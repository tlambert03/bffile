import typing
from typing import Protocol

import com.esotericsoftware.kryo
import com.esotericsoftware.kryo.io
import java.io
import java.lang
import java.net
import java.nio
import java.nio.channels
import java.util
import java.util.zip
import jpype
import jpype.protocol
import loci.common.enumeration
import loci.common.image
import loci.common.services
import loci.common.xml

class CBZip2InputStream(java.io.InputStream):
    def __init__(self, inputStream: java.io.InputStream): ...
    def close(self) -> None: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...

class CRC:
    CRC_32_TABLE: typing.ClassVar[typing.MutableSequence[int]] = ...
    def __init__(self): ...
    def getFinalCRC(self) -> int: ...
    def getGlobalCRC(self) -> int: ...
    def initialiseCRC(self) -> None: ...
    def setGlobalCRC(self, int: int) -> None: ...
    def updateCRC(self, int: int) -> None: ...

class Constants:
    ENCODING: typing.ClassVar[java.lang.String] = ...
    EPSILON: typing.ClassVar[float] = ...
    def __init__(self): ...

class DataTools:
    @staticmethod
    def allocate(*int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(
        byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(shortArray: list[int] | jpype.JArray, boolean: bool) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(
        shortArray: list[int] | jpype.JArray, int: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToDouble(
        shortArray: list[int] | jpype.JArray, int: int, int2: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(
        byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(shortArray: list[int] | jpype.JArray, boolean: bool) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(
        shortArray: list[int] | jpype.JArray, int: int, boolean: bool
    ) -> float: ...
    @typing.overload
    @staticmethod
    def bytesToFloat(
        shortArray: list[int] | jpype.JArray, int: int, int2: int, boolean: bool
    ) -> float: ...
    @staticmethod
    def bytesToHex(byteArray: list[int] | jpype.JArray | bytes) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def bytesToInt(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToInt(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToInt(
        byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToInt(shortArray: list[int] | jpype.JArray, boolean: bool) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToInt(
        shortArray: list[int] | jpype.JArray, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToInt(
        shortArray: list[int] | jpype.JArray, int: int, int2: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(
        byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(shortArray: list[int] | jpype.JArray, boolean: bool) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(
        shortArray: list[int] | jpype.JArray, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToLong(
        shortArray: list[int] | jpype.JArray, int: int, int2: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(
        byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(shortArray: list[int] | jpype.JArray, boolean: bool) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(
        shortArray: list[int] | jpype.JArray, int: int, boolean: bool
    ) -> int: ...
    @typing.overload
    @staticmethod
    def bytesToShort(
        shortArray: list[int] | jpype.JArray, int: int, int2: int, boolean: bool
    ) -> int: ...
    @staticmethod
    def containsValue(intArray: list[int] | jpype.JArray, int2: int) -> bool: ...
    @staticmethod
    def doubleToBytes(double: float, boolean: bool) -> typing.MutableSequence[int]: ...
    @staticmethod
    def doublesToBytes(
        doubleArray: list[float] | jpype.JArray, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def floatToBytes(float: float, boolean: bool) -> typing.MutableSequence[int]: ...
    @staticmethod
    def floatsToBytes(
        floatArray: list[float] | jpype.JArray, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def indexOf(intArray: list[int] | jpype.JArray, int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(
        objectArray: list[typing.Any] | jpype.JArray, object2: typing.Any
    ) -> int: ...
    @staticmethod
    def intToBytes(int: int, boolean: bool) -> typing.MutableSequence[int]: ...
    @staticmethod
    def intsToBytes(
        intArray: list[int] | jpype.JArray, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def longToBytes(long: int, boolean: bool) -> typing.MutableSequence[int]: ...
    @staticmethod
    def longsToBytes(
        longArray: list[int] | jpype.JArray, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def makeDataArray(
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        boolean: bool,
        boolean2: bool,
    ) -> typing.Any: ...
    @staticmethod
    def makeDataArray2D(
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        boolean: bool,
        boolean2: bool,
        int2: int,
    ) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def makeSigned(
        byteArray: list[int] | jpype.JArray | bytes,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def makeSigned(
        intArray: list[int] | jpype.JArray,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def makeSigned(
        shortArray: list[int] | jpype.JArray,
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def normalizeDoubles(
        doubleArray: list[float] | jpype.JArray,
    ) -> typing.MutableSequence[float]: ...
    @staticmethod
    def normalizeFloats(
        floatArray: list[float] | jpype.JArray,
    ) -> typing.MutableSequence[float]: ...
    @staticmethod
    def parseByte(string: java.lang.String | str) -> int: ...
    @staticmethod
    def parseDouble(string: java.lang.String | str) -> float: ...
    @staticmethod
    def parseFloat(string: java.lang.String | str) -> float: ...
    @staticmethod
    def parseInteger(string: java.lang.String | str) -> int: ...
    @staticmethod
    def parseLong(string: java.lang.String | str) -> int: ...
    @staticmethod
    def parseShort(string: java.lang.String | str) -> int: ...
    @staticmethod
    def readFile(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def safeMultiply32(*int: int) -> int: ...
    @staticmethod
    def safeMultiply64(*long: int) -> int: ...
    @staticmethod
    def samePrefix(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    @staticmethod
    def sanitize(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def sanitizeDouble(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def shortToBytes(short: int, boolean: bool) -> typing.MutableSequence[int]: ...
    @staticmethod
    def shortsToBytes(
        shortArray: list[int] | jpype.JArray, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def stripString(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def swap(char: str) -> str: ...
    @typing.overload
    @staticmethod
    def swap(double: float) -> float: ...
    @typing.overload
    @staticmethod
    def swap(float: float) -> float: ...
    @typing.overload
    @staticmethod
    def swap(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def swap(long: int) -> int: ...
    @typing.overload
    @staticmethod
    def swap(short: int) -> int: ...
    @staticmethod
    def unpackBytes(
        long: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        boolean: bool,
    ) -> None: ...

class DateTools:
    UNIX: typing.ClassVar[int] = ...
    COBOL: typing.ClassVar[int] = ...
    MICROSOFT: typing.ClassVar[int] = ...
    ZVI: typing.ClassVar[int] = ...
    ALT_ZVI: typing.ClassVar[int] = ...
    UNIX_EPOCH: typing.ClassVar[int] = ...
    COBOL_EPOCH: typing.ClassVar[int] = ...
    MICROSOFT_EPOCH: typing.ClassVar[int] = ...
    ZVI_EPOCH: typing.ClassVar[int] = ...
    ALT_ZVI_EPOCH: typing.ClassVar[int] = ...
    ISO8601_FORMAT_MS: typing.ClassVar[java.lang.String] = ...
    ISO8601_FORMAT: typing.ClassVar[java.lang.String] = ...
    TIMESTAMP_FORMAT: typing.ClassVar[java.lang.String] = ...
    FILENAME_FORMAT: typing.ClassVar[java.lang.String] = ...
    @typing.overload
    @staticmethod
    def convertDate(long: int, int: int) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def convertDate(
        long: int, int: int, string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def convertDate(
        long: int, int: int, string: java.lang.String | str, boolean: bool
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str, string2: java.lang.String | str, boolean: bool
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        boolean: bool,
        string3: java.lang.String | str,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        boolean: bool,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        boolean: bool,
        string3: java.lang.String | str,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def formatDate(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        string3: java.lang.String | str,
    ) -> java.lang.String: ...
    @staticmethod
    def getFileTimestamp() -> java.lang.String: ...
    @staticmethod
    def getMillisFromTicks(long: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def getTime(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getTime(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ) -> int: ...
    @staticmethod
    def getTimestamp() -> java.lang.String: ...

class DebugTools:
    @staticmethod
    def enableIJLogging(boolean: bool) -> bool: ...
    @typing.overload
    @staticmethod
    def enableLogging() -> bool: ...
    @typing.overload
    @staticmethod
    def enableLogging(string: java.lang.String | str) -> bool: ...
    @staticmethod
    def getFieldName(class_: type[typing.Any], int: int) -> java.lang.String: ...
    @staticmethod
    def getStackTrace(throwable: java.lang.Throwable) -> java.lang.String: ...
    @staticmethod
    def isEnabled() -> bool: ...
    @staticmethod
    def setRootLevel(string: java.lang.String | str) -> None: ...

class HandleException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class IRandomAccess(java.io.DataInput, java.io.DataOutput):
    def close(self) -> None: ...
    def exists(self) -> bool: ...
    def getFilePointer(self) -> int: ...
    def getOrder(self) -> java.nio.ByteOrder: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    def seek(self, long: int) -> None: ...
    def setOrder(self, byteOrder: java.nio.ByteOrder) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...

class IniList(java.util.ArrayList["IniTable"]):
    def __init__(self): ...
    def flattenIntoHashMap(
        self,
    ) -> java.util.HashMap[java.lang.String, java.lang.String]: ...
    def getHeaders(self) -> java.util.List[java.lang.String]: ...
    def getTable(self, string: java.lang.String | str) -> IniTable: ...

class IniParser:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def openTextResource(string: java.lang.String | str) -> java.io.BufferedReader: ...
    @typing.overload
    @staticmethod
    def openTextResource(
        string: java.lang.String | str, class_: type[typing.Any]
    ) -> java.io.BufferedReader: ...
    @typing.overload
    def parseINI(self, bufferedReader: java.io.BufferedReader) -> IniList: ...
    @typing.overload
    def parseINI(self, file: java.io.File | jpype.protocol.SupportsPath) -> IniList: ...
    @typing.overload
    def parseINI(self, string: java.lang.String | str) -> IniList: ...
    @typing.overload
    def parseINI(
        self, string: java.lang.String | str, class_: type[typing.Any]
    ) -> IniList: ...
    def setBackslashContinuesLine(self, boolean: bool) -> None: ...
    def setCommentDelimiter(self, string: java.lang.String | str) -> None: ...

class IniTable(java.util.HashMap[java.lang.String, java.lang.String]):
    HEADER_KEY: typing.ClassVar[java.lang.String] = ...
    DEFAULT_HEADER: typing.ClassVar[java.lang.String] = ...
    def __init__(self): ...

class IniWriter:
    def __init__(self): ...
    @typing.overload
    def saveINI(self, iniList: IniList, string: java.lang.String | str) -> None: ...
    @typing.overload
    def saveINI(
        self, iniList: IniList, string: java.lang.String | str, boolean: bool
    ) -> None: ...
    @typing.overload
    def saveINI(
        self,
        iniList: IniList,
        string: java.lang.String | str,
        boolean: bool,
        boolean2: bool,
    ) -> None: ...

class Location:
    @typing.overload
    def __init__(self, file: java.io.File | jpype.protocol.SupportsPath): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(self, location: Location, string: java.lang.String | str): ...
    @staticmethod
    def cacheDirectoryListings(boolean: bool) -> None: ...
    def canRead(self) -> bool: ...
    def canWrite(self) -> bool: ...
    @staticmethod
    def checkValidId(string: java.lang.String | str) -> None: ...
    @staticmethod
    def cleanStaleCacheEntries() -> None: ...
    @staticmethod
    def clearDirectoryListingsCache() -> None: ...
    def createNewFile(self) -> bool: ...
    def delete(self) -> bool: ...
    def deleteOnExit(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exists(self) -> bool: ...
    def getAbsoluteFile(self) -> Location: ...
    def getAbsolutePath(self) -> java.lang.String: ...
    def getCanonicalFile(self) -> Location: ...
    def getCanonicalPath(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getHandle(string: java.lang.String | str) -> IRandomAccess: ...
    @typing.overload
    @staticmethod
    def getHandle(string: java.lang.String | str, boolean: bool) -> IRandomAccess: ...
    @typing.overload
    @staticmethod
    def getHandle(
        string: java.lang.String | str, boolean: bool, boolean2: bool
    ) -> IRandomAccess: ...
    @typing.overload
    @staticmethod
    def getHandle(
        string: java.lang.String | str, boolean: bool, boolean2: bool, int: int
    ) -> IRandomAccess: ...
    @staticmethod
    def getIdMap() -> java.util.HashMap[java.lang.String, typing.Any]: ...
    @staticmethod
    def getMappedFile(string: java.lang.String | str) -> IRandomAccess: ...
    @staticmethod
    def getMappedId(string: java.lang.String | str) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getParent(self) -> java.lang.String: ...
    def getParentFile(self) -> Location: ...
    def getPath(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isDirectory(self) -> bool: ...
    def isFile(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def lastModified(self) -> int: ...
    def length(self) -> int: ...
    @typing.overload
    def list(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def list(self, boolean: bool) -> typing.MutableSequence[java.lang.String]: ...
    def listFiles(self) -> typing.MutableSequence[Location]: ...
    @staticmethod
    def mapFile(
        string: java.lang.String | str, iRandomAccess: IRandomAccess
    ) -> None: ...
    @staticmethod
    def mapId(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    def mkdirs(self) -> bool: ...
    @staticmethod
    def reset() -> None: ...
    @staticmethod
    def setCacheDirectoryTimeout(double: float) -> None: ...
    @staticmethod
    def setIdMap(
        hashMap: java.util.HashMap[java.lang.String | str, typing.Any],
    ) -> None: ...
    def toString(self) -> java.lang.String: ...
    def toURL(self) -> java.net.URL: ...

class Log4jTools:
    @staticmethod
    def enableLogging() -> bool: ...
    @staticmethod
    def isEnabled() -> bool: ...
    @staticmethod
    def setRootLevel(string: java.lang.String | str) -> None: ...

class NIOByteBufferProvider:
    MINIMUM_JAVA_VERSION: typing.ClassVar[int] = ...
    def __init__(
        self,
        fileChannel: java.nio.channels.FileChannel,
        mapMode: java.nio.channels.FileChannel.MapMode,
    ): ...
    def allocate(self, long: int, int: int) -> java.nio.ByteBuffer: ...

class NIOInputStream(java.io.InputStream, java.io.DataInput):
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, iRandomAccess: IRandomAccess): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    @typing.overload
    def findString(
        self, boolean: bool, int: int, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(
        self, boolean: bool, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(
        self, int: int, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(self, *string: java.lang.String | str) -> java.lang.String: ...
    def getFilePointer(self) -> int: ...
    def getInputStream(self) -> java.io.DataInputStream: ...
    def isLittleEndian(self) -> bool: ...
    def length(self) -> int: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    def order(self, boolean: bool) -> None: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readCString(self) -> java.lang.String: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    @typing.overload
    def readString(self, int: int) -> java.lang.String: ...
    @typing.overload
    def readString(self, string: java.lang.String | str) -> java.lang.String: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def reset(self) -> None: ...
    def seek(self, long: int) -> None: ...
    def setExtend(self, int: int) -> None: ...
    def skipBytes(self, int: int) -> int: ...

class RandomAccessInputStream(
    java.io.InputStream,
    java.io.DataInput,
    java.io.Closeable,
    com.esotericsoftware.kryo.KryoSerializable,
):
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(self, iRandomAccess: IRandomAccess): ...
    @typing.overload
    def __init__(
        self, iRandomAccess: IRandomAccess, string: java.lang.String | str
    ): ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    @typing.overload
    def findString(
        self, boolean: bool, int: int, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(
        self, boolean: bool, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(
        self, int: int, *string: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def findString(self, *string: java.lang.String | str) -> java.lang.String: ...
    def getFilePointer(self) -> int: ...
    def isBitOnByteBoundary(self) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def length(self) -> int: ...
    def mark(self, int: int) -> None: ...
    def markSupported(self) -> bool: ...
    def order(self, boolean: bool) -> None: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    @typing.overload
    def read(
        self,
        kryo: com.esotericsoftware.kryo.Kryo,
        input: com.esotericsoftware.kryo.io.Input,
    ) -> None: ...
    def readBits(self, int: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readByteToString(self, int: int) -> java.lang.String: ...
    def readCString(self) -> java.lang.String: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    @typing.overload
    def readString(self, int: int) -> java.lang.String: ...
    @typing.overload
    def readString(self, string: java.lang.String | str) -> java.lang.String: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedInt(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def reset(self) -> None: ...
    def seek(self, long: int) -> None: ...
    def setEncoding(self, string: java.lang.String | str) -> None: ...
    def setLength(self, long: int) -> None: ...
    def skipBits(self, long: int) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    def write(
        self,
        kryo: com.esotericsoftware.kryo.Kryo,
        output: com.esotericsoftware.kryo.io.Output,
    ) -> None: ...

class RandomAccessOutputStream(
    java.io.OutputStream, java.io.DataOutput, java.io.Closeable
):
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, iRandomAccess: IRandomAccess): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def getFilePointer(self) -> int: ...
    def isLittleEndian(self) -> bool: ...
    def length(self) -> int: ...
    def order(self, boolean: bool) -> None: ...
    def seek(self, long: int) -> None: ...
    def skipBytes(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...
    @typing.overload
    def writeBits(self, int: int, int2: int) -> None: ...
    @typing.overload
    def writeBits(self, string: java.lang.String | str) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String | str) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String | str) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLine(self, string: java.lang.String | str) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String | str) -> None: ...

class ReflectException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ReflectedUniverse:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, uRLArray: list[java.net.URL] | jpype.JArray): ...
    def exec_(self, string: java.lang.String | str) -> typing.Any: ...
    def getVar(self, string: java.lang.String | str) -> typing.Any: ...
    def isAccessibilityIgnored(self) -> bool: ...
    @staticmethod
    def isInstance(class_: type[typing.Any], object: typing.Any) -> bool: ...
    @staticmethod
    def main(stringArray: list[java.lang.String] | jpype.JArray) -> None: ...
    def setAccessibilityIgnored(self, boolean: bool) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, boolean: bool) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, byte: int) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, char: str) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, double: float) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, float: float) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, int: int) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, object: typing.Any) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, long: int) -> None: ...
    @typing.overload
    def setVar(self, string: java.lang.String | str, short: int) -> None: ...

class Region:
    x: int = ...
    y: int = ...
    width: int = ...
    height: int = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int): ...
    def containsPoint(self, int: int, int2: int) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def intersection(self, region: Region) -> Region: ...
    def intersects(self, region: Region) -> bool: ...
    def toString(self) -> java.lang.String: ...

class StatusEvent:
    @typing.overload
    def __init__(self, int: int, int2: int, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, int: int, int2: int, string: java.lang.String | str, boolean: bool
    ): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, boolean: bool): ...
    def getProgressMaximum(self) -> int: ...
    def getProgressValue(self) -> int: ...
    def getStatusMessage(self) -> java.lang.String: ...
    def isWarning(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class StatusListener(java.util.EventListener):
    def statusUpdated(self, statusEvent: StatusEvent) -> None: ...

class StatusReporter:
    def addStatusListener(
        self, statusListener: StatusListener | typing.Callable
    ) -> None: ...
    def notifyListeners(self, statusEvent: StatusEvent) -> None: ...
    def removeStatusListener(
        self, statusListener: StatusListener | typing.Callable
    ) -> None: ...

class AbstractNIOHandle(IRandomAccess):
    def __init__(self): ...
    def exists(self) -> bool: ...

class CaseInsensitiveLocation(Location):
    @typing.overload
    def __init__(self, file: java.io.File | jpype.protocol.SupportsPath): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        caseInsensitiveLocation: CaseInsensitiveLocation,
        string: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(self, location: Location): ...
    @typing.overload
    @staticmethod
    def invalidateCache() -> None: ...
    @typing.overload
    @staticmethod
    def invalidateCache(file: java.io.File | jpype.protocol.SupportsPath) -> None: ...

class FileHandle(IRandomAccess):
    @typing.overload
    def __init__(
        self,
        file: java.io.File | jpype.protocol.SupportsPath,
        string: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def close(self) -> None: ...
    def exists(self) -> bool: ...
    def getFilePointer(self) -> int: ...
    def getOrder(self) -> java.nio.ByteOrder: ...
    def getRandomAccessFile(self) -> java.io.RandomAccessFile: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def seek(self, long: int) -> None: ...
    def setOrder(self, byteOrder: java.nio.ByteOrder) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String | str) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String | str) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String | str) -> None: ...

class StreamHandle(IRandomAccess):
    def __init__(self): ...
    def close(self) -> None: ...
    def exists(self) -> bool: ...
    def getFilePointer(self) -> int: ...
    def getOrder(self) -> java.nio.ByteOrder: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def seek(self, long: int) -> None: ...
    def setOrder(self, byteOrder: java.nio.ByteOrder) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String | str) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String | str) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String | str) -> None: ...
    class Settings:
        def __init__(self): ...
        def get(self, string: java.lang.String | str) -> java.lang.String: ...
        def getRemoteCacheRootDir(self) -> java.lang.String: ...

class BZip2Handle(StreamHandle):
    def __init__(self, string: java.lang.String | str): ...
    @staticmethod
    def isBZip2File(string: java.lang.String | str) -> bool: ...

class ByteArrayHandle(AbstractNIOHandle):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, byteBuffer: java.nio.ByteBuffer): ...
    def close(self) -> None: ...
    def getByteBuffer(self) -> java.nio.ByteBuffer: ...
    def getBytes(self) -> typing.MutableSequence[int]: ...
    def getFilePointer(self) -> int: ...
    def getOrder(self) -> java.nio.ByteOrder: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def seek(self, long: int) -> None: ...
    def setLength(self, long: int) -> None: ...
    def setOrder(self, byteOrder: java.nio.ByteOrder) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String | str) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String | str) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String | str) -> None: ...

class GZipHandle(StreamHandle):
    def __init__(self, string: java.lang.String | str): ...
    @staticmethod
    def isGZipFile(string: java.lang.String | str) -> bool: ...

class NIOFileHandle(AbstractNIOHandle):
    @typing.overload
    def __init__(
        self,
        file: java.io.File | jpype.protocol.SupportsPath,
        string: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        file: java.io.File | jpype.protocol.SupportsPath,
        string: java.lang.String | str,
        int: int,
    ): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def close(self) -> None: ...
    def getBufferSize(self) -> int: ...
    def getFileChannel(self) -> java.nio.channels.FileChannel: ...
    def getFilePointer(self) -> int: ...
    def getOrder(self) -> java.nio.ByteOrder: ...
    def getRandomAccessFile(self) -> java.io.RandomAccessFile: ...
    def length(self) -> int: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer) -> int: ...
    @typing.overload
    def read(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> int: ...
    def readBoolean(self) -> bool: ...
    def readByte(self) -> int: ...
    def readChar(self) -> str: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    @typing.overload
    def readFully(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def readFully(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def readInt(self) -> int: ...
    def readLine(self) -> java.lang.String: ...
    def readLong(self) -> int: ...
    def readShort(self) -> int: ...
    def readUTF(self) -> java.lang.String: ...
    def readUnsignedByte(self) -> int: ...
    def readUnsignedShort(self) -> int: ...
    def seek(self, long: int) -> None: ...
    @staticmethod
    def setDefaultBufferSize(int: int) -> None: ...
    @staticmethod
    def setDefaultReadWriteBufferSize(int: int) -> None: ...
    def setLength(self, long: int) -> None: ...
    def setOrder(self, byteOrder: java.nio.ByteOrder) -> None: ...
    @typing.overload
    def skipBytes(self, int: int) -> int: ...
    @typing.overload
    def skipBytes(self, long: int) -> int: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def write(self, byteBuffer: java.nio.ByteBuffer, int: int, int2: int) -> None: ...
    def writeBoolean(self, boolean: bool) -> None: ...
    def writeByte(self, int: int) -> None: ...
    def writeBytes(self, string: java.lang.String | str) -> None: ...
    def writeChar(self, int: int) -> None: ...
    def writeChars(self, string: java.lang.String | str) -> None: ...
    def writeDouble(self, double: float) -> None: ...
    def writeFloat(self, float: float) -> None: ...
    def writeInt(self, int: int) -> None: ...
    def writeLong(self, long: int) -> None: ...
    def writeShort(self, int: int) -> None: ...
    def writeUTF(self, string: java.lang.String | str) -> None: ...

class S3Handle(StreamHandle):
    DEFAULT_S3_PROTOCOL: typing.ClassVar[java.lang.String] = ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        boolean: bool,
        settings: StreamHandle.Settings,
    ): ...
    @staticmethod
    def cacheObject(
        string: java.lang.String | str, settings: StreamHandle.Settings
    ) -> java.lang.String: ...
    @staticmethod
    def canHandleScheme(string: java.lang.String | str) -> bool: ...
    def exists(self) -> bool: ...
    def getBucket(self) -> java.lang.String: ...
    def getCacheKey(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getServer(self) -> java.lang.String: ...
    def isBucket(self) -> bool: ...
    def length(self) -> int: ...
    def seek(self, long: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class URLHandle(StreamHandle):
    def __init__(self, string: java.lang.String | str): ...
    def seek(self, long: int) -> None: ...

class ZipHandle(StreamHandle):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, zipEntry: java.util.zip.ZipEntry
    ): ...
    def close(self) -> None: ...
    def getEntryCount(self) -> int: ...
    def getEntryName(self) -> java.lang.String: ...
    def getInputStream(self) -> java.io.DataInputStream: ...
    @staticmethod
    def isZipFile(string: java.lang.String | str) -> bool: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("loci.common")``.

    AbstractNIOHandle: type[AbstractNIOHandle]
    BZip2Handle: type[BZip2Handle]
    ByteArrayHandle: type[ByteArrayHandle]
    CBZip2InputStream: type[CBZip2InputStream]
    CRC: type[CRC]
    CaseInsensitiveLocation: type[CaseInsensitiveLocation]
    Constants: type[Constants]
    DataTools: type[DataTools]
    DateTools: type[DateTools]
    DebugTools: type[DebugTools]
    FileHandle: type[FileHandle]
    GZipHandle: type[GZipHandle]
    HandleException: type[HandleException]
    IRandomAccess: type[IRandomAccess]
    IniList: type[IniList]
    IniParser: type[IniParser]
    IniTable: type[IniTable]
    IniWriter: type[IniWriter]
    Location: type[Location]
    Log4jTools: type[Log4jTools]
    NIOByteBufferProvider: type[NIOByteBufferProvider]
    NIOFileHandle: type[NIOFileHandle]
    NIOInputStream: type[NIOInputStream]
    RandomAccessInputStream: type[RandomAccessInputStream]
    RandomAccessOutputStream: type[RandomAccessOutputStream]
    ReflectException: type[ReflectException]
    ReflectedUniverse: type[ReflectedUniverse]
    Region: type[Region]
    S3Handle: type[S3Handle]
    StatusEvent: type[StatusEvent]
    StatusListener: type[StatusListener]
    StatusReporter: type[StatusReporter]
    StreamHandle: type[StreamHandle]
    URLHandle: type[URLHandle]
    ZipHandle: type[ZipHandle]
    enumeration: loci.common.enumeration.__module_protocol__
    image: loci.common.image.__module_protocol__
    services: loci.common.services.__module_protocol__
    xml: loci.common.xml.__module_protocol__
