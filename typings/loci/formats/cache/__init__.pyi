import typing
from typing import Protocol

import java.lang
import java.util
import jpype
import loci.formats

class CacheEvent:
    SOURCE_CHANGED: typing.ClassVar[int] = ...
    STRATEGY_CHANGED: typing.ClassVar[int] = ...
    POSITION_CHANGED: typing.ClassVar[int] = ...
    PRIORITIES_CHANGED: typing.ClassVar[int] = ...
    ORDER_CHANGED: typing.ClassVar[int] = ...
    RANGE_CHANGED: typing.ClassVar[int] = ...
    OBJECT_LOADED: typing.ClassVar[int] = ...
    OBJECT_DROPPED: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, object: typing.Any, int: int): ...
    @typing.overload
    def __init__(self, object: typing.Any, int: int, int2: int): ...
    def getIndex(self) -> int: ...
    def getSource(self) -> typing.Any: ...
    def getType(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class CacheException(loci.formats.FormatException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class CacheListener:
    def cacheUpdated(self, cacheEvent: CacheEvent) -> None: ...

class CacheReporter:
    def addCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...
    def getCacheListeners(self) -> typing.MutableSequence[CacheListener]: ...
    def removeCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...

class CacheUpdater(java.lang.Thread):
    def __init__(self, cache: Cache): ...
    def quit(self) -> None: ...
    def run(self) -> None: ...

class ICacheSource:
    def getObject(self, int: int) -> typing.Any: ...
    def getObjectCount(self) -> int: ...

class Cache(CacheReporter):
    def __init__(
        self, iCacheStrategy: ICacheStrategy, iCacheSource: ICacheSource, boolean: bool
    ): ...
    def addCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...
    def getCacheListeners(self) -> typing.MutableSequence[CacheListener]: ...
    def getCurrentPos(self) -> typing.MutableSequence[int]: ...
    def getObject(self, intArray: list[int] | jpype.JArray) -> typing.Any: ...
    def getSource(self) -> ICacheSource: ...
    def getStrategy(self) -> ICacheStrategy: ...
    @typing.overload
    def isInCache(self, int: int) -> bool: ...
    @typing.overload
    def isInCache(self, intArray: list[int] | jpype.JArray) -> bool: ...
    @typing.overload
    def recache(self) -> None: ...
    @typing.overload
    def recache(self, int: int) -> None: ...
    def removeCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...
    def reset(self) -> None: ...
    def setCurrentPos(self, intArray: list[int] | jpype.JArray) -> None: ...
    def setSource(self, iCacheSource: ICacheSource) -> None: ...
    def setStrategy(self, iCacheStrategy: ICacheStrategy) -> None: ...

class CacheSource(ICacheSource):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, iFormatReader: loci.formats.IFormatReader): ...
    def getObject(self, int: int) -> typing.Any: ...
    def getObjectCount(self) -> int: ...

class ICacheStrategy(CacheReporter):
    MIN_PRIORITY: typing.ClassVar[int] = ...
    LOW_PRIORITY: typing.ClassVar[int] = ...
    NORMAL_PRIORITY: typing.ClassVar[int] = ...
    HIGH_PRIORITY: typing.ClassVar[int] = ...
    MAX_PRIORITY: typing.ClassVar[int] = ...
    CENTERED_ORDER: typing.ClassVar[int] = ...
    FORWARD_ORDER: typing.ClassVar[int] = ...
    BACKWARD_ORDER: typing.ClassVar[int] = ...
    def getLengths(self) -> typing.MutableSequence[int]: ...
    def getLoadList(
        self, intArray: list[int] | jpype.JArray
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getOrder(self) -> typing.MutableSequence[int]: ...
    def getPriorities(self) -> typing.MutableSequence[int]: ...
    def getRange(self) -> typing.MutableSequence[int]: ...
    def setOrder(self, int: int, int2: int) -> None: ...
    def setPriority(self, int: int, int2: int) -> None: ...
    def setRange(self, int: int, int2: int) -> None: ...

class ByteArraySource(CacheSource):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, iFormatReader: loci.formats.IFormatReader): ...
    def getObject(self, int: int) -> typing.Any: ...

class CacheStrategy(CacheReporter, java.util.Comparator, ICacheStrategy):
    DEFAULT_RANGE: typing.ClassVar[int] = ...
    def __init__(self, intArray: list[int] | jpype.JArray): ...
    def addCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...
    def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    def distance(self, int: int, int2: int) -> int: ...
    def getCacheListeners(self) -> typing.MutableSequence[CacheListener]: ...
    def getLengths(self) -> typing.MutableSequence[int]: ...
    def getLoadList(
        self, intArray: list[int] | jpype.JArray
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getOrder(self) -> typing.MutableSequence[int]: ...
    def getPriorities(self) -> typing.MutableSequence[int]: ...
    def getRange(self) -> typing.MutableSequence[int]: ...
    def removeCacheListener(
        self, cacheListener: CacheListener | typing.Callable
    ) -> None: ...
    def setOrder(self, int: int, int2: int) -> None: ...
    def setPriority(self, int: int, int2: int) -> None: ...
    def setRange(self, int: int, int2: int) -> None: ...

class CrosshairStrategy(CacheStrategy):
    def __init__(self, intArray: list[int] | jpype.JArray): ...

class RectangleStrategy(CacheStrategy):
    def __init__(self, intArray: list[int] | jpype.JArray): ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("loci.formats.cache")``.

    ByteArraySource: type[ByteArraySource]
    Cache: type[Cache]
    CacheEvent: type[CacheEvent]
    CacheException: type[CacheException]
    CacheListener: type[CacheListener]
    CacheReporter: type[CacheReporter]
    CacheSource: type[CacheSource]
    CacheStrategy: type[CacheStrategy]
    CacheUpdater: type[CacheUpdater]
    CrosshairStrategy: type[CrosshairStrategy]
    ICacheSource: type[ICacheSource]
    ICacheStrategy: type[ICacheStrategy]
    RectangleStrategy: type[RectangleStrategy]
