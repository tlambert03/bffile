import typing
from typing import Protocol

import java.lang
import java.util
import jpype
import loci
import loci.formats
import loci.formats.meta
import ome.units.quantity
import org.slf4j
import org.w3c.dom

class Channel:
    channelTag: int = ...
    resolution: int = ...
    min: float = ...
    max: float = ...
    unit: java.lang.String = ...
    lutName: java.lang.String = ...
    bytesInc: int = ...
    isLutInverted: bool = ...
    bitInc: int = ...
    dataType: int = ...
    nameOfMeasuredQuantity: java.lang.String = ...
    channelType: Channel.ChannelType = ...
    def __init__(
        self,
        int: int,
        int2: int,
        double: float,
        double2: float,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        long: int,
    ): ...
    class ChannelType(java.lang.Enum["Channel.ChannelType"]):
        MONO: typing.ClassVar[Channel.ChannelType] = ...
        RED: typing.ClassVar[Channel.ChannelType] = ...
        GREEN: typing.ClassVar[Channel.ChannelType] = ...
        BLUE: typing.ClassVar[Channel.ChannelType] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> Channel.ChannelType: ...
        @staticmethod
        def values() -> typing.MutableSequence[Channel.ChannelType]: ...

class Dimension:
    key: Dimension.DimensionKey = ...
    size: int = ...
    bytesInc: int = ...
    unit: java.lang.String = ...
    oldPhysicalSize: bool = ...
    frameIndex: int = ...
    def __init__(
        self,
        dimensionKey: Dimension.DimensionKey,
        int: int,
        long: int,
        string: java.lang.String | str,
        double: float,
        boolean: bool,
    ): ...
    @staticmethod
    def createChannelDimension(int: int, long: int) -> Dimension: ...
    def getLength(self) -> float: ...
    def setLength(self, double: float) -> None: ...
    class DimensionKey(java.lang.Enum["Dimension.DimensionKey"]):
        X: typing.ClassVar[Dimension.DimensionKey] = ...
        Y: typing.ClassVar[Dimension.DimensionKey] = ...
        Z: typing.ClassVar[Dimension.DimensionKey] = ...
        T: typing.ClassVar[Dimension.DimensionKey] = ...
        C: typing.ClassVar[Dimension.DimensionKey] = ...
        S: typing.ClassVar[Dimension.DimensionKey] = ...
        id: int = ...
        token: str = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> Dimension.DimensionKey: ...
        @staticmethod
        def values() -> typing.MutableSequence[Dimension.DimensionKey]: ...
        @staticmethod
        def with_(int: int) -> Dimension.DimensionKey: ...

class LMSCollectionXmlDocument(
    loci.formats.in_.LeicaMicrosystemsMetadata.LMSXmlDocument
):
    def __init__(
        self,
        string: java.lang.String | str,
        lMSCollectionXmlDocument: LMSCollectionXmlDocument,
    ): ...
    def getChildrenFiles(self, boolean: bool) -> java.util.List[java.lang.String]: ...
    def getXlifs(self) -> java.util.List[XlifDocument]: ...

class LMSFileReader(loci.formats.FormatReader):
    OLD_PHYSICAL_SIZE_KEY: typing.ClassVar[java.lang.String] = ...
    OLD_PHYSICAL_SIZE_DEFAULT: typing.ClassVar[bool] = ...
    log: typing.ClassVar[org.slf4j.Logger] = ...
    metaTemp: MetadataTempBuffer = ...
    associatedXmlDoc: LMSXmlDocument = ...
    def addSeriesMeta(
        self, string: java.lang.String | str, object: typing.Any
    ) -> None: ...
    def addSeriesMetaList(
        self, string: java.lang.String | str, object: typing.Any
    ) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    @staticmethod
    def fileExists(string: java.lang.String | str) -> bool: ...
    def getCore(self) -> java.util.List[loci.formats.CoreMetadata]: ...
    def getImageFormat(self) -> LMSFileReader.ImageFormat: ...
    def makeFilterMetadata(self) -> loci.formats.meta.MetadataStore: ...
    def setCore(
        self, arrayList: java.util.ArrayList[loci.formats.CoreMetadata]
    ) -> None: ...
    @typing.overload
    def translateMetadata(self, list: java.util.List[LMSImageXmlDocument]) -> None: ...
    @typing.overload
    def translateMetadata(self, lMSImageXmlDocument: LMSImageXmlDocument) -> None: ...
    def useOldPhysicalSizeCalculation(self) -> bool: ...
    class ImageFormat(java.lang.Enum["LMSFileReader.ImageFormat"]):
        LOF: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        TIF: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        BMP: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        JPEG: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        PNG: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        UNKNOWN: typing.ClassVar[LMSFileReader.ImageFormat] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> LMSFileReader.ImageFormat: ...
        @staticmethod
        def values() -> typing.MutableSequence[LMSFileReader.ImageFormat]: ...

class LMSImageXmlDocument(loci.formats.in_.LeicaMicrosystemsMetadata.LMSXmlDocument):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        lMSCollectionXmlDocument: LMSCollectionXmlDocument,
    ): ...
    def getImageName(self) -> java.lang.String: ...
    def getImageNode(self) -> org.w3c.dom.Node: ...

class LMSMetadataExtractor:
    def __init__(self, lMSFileReader: LMSFileReader): ...
    @staticmethod
    def getChannelIndex(element: org.w3c.dom.Element) -> int: ...
    def parseDouble(self, string: java.lang.String | str) -> float: ...
    def parseInt(self, string: java.lang.String | str) -> int: ...
    def parseLong(self, string: java.lang.String | str) -> int: ...
    def translateAttachmentNodes(
        self, element: org.w3c.dom.Element, int: int
    ) -> None: ...
    def translateChannelDescriptions(
        self, element: org.w3c.dom.Element, int: int
    ) -> None: ...
    def translateDetectors(self, element: org.w3c.dom.Element, int: int) -> None: ...
    def translateFilterSettings(
        self, element: org.w3c.dom.Element, int: int
    ) -> None: ...
    def translateImage(self, element: org.w3c.dom.Element, int: int) -> None: ...
    def translateLaserLines(self, element: org.w3c.dom.Element, int: int) -> None: ...
    def translateMetadata(self, list: java.util.List[LMSImageXmlDocument]) -> None: ...
    def translateROIs(self, element: org.w3c.dom.Element, int: int) -> None: ...
    def translateScannerSettings(
        self, element: org.w3c.dom.Element, int: int
    ) -> None: ...
    def translateSingleROIs(self, element: org.w3c.dom.Element, int: int) -> None: ...
    def translateTimestamps(self, element: org.w3c.dom.Element, int: int) -> None: ...

class LMSXmlDocument:
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        lMSCollectionXmlDocument: LMSCollectionXmlDocument,
    ): ...
    def getDoc(self) -> org.w3c.dom.Document: ...
    def getFilepath(self) -> java.lang.String: ...
    def getParentFiles(self) -> java.util.List[java.lang.String]: ...
    def nodeToString(self, node: org.w3c.dom.Node) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def xPath(self, string: java.lang.String | str) -> org.w3c.dom.NodeList: ...
    @typing.overload
    def xPath(
        self, node: org.w3c.dom.Node, string: java.lang.String | str
    ) -> org.w3c.dom.NodeList: ...
    class InitFrom(java.lang.Enum["LMSXmlDocument.InitFrom"]):
        XML: typing.ClassVar[LMSXmlDocument.InitFrom] = ...
        FILEPATH: typing.ClassVar[LMSXmlDocument.InitFrom] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> LMSXmlDocument.InitFrom: ...
        @staticmethod
        def values() -> typing.MutableSequence[LMSXmlDocument.InitFrom]: ...

class LofXmlDocument(LMSImageXmlDocument):
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def getImageName(self) -> java.lang.String: ...
    def getImageNode(self) -> org.w3c.dom.Node: ...

class MetadataStoreInitializer:
    def __init__(self, lMSFileReader: LMSFileReader): ...
    def checkFlip(
        self, boolean: bool, length: ome.units.quantity.Length
    ) -> ome.units.quantity.Length: ...
    def getTileIndex(self, int: int) -> int: ...
    def initDetectorModels(self, int: int) -> None: ...
    def initFilterModels(self, int: int) -> None: ...
    def initImageDetails(self, int: int) -> None: ...
    def initLasers(self, int: int) -> None: ...
    def initMetadataStore(self) -> None: ...
    def initStandDetails(self, int: int) -> None: ...

class MetadataTempBuffer:
    channelColors: java.util.List = ...
    channelPrios: typing.MutableSequence[typing.MutableSequence[int]] = ...
    physicalSizeXs: java.util.List = ...
    physicalSizeYs: java.util.List = ...
    fieldPosX: java.util.List = ...
    fieldPosY: java.util.List = ...
    descriptions: typing.MutableSequence[java.lang.String] = ...
    microscopeModels: typing.MutableSequence[java.lang.String] = ...
    serialNumber: typing.MutableSequence[java.lang.String] = ...
    pinholes: typing.MutableSequence[float] = ...
    zooms: typing.MutableSequence[float] = ...
    zSteps: typing.MutableSequence[float] = ...
    tSteps: typing.MutableSequence[float] = ...
    lensNA: typing.MutableSequence[float] = ...
    flipX: typing.MutableSequence[bool] = ...
    flipY: typing.MutableSequence[bool] = ...
    swapXY: typing.MutableSequence[bool] = ...
    expTimes: typing.MutableSequence[typing.MutableSequence[float]] = ...
    gains: typing.MutableSequence[typing.MutableSequence[float]] = ...
    detectorOffsets: typing.MutableSequence[typing.MutableSequence[float]] = ...
    channelNames: typing.MutableSequence[typing.MutableSequence[java.lang.String]] = ...
    detectorModels: java.util.ArrayList = ...
    exWaves: typing.MutableSequence[typing.MutableSequence[float]] = ...
    activeDetector: java.util.ArrayList = ...
    detectorIndexes: java.util.ArrayList = ...
    immersions: typing.MutableSequence[java.lang.String] = ...
    corrections: typing.MutableSequence[java.lang.String] = ...
    objectiveModels: typing.MutableSequence[java.lang.String] = ...
    magnification: typing.MutableSequence[float] = ...
    posX: typing.MutableSequence[ome.units.quantity.Length] = ...
    posY: typing.MutableSequence[ome.units.quantity.Length] = ...
    posZ: typing.MutableSequence[ome.units.quantity.Length] = ...
    refractiveIndex: typing.MutableSequence[float] = ...
    cutIns: java.util.ArrayList = ...
    cutOuts: java.util.ArrayList = ...
    filterModels: java.util.ArrayList = ...
    timestamps: typing.MutableSequence[typing.MutableSequence[float]] = ...
    laserIntensity: java.util.ArrayList = ...
    laserWavelength: java.util.ArrayList = ...
    laserActive: java.util.ArrayList = ...
    laserFrap: java.util.ArrayList = ...
    imageROIs: typing.MutableSequence[typing.MutableSequence[ROI]] = ...
    alternateCenter: bool = ...
    imageNames: typing.MutableSequence[java.lang.String] = ...
    acquiredDate: typing.MutableSequence[float] = ...
    tileCount: typing.MutableSequence[int] = ...
    tileBytesInc: typing.MutableSequence[int] = ...
    inverseRgb: typing.MutableSequence[bool] = ...
    channels: java.util.ArrayList = ...
    def __init__(self, int: int): ...
    def addChannelDimension(self, int: int) -> None: ...
    def addDimension(self, int: int, dimension: Dimension) -> None: ...
    def addMissingDimensions(self, int: int) -> None: ...
    def getDimension(
        self, int: int, dimensionKey: Dimension.DimensionKey
    ) -> Dimension: ...
    def getDimensionOrder(self, int: int) -> java.lang.String: ...
    def getDimensions(self, int: int) -> java.util.ArrayList[Dimension]: ...

class MultipleImagesReader(LMSFileReader):
    def __init__(self, xlifDocument: XlifDocument, int: int): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def getBitsPerPixel(self) -> int: ...
    def getImageFormat(self) -> LMSFileReader.ImageFormat: ...
    def getPixelType(self) -> int: ...
    def getRGBChannelCount(self) -> int: ...
    def getSizeC(self) -> int: ...
    def isRGB(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def setCoreMetadata(self, coreMetadata: loci.formats.CoreMetadata) -> None: ...
    def setMetadataTempBuffer(self, metadataTempBuffer: MetadataTempBuffer) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def swapDimensions(self) -> None: ...

class XlcfDocument(LMSCollectionXmlDocument):
    def __init__(
        self,
        string: java.lang.String | str,
        lMSCollectionXmlDocument: LMSCollectionXmlDocument,
    ): ...

class XlefDocument(LMSCollectionXmlDocument):
    def __init__(self, string: java.lang.String | str): ...
    def getImageCount(self) -> int: ...
    def printReferences(self) -> None: ...

class XlifDocument(LMSImageXmlDocument):
    def __init__(
        self,
        string: java.lang.String | str,
        lMSCollectionXmlDocument: LMSCollectionXmlDocument,
    ): ...
    def getElementNode(self) -> org.w3c.dom.Node: ...
    def getImageFormat(self) -> LMSFileReader.ImageFormat: ...
    def getImageName(self) -> java.lang.String: ...
    def getImageNode(self) -> org.w3c.dom.Node: ...
    def getImagePaths(self) -> java.util.List[java.lang.String]: ...
    def getName(self) -> java.lang.String: ...
    def getTileCount(self) -> int: ...
    def isValid(self) -> bool: ...
    def printXlifInfo(self) -> None: ...

class ROI: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("loci.formats.in_.LeicaMicrosystemsMetadata")``.

    Channel: type[Channel]
    Dimension: type[Dimension]
    LMSCollectionXmlDocument: type[LMSCollectionXmlDocument]
    LMSFileReader: type[LMSFileReader]
    LMSImageXmlDocument: type[LMSImageXmlDocument]
    LMSMetadataExtractor: type[LMSMetadataExtractor]
    LMSXmlDocument: type[LMSXmlDocument]
    LofXmlDocument: type[LofXmlDocument]
    MetadataStoreInitializer: type[MetadataStoreInitializer]
    MetadataTempBuffer: type[MetadataTempBuffer]
    MultipleImagesReader: type[MultipleImagesReader]
    ROI: type[ROI]
    XlcfDocument: type[XlcfDocument]
    XlefDocument: type[XlefDocument]
    XlifDocument: type[XlifDocument]
