import typing
from typing import Protocol

import com.esotericsoftware.kryo
import java.awt.image
import java.io
import java.lang
import java.math
import java.util
import jpype
import jpype.protocol
import loci
import loci.common
import loci.formats.cache
import loci.formats.codec
import loci.formats.dicom
import loci.formats.filter
import loci.formats.gui
import loci.formats.in_
import loci.formats.meta
import loci.formats.ome
import loci.formats.out
import loci.formats.services
import loci.formats.tiff
import loci.formats.tools
import ome.units.quantity
import ome.units.unit
import ome.xml.model.enums
import ome.xml.model.primitives

class AxisGuesser:
    UNKNOWN_AXIS: typing.ClassVar[int] = ...
    Z_AXIS: typing.ClassVar[int] = ...
    T_AXIS: typing.ClassVar[int] = ...
    C_AXIS: typing.ClassVar[int] = ...
    S_AXIS: typing.ClassVar[int] = ...
    Z_PREFIXES: typing.ClassVar[java.util.Set] = ...
    T_PREFIXES: typing.ClassVar[java.util.Set] = ...
    C_PREFIXES: typing.ClassVar[java.util.Set] = ...
    S_PREFIXES: typing.ClassVar[java.util.Set] = ...
    def __init__(
        self,
        filePattern: FilePattern,
        string: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        boolean: bool,
    ): ...
    def getAdjustedOrder(self) -> java.lang.String: ...
    def getAxisCount(self, int: int) -> int: ...
    def getAxisCountC(self) -> int: ...
    def getAxisCountS(self) -> int: ...
    def getAxisCountT(self) -> int: ...
    def getAxisCountZ(self) -> int: ...
    @staticmethod
    def getAxisType(string: java.lang.String | str) -> int: ...
    def getAxisTypes(self) -> typing.MutableSequence[int]: ...
    def getFilePattern(self) -> FilePattern: ...
    def getOriginalOrder(self) -> java.lang.String: ...
    def isCertain(self) -> bool: ...
    def setAxisTypes(self, intArray: list[int] | jpype.JArray) -> None: ...

_ClassList__T = typing.TypeVar("_ClassList__T")  # <T>

class ClassList(typing.Generic[_ClassList__T]):
    @typing.overload
    def __init__(self, class_: type[_ClassList__T]): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, class_: type[_ClassList__T]): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[_ClassList__T],
        class2: type[typing.Any],
    ): ...
    @typing.overload
    def addClass(self, int: int, class_: type[_ClassList__T]) -> None: ...
    @typing.overload
    def addClass(self, class_: type[_ClassList__T]) -> None: ...
    def addOption(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    @typing.overload
    def append(self, list: java.util.List[type[_ClassList__T]]) -> None: ...
    @typing.overload
    def append(self, classList: ClassList[_ClassList__T]) -> None: ...
    def getClasses(self) -> typing.MutableSequence[type[_ClassList__T]]: ...
    def getOptions(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def isAllowedKey(self, string: java.lang.String | str) -> bool: ...
    def isWhitelistedKey(self, string: java.lang.String | str) -> bool: ...
    def parseFile(
        self, string: java.lang.String | str, class_: type[typing.Any]
    ) -> None: ...
    def parseLine(self, string: java.lang.String | str) -> None: ...
    def parseOptions(
        self, string: java.lang.String | str
    ) -> java.util.Map[java.lang.String, java.lang.String]: ...
    @typing.overload
    def prepend(self, list: java.util.List[type[_ClassList__T]]) -> None: ...
    @typing.overload
    def prepend(self, classList: ClassList[_ClassList__T]) -> None: ...
    def removeClass(self, class_: type[_ClassList__T]) -> None: ...

class CoreMetadata(java.lang.Cloneable):
    sizeX: int = ...
    sizeY: int = ...
    sizeZ: int = ...
    sizeC: int = ...
    sizeT: int = ...
    thumbSizeX: int = ...
    thumbSizeY: int = ...
    pixelType: int = ...
    bitsPerPixel: int = ...
    imageCount: int = ...
    moduloZ: Modulo = ...
    moduloC: Modulo = ...
    moduloT: Modulo = ...
    dimensionOrder: java.lang.String = ...
    orderCertain: bool = ...
    rgb: bool = ...
    littleEndian: bool = ...
    interleaved: bool = ...
    indexed: bool = ...
    falseColor: bool = ...
    metadataComplete: bool = ...
    seriesMetadata: java.util.Hashtable = ...
    thumbnail: bool = ...
    resolutionCount: int = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, coreMetadata: CoreMetadata): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader, int: int): ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self, iFormatReader: IFormatReader, int: int) -> CoreMetadata: ...
    def toString(self) -> java.lang.String: ...

class FileInfo:
    filename: java.lang.String = ...
    reader: type = ...
    usedToInitialize: bool = ...
    def __init__(self): ...
    def toString(self) -> java.lang.String: ...

class FilePattern:
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(self, location: loci.common.Location): ...
    @typing.overload
    @staticmethod
    def findPattern(
        file: java.io.File | jpype.protocol.SupportsPath,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        intArray: list[int] | jpype.JArray,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findPattern(location: loci.common.Location) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def findSeriesPatterns(
        string: java.lang.String | str,
    ) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def findSeriesPatterns(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getBlock(self, int: int) -> java.lang.String: ...
    def getBlocks(self) -> typing.MutableSequence[java.lang.String]: ...
    def getCount(self) -> typing.MutableSequence[int]: ...
    def getElements(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[java.lang.String]]: ...
    def getErrorMessage(self) -> java.lang.String: ...
    def getFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    def getFirst(self) -> typing.MutableSequence[java.math.BigInteger]: ...
    def getLast(self) -> typing.MutableSequence[java.math.BigInteger]: ...
    def getPattern(self) -> java.lang.String: ...
    @typing.overload
    def getPrefix(self) -> java.lang.String: ...
    @typing.overload
    def getPrefix(self, int: int) -> java.lang.String: ...
    def getPrefixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getStep(self) -> typing.MutableSequence[java.math.BigInteger]: ...
    def getSuffix(self) -> java.lang.String: ...
    def isRegex(self) -> bool: ...
    def isValid(self) -> bool: ...

class FilePatternBlock:
    BLOCK_START: typing.ClassVar[java.lang.String] = ...
    BLOCK_END: typing.ClassVar[java.lang.String] = ...
    def __init__(self, string: java.lang.String | str): ...
    def getBlock(self) -> java.lang.String: ...
    def getElements(self) -> typing.MutableSequence[java.lang.String]: ...
    def getFirst(self) -> java.math.BigInteger: ...
    def getLast(self) -> java.math.BigInteger: ...
    def getStep(self) -> java.math.BigInteger: ...
    def isFixed(self) -> bool: ...
    def isNumeric(self) -> bool: ...

class FormatException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class FormatTools:
    INT8: typing.ClassVar[int] = ...
    UINT8: typing.ClassVar[int] = ...
    INT16: typing.ClassVar[int] = ...
    UINT16: typing.ClassVar[int] = ...
    INT32: typing.ClassVar[int] = ...
    UINT32: typing.ClassVar[int] = ...
    FLOAT: typing.ClassVar[int] = ...
    DOUBLE: typing.ClassVar[int] = ...
    BIT: typing.ClassVar[int] = ...
    CHANNEL: typing.ClassVar[java.lang.String] = ...
    SPECTRA: typing.ClassVar[java.lang.String] = ...
    LIFETIME: typing.ClassVar[java.lang.String] = ...
    POLARIZATION: typing.ClassVar[java.lang.String] = ...
    PHASE: typing.ClassVar[java.lang.String] = ...
    FREQUENCY: typing.ClassVar[java.lang.String] = ...
    ROTATION: typing.ClassVar[java.lang.String] = ...
    ILLUMINATION: typing.ClassVar[java.lang.String] = ...
    MUST_GROUP: typing.ClassVar[int] = ...
    CAN_GROUP: typing.ClassVar[int] = ...
    CANNOT_GROUP: typing.ClassVar[int] = ...
    SERIES_NUM: typing.ClassVar[java.lang.String] = ...
    SERIES_NAME: typing.ClassVar[java.lang.String] = ...
    CHANNEL_NUM: typing.ClassVar[java.lang.String] = ...
    CHANNEL_NAME: typing.ClassVar[java.lang.String] = ...
    Z_NUM: typing.ClassVar[java.lang.String] = ...
    T_NUM: typing.ClassVar[java.lang.String] = ...
    TIMESTAMP: typing.ClassVar[java.lang.String] = ...
    TILE_X: typing.ClassVar[java.lang.String] = ...
    TILE_Y: typing.ClassVar[java.lang.String] = ...
    TILE_NUM: typing.ClassVar[java.lang.String] = ...
    VERSION_PROPERTIES: typing.ClassVar[java.util.Properties] = ...
    VCS_REVISION: typing.ClassVar[java.lang.String] = ...
    VCS_SHORT_REVISION: typing.ClassVar[java.lang.String] = ...
    DATE: typing.ClassVar[java.lang.String] = ...
    YEAR: typing.ClassVar[java.lang.String] = ...
    VERSION: typing.ClassVar[java.lang.String] = ...
    CREATOR: typing.ClassVar[java.lang.String] = ...
    PROPERTY_FILE: typing.ClassVar[java.lang.String] = ...
    HCS_DOMAIN: typing.ClassVar[java.lang.String] = ...
    LM_DOMAIN: typing.ClassVar[java.lang.String] = ...
    EM_DOMAIN: typing.ClassVar[java.lang.String] = ...
    SPM_DOMAIN: typing.ClassVar[java.lang.String] = ...
    SEM_DOMAIN: typing.ClassVar[java.lang.String] = ...
    FLIM_DOMAIN: typing.ClassVar[java.lang.String] = ...
    MEDICAL_DOMAIN: typing.ClassVar[java.lang.String] = ...
    HISTOLOGY_DOMAIN: typing.ClassVar[java.lang.String] = ...
    GEL_DOMAIN: typing.ClassVar[java.lang.String] = ...
    ASTRONOMY_DOMAIN: typing.ClassVar[java.lang.String] = ...
    GRAPHICS_DOMAIN: typing.ClassVar[java.lang.String] = ...
    UNKNOWN_DOMAIN: typing.ClassVar[java.lang.String] = ...
    NON_GRAPHICS_DOMAINS: typing.ClassVar[
        typing.MutableSequence[java.lang.String]
    ] = ...
    NON_HCS_DOMAINS: typing.ClassVar[typing.MutableSequence[java.lang.String]] = ...
    NON_SPECIAL_DOMAINS: typing.ClassVar[typing.MutableSequence[java.lang.String]] = ...
    ALL_DOMAINS: typing.ClassVar[typing.MutableSequence[java.lang.String]] = ...
    URL_BIO_FORMATS: typing.ClassVar[java.lang.String] = ...
    URL_BIO_FORMATS_LIBRARIES: typing.ClassVar[java.lang.String] = ...
    URL_OME_TIFF: typing.ClassVar[java.lang.String] = ...
    @staticmethod
    def assertId(string: java.lang.String | str, boolean: bool, int: int) -> None: ...
    @staticmethod
    def canUsePrecompressedTiles(
        iFormatReader: IFormatReader, iFormatWriter: IFormatWriter, int: int, int2: int
    ) -> bool: ...
    @typing.overload
    @staticmethod
    def checkBufferSize(iFormatReader: IFormatReader, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def checkBufferSize(
        iFormatReader: IFormatReader, int: int, int2: int, int3: int
    ) -> None: ...
    @staticmethod
    def checkPlaneNumber(iFormatReader: IFormatReader, int: int) -> None: ...
    @staticmethod
    def checkPlaneParameters(
        iFormatReader: IFormatReader,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
    ) -> None: ...
    @staticmethod
    def checkTileSize(
        iFormatReader: IFormatReader, int: int, int2: int, int3: int, int4: int
    ) -> None: ...
    @typing.overload
    @staticmethod
    def convert(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    @typing.overload
    @staticmethod
    def convert(
        iFormatReader: IFormatReader,
        iFormatWriter: IFormatWriter,
        string: java.lang.String | str,
    ) -> None: ...
    _createAngle_2__T = typing.TypeVar(
        "_createAngle_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createAngle(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Angle]
    ) -> ome.units.quantity.Angle: ...
    @typing.overload
    @staticmethod
    def createAngle(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Angle]
    ) -> ome.units.quantity.Angle: ...
    @typing.overload
    @staticmethod
    def createAngle(
        t: _createAngle_2__T, unit: ome.units.unit.Unit[ome.units.quantity.Angle]
    ) -> ome.units.quantity.Angle: ...
    _createElectricPotential_2__T = typing.TypeVar(
        "_createElectricPotential_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createElectricPotential(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.ElectricPotential]
    ) -> ome.units.quantity.ElectricPotential: ...
    @typing.overload
    @staticmethod
    def createElectricPotential(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.ElectricPotential]
    ) -> ome.units.quantity.ElectricPotential: ...
    @typing.overload
    @staticmethod
    def createElectricPotential(
        t: _createElectricPotential_2__T,
        unit: ome.units.unit.Unit[ome.units.quantity.ElectricPotential],
    ) -> ome.units.quantity.ElectricPotential: ...
    _createFrequency_2__T = typing.TypeVar(
        "_createFrequency_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createFrequency(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Frequency]
    ) -> ome.units.quantity.Frequency: ...
    @typing.overload
    @staticmethod
    def createFrequency(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Frequency]
    ) -> ome.units.quantity.Frequency: ...
    @typing.overload
    @staticmethod
    def createFrequency(
        t: _createFrequency_2__T,
        unit: ome.units.unit.Unit[ome.units.quantity.Frequency],
    ) -> ome.units.quantity.Frequency: ...
    _createLength_2__T = typing.TypeVar(
        "_createLength_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createLength(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def createLength(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def createLength(
        t: _createLength_2__T, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    _createPower_2__T = typing.TypeVar(
        "_createPower_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createPower(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Power]
    ) -> ome.units.quantity.Power: ...
    @typing.overload
    @staticmethod
    def createPower(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Power]
    ) -> ome.units.quantity.Power: ...
    @typing.overload
    @staticmethod
    def createPower(
        t: _createPower_2__T, unit: ome.units.unit.Unit[ome.units.quantity.Power]
    ) -> ome.units.quantity.Power: ...
    _createPressure_2__T = typing.TypeVar(
        "_createPressure_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createPressure(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Pressure]
    ) -> ome.units.quantity.Pressure: ...
    @typing.overload
    @staticmethod
    def createPressure(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Pressure]
    ) -> ome.units.quantity.Pressure: ...
    @typing.overload
    @staticmethod
    def createPressure(
        t: _createPressure_2__T, unit: ome.units.unit.Unit[ome.units.quantity.Pressure]
    ) -> ome.units.quantity.Pressure: ...
    _createTemperature_2__T = typing.TypeVar(
        "_createTemperature_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createTemperature(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Temperature]
    ) -> ome.units.quantity.Temperature: ...
    @typing.overload
    @staticmethod
    def createTemperature(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Temperature]
    ) -> ome.units.quantity.Temperature: ...
    @typing.overload
    @staticmethod
    def createTemperature(
        t: _createTemperature_2__T,
        unit: ome.units.unit.Unit[ome.units.quantity.Temperature],
    ) -> ome.units.quantity.Temperature: ...
    _createTime_2__T = typing.TypeVar(
        "_createTime_2__T", bound=ome.xml.model.primitives.PrimitiveNumber
    )  # <T>
    @typing.overload
    @staticmethod
    def createTime(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Time]
    ) -> ome.units.quantity.Time: ...
    @typing.overload
    @staticmethod
    def createTime(
        integer: int, unit: ome.units.unit.Unit[ome.units.quantity.Time]
    ) -> ome.units.quantity.Time: ...
    @typing.overload
    @staticmethod
    def createTime(
        t: _createTime_2__T, unit: ome.units.unit.Unit[ome.units.quantity.Time]
    ) -> ome.units.quantity.Time: ...
    @staticmethod
    def defaultMinMax(int: int) -> typing.MutableSequence[int]: ...
    @staticmethod
    def equalReaders(
        iFormatReader: IFormatReader, iFormatReader2: IFormatReader
    ) -> bool: ...
    @typing.overload
    @staticmethod
    def getBytesPerPixel(int: int) -> int: ...
    @typing.overload
    @staticmethod
    def getBytesPerPixel(string: java.lang.String | str) -> int: ...
    @staticmethod
    def getCutIn(double: float) -> ome.units.quantity.Length: ...
    @staticmethod
    def getCutOut(double: float) -> ome.units.quantity.Length: ...
    @staticmethod
    def getEmissionWavelength(double: float) -> ome.units.quantity.Length: ...
    @staticmethod
    def getExcitationWavelength(double: float) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getFilename(
        int: int,
        int2: int,
        iFormatReader: IFormatReader,
        string: java.lang.String | str,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getFilename(
        int: int,
        int2: int,
        iFormatReader: IFormatReader,
        string: java.lang.String | str,
        boolean: bool,
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getFilename(
        int: int,
        int2: int,
        metadataRetrieve: loci.formats.meta.MetadataRetrieve,
        string: java.lang.String | str,
        boolean: bool,
    ) -> java.lang.String: ...
    @staticmethod
    def getFilenames(
        string: java.lang.String | str, iFormatReader: IFormatReader
    ) -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def getFontSize(integer: int) -> ome.units.quantity.Length: ...
    @staticmethod
    def getImagesPerFile(
        string: java.lang.String | str, iFormatReader: IFormatReader
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getIndex(
        string: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getIndex(
        string: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
        int8: int,
        int9: int,
        int10: int,
        int11: int,
        int12: int,
        int13: int,
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getIndex(
        iFormatReader: IFormatReader, int: int, int2: int, int3: int
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getIndex(
        iFormatReader: IFormatReader,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
    ) -> int: ...
    @staticmethod
    def getMaxFieldCount(integer: int) -> ome.xml.model.primitives.PositiveInteger: ...
    @staticmethod
    def getPhysicalSize(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeX(double: float) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeX(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeX(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeY(double: float) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeY(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeY(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeZ(double: float) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeZ(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getPhysicalSizeZ(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @staticmethod
    def getPixelTypeString(int: int) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getPlaneSize(iFormatReader: IFormatReader) -> int: ...
    @typing.overload
    @staticmethod
    def getPlaneSize(iFormatReader: IFormatReader, int: int, int2: int) -> int: ...
    @staticmethod
    def getRasterLength(intArray: list[int] | jpype.JArray) -> int: ...
    @staticmethod
    def getReader(
        iFormatReader: IFormatReader, class_: type[IFormatReader]
    ) -> IFormatReader: ...
    @typing.overload
    @staticmethod
    def getReorderedIndex(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getReorderedIndex(
        iFormatReader: IFormatReader, string: java.lang.String | str, int: int
    ) -> int: ...
    @staticmethod
    def getRequiredDirectories(
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> int: ...
    @typing.overload
    @staticmethod
    def getStagePosition(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getStagePosition(
        double: float, unit: ome.units.unit.Unit[ome.units.quantity.Length]
    ) -> ome.units.quantity.Length: ...
    @staticmethod
    def getTileFilename(
        int: int, int2: int, int3: int, string: java.lang.String | str
    ) -> java.lang.String: ...
    @staticmethod
    def getTime(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Time: ...
    @typing.overload
    @staticmethod
    def getWavelength(double: float) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def getWavelength(
        double: float, string: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @staticmethod
    def getWellName(int: int, int2: int) -> java.lang.String: ...
    @staticmethod
    def getWellRowName(int: int) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getZCTCoords(
        string: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def getZCTCoords(
        string: java.lang.String | str,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
        int8: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def getZCTCoords(
        iFormatReader: IFormatReader, int: int
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def getZCTModuloCoords(
        iFormatReader: IFormatReader, int: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def isFloatingPoint(int: int) -> bool: ...
    @typing.overload
    @staticmethod
    def isFloatingPoint(iFormatReader: IFormatReader) -> bool: ...
    @staticmethod
    def isPositiveValue(double: float) -> bool: ...
    @staticmethod
    def isSigned(int: int) -> bool: ...
    @staticmethod
    def openThumbBytes(
        iFormatReader: IFormatReader, int: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def parseLength(string: java.lang.String | str) -> ome.units.quantity.Length: ...
    @typing.overload
    @staticmethod
    def parseLength(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> ome.units.quantity.Length: ...
    @staticmethod
    def pixelTypeFromBytes(int: int, boolean: bool, boolean2: bool) -> int: ...
    @staticmethod
    def pixelTypeFromString(string: java.lang.String | str) -> int: ...
    @staticmethod
    def positionToRaster(
        intArray: list[int] | jpype.JArray, intArray2: list[int] | jpype.JArray
    ) -> int: ...
    @typing.overload
    @staticmethod
    def rasterToPosition(
        intArray: list[int] | jpype.JArray, int2: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def rasterToPosition(
        intArray: list[int] | jpype.JArray,
        int2: int,
        intArray2: list[int] | jpype.JArray,
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def validStream(
        randomAccessInputStream: loci.common.RandomAccessInputStream,
        int: int,
        boolean: bool,
    ) -> bool: ...

class ICompressedTileReader:
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getTileColumns(self, int: int) -> int: ...
    def getTileRows(self, int: int) -> int: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...

class ICompressedTileWriter:
    def getCodec(self) -> loci.formats.codec.Codec: ...
    def getCodecOptions(self) -> loci.formats.codec.CodecOptions: ...
    def saveCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...

class IMetadataConfigurable:
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...

class IPyramidHandler:
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def setResolution(self, int: int) -> None: ...

class IllegalBlockException(java.lang.IllegalArgumentException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ImageTools:
    @staticmethod
    def autoscale(
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        int3: int,
        boolean: bool,
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def bgrToRgb(
        byteArray: list[int] | jpype.JArray | bytes, boolean: bool, int: int, int2: int
    ) -> None: ...
    @staticmethod
    def getSubimage(
        byteArray: list[int] | jpype.JArray | bytes,
        byteArray2: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
        int8: int,
        boolean: bool,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def indexedToRGB(
        byteArray: list[typing.MutableSequence[int]] | jpype.JArray,
        byteArray2: list[int] | jpype.JArray | bytes,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    @typing.overload
    @staticmethod
    def indexedToRGB(
        shortArray: list[typing.MutableSequence[int]] | jpype.JArray,
        byteArray: list[int] | jpype.JArray | bytes,
        boolean: bool,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    @staticmethod
    def interpolate(
        shortArray: list[int] | jpype.JArray,
        byteArray: list[int] | jpype.JArray | bytes,
        intArray: list[int] | jpype.JArray,
        int2: int,
        int3: int,
        boolean: bool,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def make24Bits(
        object: typing.Any, int: int, int2: int, boolean: bool, boolean2: bool
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    @typing.overload
    @staticmethod
    def make24Bits(
        object: typing.Any,
        int: int,
        int2: int,
        boolean: bool,
        boolean2: bool,
        double: float,
        double2: float,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    @typing.overload
    @staticmethod
    def make24Bits(
        object: typing.Any, int: int, int2: int, boolean: bool
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def make24Bits(
        object: typing.Any,
        int: int,
        int2: int,
        boolean: bool,
        double: float,
        double2: float,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def padImage(
        byteArray: list[int] | jpype.JArray | bytes,
        boolean: bool,
        int: int,
        int2: int,
        int3: int,
        int4: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def padImage(
        doubleArray: list[float] | jpype.JArray,
        boolean: bool,
        int: int,
        int2: int,
        int3: int,
        int4: int,
    ) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def padImage(
        floatArray: list[float] | jpype.JArray,
        boolean: bool,
        int: int,
        int2: int,
        int3: int,
        int4: int,
    ) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def padImage(
        intArray: list[int] | jpype.JArray,
        boolean: bool,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def padImage(
        shortArray: list[int] | jpype.JArray,
        boolean: bool,
        int: int,
        int2: int,
        int3: int,
        int4: int,
    ) -> typing.MutableSequence[int]: ...
    @staticmethod
    def scanData(
        byteArray: list[int] | jpype.JArray | bytes, int: int, boolean: bool
    ) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def splitChannels(
        byteArray: list[int] | jpype.JArray | bytes,
        byteArray2: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        int3: int,
        boolean: bool,
        boolean2: bool,
        int4: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def splitChannels(
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        int3: int,
        boolean: bool,
        boolean2: bool,
    ) -> typing.MutableSequence[int]: ...

_MetadataList__T = typing.TypeVar("_MetadataList__T")  # <T>

class MetadataList(typing.Generic[_MetadataList__T]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, intArray: list[int] | jpype.JArray): ...
    @typing.overload
    def __init__(self, metadataList: MetadataList[_MetadataList__T]): ...
    @typing.overload
    def add(self) -> None: ...
    @typing.overload
    def add(self, int: int) -> None: ...
    @typing.overload
    def add(self, int: int, t: _MetadataList__T) -> None: ...
    @typing.overload
    def add(self, t: _MetadataList__T) -> None: ...
    @typing.overload
    def add(self, list: java.util.List[_MetadataList__T]) -> None: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, int: int) -> None: ...
    def get(self, int: int, int2: int) -> _MetadataList__T: ...
    @typing.overload
    def remove(self, int: int, int2: int) -> _MetadataList__T: ...
    @typing.overload
    def remove(self, int: int) -> java.util.List[_MetadataList__T]: ...
    def set(self, int: int, int2: int, t: _MetadataList__T) -> None: ...
    @typing.overload
    def size(self) -> int: ...
    @typing.overload
    def size(self, int: int) -> int: ...
    def sizes(self) -> typing.MutableSequence[int]: ...

class MetadataTools:
    @staticmethod
    def createLSID(string: java.lang.String | str, *int: int) -> java.lang.String: ...
    @staticmethod
    def createOMEXMLMetadata() -> loci.formats.meta.IMetadata: ...
    @staticmethod
    def getAcquisitionMode(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.AcquisitionMode: ...
    @staticmethod
    def getArcType(string: java.lang.String | str) -> ome.xml.model.enums.ArcType: ...
    @staticmethod
    def getBinning(string: java.lang.String | str) -> ome.xml.model.enums.Binning: ...
    @staticmethod
    def getCompression(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.Compression: ...
    @staticmethod
    def getContrastMethod(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.ContrastMethod: ...
    @staticmethod
    def getCorrection(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.Correction: ...
    @staticmethod
    def getDetectorType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.DetectorType: ...
    @staticmethod
    def getDimensionOrder(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.DimensionOrder: ...
    @staticmethod
    def getExperimentType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.ExperimentType: ...
    @staticmethod
    def getFilamentType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.FilamentType: ...
    @staticmethod
    def getFillRule(string: java.lang.String | str) -> ome.xml.model.enums.FillRule: ...
    @staticmethod
    def getFilterType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.FilterType: ...
    @staticmethod
    def getFontFamily(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.FontFamily: ...
    @staticmethod
    def getFontStyle(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.FontStyle: ...
    @staticmethod
    def getIlluminationType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.IlluminationType: ...
    @staticmethod
    def getImmersion(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.Immersion: ...
    @staticmethod
    def getLaserMedium(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.LaserMedium: ...
    @staticmethod
    def getLaserType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.LaserType: ...
    @staticmethod
    def getMarker(string: java.lang.String | str) -> ome.xml.model.enums.Marker: ...
    @staticmethod
    def getMedium(string: java.lang.String | str) -> ome.xml.model.enums.Medium: ...
    @staticmethod
    def getMicrobeamManipulationType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.MicrobeamManipulationType: ...
    @staticmethod
    def getMicroscopeType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.MicroscopeType: ...
    @staticmethod
    def getNamingConvention(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.NamingConvention: ...
    @staticmethod
    def getPixelType(
        string: java.lang.String | str,
    ) -> ome.xml.model.enums.PixelType: ...
    @staticmethod
    def getPulse(string: java.lang.String | str) -> ome.xml.model.enums.Pulse: ...
    @staticmethod
    def keys(
        hashtable: java.util.Hashtable[java.lang.String | str, typing.Any],
    ) -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def makeSaneDimensionOrder(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def merge(
        map: java.util.Map[java.lang.String | str, typing.Any]
        | typing.Mapping[java.lang.String | str, typing.Any],
        map2: java.util.Map[java.lang.String | str, typing.Any]
        | typing.Mapping[java.lang.String | str, typing.Any],
        string: java.lang.String | str,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populateMetadata(
        metadataStore: loci.formats.meta.MetadataStore,
        int: int,
        string: java.lang.String | str,
        boolean: bool,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populateMetadata(
        metadataStore: loci.formats.meta.MetadataStore,
        int: int,
        string: java.lang.String | str,
        coreMetadata: CoreMetadata,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populateMetadata(
        metadataStore: loci.formats.meta.MetadataStore,
        string: java.lang.String | str,
        int: int,
        string2: java.lang.String | str,
        boolean: bool,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populatePixels(
        metadataStore: loci.formats.meta.MetadataStore, iFormatReader: IFormatReader
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populatePixels(
        metadataStore: loci.formats.meta.MetadataStore,
        iFormatReader: IFormatReader,
        boolean: bool,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populatePixels(
        metadataStore: loci.formats.meta.MetadataStore,
        iFormatReader: IFormatReader,
        boolean: bool,
        boolean2: bool,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populatePixelsOnly(
        metadataStore: loci.formats.meta.MetadataStore,
        int: int,
        boolean: bool,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
        int6: int,
        int7: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def populatePixelsOnly(
        metadataStore: loci.formats.meta.MetadataStore, iFormatReader: IFormatReader
    ) -> None: ...
    @staticmethod
    def setDefaultCreationDate(
        metadataStore: loci.formats.meta.MetadataStore,
        string: java.lang.String | str,
        int: int,
    ) -> None: ...
    @staticmethod
    def setDefaultDateEnabled(boolean: bool) -> None: ...
    @typing.overload
    @staticmethod
    def verifyMinimumPopulated(
        metadataRetrieve: loci.formats.meta.MetadataRetrieve,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def verifyMinimumPopulated(
        metadataRetrieve: loci.formats.meta.MetadataRetrieve, int: int
    ) -> None: ...

class Modulo:
    parentDimension: java.lang.String = ...
    start: float = ...
    step: float = ...
    end: float = ...
    parentType: java.lang.String = ...
    type: java.lang.String = ...
    typeDescription: java.lang.String = ...
    unit: java.lang.String = ...
    labels: typing.MutableSequence[java.lang.String] = ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, modulo: Modulo): ...
    def length(self) -> int: ...
    def toXMLAnnotation(self) -> java.lang.String: ...

class NumberFilter(java.io.FileFilter):
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def accept(self, file: java.io.File | jpype.protocol.SupportsPath) -> bool: ...
    @typing.overload
    def accept(self, string: java.lang.String | str) -> bool: ...
    def getNumber(self, string: java.lang.String | str) -> java.math.BigInteger: ...

class Resolution:
    sizeX: ome.xml.model.primitives.PositiveInteger = ...
    sizeY: ome.xml.model.primitives.PositiveInteger = ...
    index: int = ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int): ...

class ResourceNamer:
    PLATE: typing.ClassVar[java.lang.String] = ...
    RUN: typing.ClassVar[java.lang.String] = ...
    WELL: typing.ClassVar[java.lang.String] = ...
    FIELD: typing.ClassVar[java.lang.String] = ...
    FAKE_EXT: typing.ClassVar[java.lang.String] = ...
    DOT: typing.ClassVar[java.lang.String] = ...
    def __init__(self, int: int): ...
    @staticmethod
    def alphabeticIndexCount(string: java.lang.String | str) -> int: ...
    def getLetter(self) -> java.lang.String: ...
    def getLocationFromResourceName(
        self,
        location: loci.common.Location,
        string: java.lang.String | str,
        int: int,
        string2: java.lang.String | str,
    ) -> loci.common.Location: ...
    def nextLetter(self) -> None: ...
    def restartAlphabet(self) -> None: ...

class UpgradeChecker:
    REGISTRY_IMAGEJ: typing.ClassVar[java.lang.String] = ...
    REGISTRY_LIBRARY: typing.ClassVar[java.lang.String] = ...
    STABLE_VERSION: typing.ClassVar[java.lang.String] = ...
    CI_SERVER: typing.ClassVar[java.lang.String] = ...
    TRUNK_BUILD: typing.ClassVar[java.lang.String] = ...
    DAILY_BUILD: typing.ClassVar[java.lang.String] = ...
    STABLE_BUILD: typing.ClassVar[java.lang.String] = ...
    TOOLS: typing.ClassVar[java.lang.String] = ...
    OLD_TOOLS: typing.ClassVar[java.lang.String] = ...
    OME_TOOLS: typing.ClassVar[java.lang.String] = ...
    INDIVIDUAL_JARS: typing.ClassVar[typing.MutableSequence[java.lang.String]] = ...
    REGISTRY: typing.ClassVar[java.lang.String] = ...
    DEFAULT_CALLER: typing.ClassVar[java.lang.String] = ...
    def __init__(self): ...
    def alreadyChecked(self) -> bool: ...
    def canDoUpgradeCheck(self) -> bool: ...
    def install(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    def installIndividualJars(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    @typing.overload
    def newVersionAvailable(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def newVersionAvailable(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    def setCanDoUpgradeCheck(self, boolean: bool) -> None: ...

class CoreMetadataList(MetadataList[CoreMetadata]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, intArray: list[int] | jpype.JArray): ...
    @typing.overload
    def __init__(self, list: java.util.List[CoreMetadata]): ...
    @typing.overload
    def __init__(self, coreMetadataList: CoreMetadataList): ...
    @typing.overload
    def add(self, int: int, coreMetadata: CoreMetadata) -> None: ...
    @typing.overload
    def add(self) -> None: ...
    @typing.overload
    def add(self, int: int) -> None: ...
    @typing.overload
    def add(self, t: typing.Any) -> None: ...
    @typing.overload
    def add(self, list: java.util.List[typing.Any]) -> None: ...
    def flattenedIndex(self, int: int, int2: int) -> int: ...
    def flattenedIndexes(self, int: int) -> typing.MutableSequence[int]: ...
    def flattenedSize(self) -> int: ...
    def getFlattenedList(self) -> java.util.List[CoreMetadata]: ...
    def getSeriesList(self) -> java.util.List[CoreMetadata]: ...
    def reorder(self) -> None: ...
    def setFlattenedList(self, list: java.util.List[CoreMetadata]) -> None: ...

class IFormatHandler(java.io.Closeable, IMetadataConfigurable):
    def getFormat(self) -> java.lang.String: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    def setId(self, string: java.lang.String | str) -> None: ...

class MissingLibraryException(FormatException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class SwappableMetadata(CoreMetadata):
    inputOrder: java.lang.String = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader, int: int): ...
    @typing.overload
    def __init__(self, swappableMetadata: SwappableMetadata): ...
    @typing.overload
    def clone(self) -> typing.Any: ...
    @typing.overload
    def clone(self, iFormatReader: IFormatReader, int: int) -> CoreMetadata: ...

class UnknownFormatException(FormatException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class UnsupportedCompressionException(FormatException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class FormatHandler(IFormatHandler):
    COMPRESSION_SUFFIXES: typing.ClassVar[
        typing.MutableSequence[java.lang.String]
    ] = ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    @staticmethod
    def checkSuffix(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    @typing.overload
    @staticmethod
    def checkSuffix(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> bool: ...
    def getFormat(self) -> java.lang.String: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...

class IFormatReader(IFormatHandler, IPyramidHandler, ICompressedTileReader):
    MUST_GROUP: typing.ClassVar[int] = ...
    CAN_GROUP: typing.ClassVar[int] = ...
    CANNOT_GROUP: typing.ClassVar[int] = ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def fileGroupOption(self, string: java.lang.String | str) -> int: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getAdvancedSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAdvancedUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getCurrentFile(self) -> java.lang.String: ...
    def getDatasetStructureDescription(self) -> java.lang.String: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getDomains(self) -> typing.MutableSequence[java.lang.String]: ...
    def getEffectiveSizeC(self) -> int: ...
    def getFillColor(self) -> int: ...
    def getGlobalMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    def getModuloC(self) -> Modulo: ...
    def getModuloT(self) -> Modulo: ...
    def getModuloZ(self) -> Modulo: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    def getPixelType(self) -> int: ...
    def getPossibleDomains(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getRGBChannelCount(self) -> int: ...
    def getRequiredDirectories(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getSeriesMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def hasCompanionFiles(self) -> bool: ...
    def hasFlattenedResolutions(self) -> bool: ...
    def isFalseColor(self) -> bool: ...
    def isGroupFiles(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isMetadataComplete(self) -> bool: ...
    def isMetadataFiltered(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isOriginalMetadataPopulated(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isSingleFile(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str, boolean: bool) -> bool: ...
    @typing.overload
    def isThisType(
        self, randomAccessInputStream: loci.common.RandomAccessInputStream
    ) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFillColor(self, byte: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setMetadataFiltered(self, boolean: bool) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setSeries(self, int: int) -> None: ...

class IFormatWriter(IFormatHandler, IPyramidHandler, ICompressedTileWriter):
    def canDoStacks(self) -> bool: ...
    def changeOutputFile(self, string: java.lang.String | str) -> None: ...
    def getColorModel(self) -> java.awt.image.ColorModel: ...
    def getCompression(self) -> java.lang.String: ...
    def getCompressionTypes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getFramesPerSecond(self) -> int: ...
    def getMetadataRetrieve(self) -> loci.formats.meta.MetadataRetrieve: ...
    @typing.overload
    def getPixelTypes(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getPixelTypes(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[int]: ...
    def getResolutions(self) -> java.util.List[Resolution]: ...
    def getSeries(self) -> int: ...
    def getTileSizeX(self) -> int: ...
    def getTileSizeY(self) -> int: ...
    def isInterleaved(self) -> bool: ...
    def isSupportedType(self, int: int) -> bool: ...
    @typing.overload
    def saveBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        region: loci.common.Region,
    ) -> None: ...
    @typing.overload
    def savePlane(self, int: int, object: typing.Any) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, int2: int, int3: int, int4: int, int5: int
    ) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, region: loci.common.Region
    ) -> None: ...
    def setCodecOptions(
        self, codecOptions: loci.formats.codec.CodecOptions
    ) -> None: ...
    def setColorModel(self, colorModel: java.awt.image.ColorModel) -> None: ...
    def setCompression(self, string: java.lang.String | str) -> None: ...
    def setFramesPerSecond(self, int: int) -> None: ...
    def setInterleaved(self, boolean: bool) -> None: ...
    def setMetadataRetrieve(
        self, metadataRetrieve: loci.formats.meta.MetadataRetrieve
    ) -> None: ...
    def setResolutions(self, list: java.util.List[Resolution]) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def setTileSizeX(self, int: int) -> int: ...
    def setTileSizeY(self, int: int) -> int: ...
    def setValidBitsPerPixel(self, int: int) -> None: ...
    def setWriteSequentially(self, boolean: bool) -> None: ...

class FormatReader(FormatHandler, IFormatReader):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def fileGroupOption(self, string: java.lang.String | str) -> int: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getAdvancedSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAdvancedUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getCurrentFile(self) -> java.lang.String: ...
    def getDatasetStructureDescription(self) -> java.lang.String: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getDomains(self) -> typing.MutableSequence[java.lang.String]: ...
    def getEffectiveSizeC(self) -> int: ...
    def getFillColor(self) -> int: ...
    def getGlobalMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    def getModuloC(self) -> Modulo: ...
    def getModuloT(self) -> Modulo: ...
    def getModuloZ(self) -> Modulo: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    def getPixelType(self) -> int: ...
    def getPossibleDomains(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getRGBChannelCount(self) -> int: ...
    def getRequiredDirectories(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> int: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getSeriesMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getTileColumns(self, int: int) -> int: ...
    def getTileRows(self, int: int) -> int: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def hasCompanionFiles(self) -> bool: ...
    def hasFlattenedResolutions(self) -> bool: ...
    def isFalseColor(self) -> bool: ...
    def isGroupFiles(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isMetadataComplete(self) -> bool: ...
    def isMetadataFiltered(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isOriginalMetadataPopulated(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isSingleFile(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str, boolean: bool) -> bool: ...
    @typing.overload
    def isThisType(
        self, randomAccessInputStream: loci.common.RandomAccessInputStream
    ) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFillColor(self, byte: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setMetadataFiltered(self, boolean: bool) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...

class FormatWriter(FormatHandler, IFormatWriter):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    def canDoStacks(self) -> bool: ...
    def changeOutputFile(self, string: java.lang.String | str) -> None: ...
    def close(self) -> None: ...
    def getCodecOptions(self) -> loci.formats.codec.CodecOptions: ...
    def getColorModel(self) -> java.awt.image.ColorModel: ...
    def getCompression(self) -> java.lang.String: ...
    def getCompressionTypes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getFramesPerSecond(self) -> int: ...
    def getMetadataRetrieve(self) -> loci.formats.meta.MetadataRetrieve: ...
    @typing.overload
    def getPixelTypes(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getPixelTypes(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[int]: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getResolutions(self) -> java.util.List[Resolution]: ...
    def getSeries(self) -> int: ...
    def getTileSizeX(self) -> int: ...
    def getTileSizeY(self) -> int: ...
    def isInterleaved(self) -> bool: ...
    def isSupportedType(self, int: int) -> bool: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        region: loci.common.Region,
    ) -> None: ...
    @typing.overload
    def savePlane(self, int: int, object: typing.Any) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, int2: int, int3: int, int4: int, int5: int
    ) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, region: loci.common.Region
    ) -> None: ...
    def setCodecOptions(
        self, codecOptions: loci.formats.codec.CodecOptions
    ) -> None: ...
    def setColorModel(self, colorModel: java.awt.image.ColorModel) -> None: ...
    def setCompression(self, string: java.lang.String | str) -> None: ...
    def setFramesPerSecond(self, int: int) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setInterleaved(self, boolean: bool) -> None: ...
    def setMetadataRetrieve(
        self, metadataRetrieve: loci.formats.meta.MetadataRetrieve
    ) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setResolutions(self, list: java.util.List[Resolution]) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def setTileSizeX(self, int: int) -> int: ...
    def setTileSizeY(self, int: int) -> int: ...
    def setValidBitsPerPixel(self, int: int) -> None: ...
    def setWriteSequentially(self, boolean: bool) -> None: ...

class ImageReader(IFormatReader):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classList: ClassList[IFormatReader]): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def fileGroupOption(self, string: java.lang.String | str) -> int: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getAdvancedSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAdvancedUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getCurrentFile(self) -> java.lang.String: ...
    def getDatasetStructureDescription(self) -> java.lang.String: ...
    @staticmethod
    def getDefaultReaderClasses() -> ClassList[IFormatReader]: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getDomains(self) -> typing.MutableSequence[java.lang.String]: ...
    def getEffectiveSizeC(self) -> int: ...
    def getFillColor(self) -> int: ...
    @typing.overload
    def getFormat(self) -> java.lang.String: ...
    @typing.overload
    def getFormat(self, string: java.lang.String | str) -> java.lang.String: ...
    def getGlobalMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    def getModuloC(self) -> Modulo: ...
    def getModuloT(self) -> Modulo: ...
    def getModuloZ(self) -> Modulo: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    def getPixelType(self) -> int: ...
    def getPossibleDomains(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getRGBChannelCount(self) -> int: ...
    @typing.overload
    def getReader(self) -> IFormatReader: ...
    @typing.overload
    def getReader(self, class_: type[IFormatReader]) -> IFormatReader: ...
    @typing.overload
    def getReader(self, string: java.lang.String | str) -> IFormatReader: ...
    def getReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    def getRequiredDirectories(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> int: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getSeriesMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getTileColumns(self, int: int) -> int: ...
    def getTileRows(self, int: int) -> int: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def hasCompanionFiles(self) -> bool: ...
    def hasFlattenedResolutions(self) -> bool: ...
    def isFalseColor(self) -> bool: ...
    def isGroupFiles(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isMetadataComplete(self) -> bool: ...
    def isMetadataFiltered(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isOriginalMetadataPopulated(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isSingleFile(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str, boolean: bool) -> bool: ...
    @typing.overload
    def isThisType(
        self, randomAccessInputStream: loci.common.RandomAccessInputStream
    ) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setAllowOpenFiles(self, boolean: bool) -> None: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFillColor(self, byte: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setMetadataFiltered(self, boolean: bool) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...

class ImageWriter(IFormatWriter):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classList: ClassList[IFormatWriter]): ...
    def canDoStacks(self) -> bool: ...
    def changeOutputFile(self, string: java.lang.String | str) -> None: ...
    def close(self) -> None: ...
    def getCodec(self) -> loci.formats.codec.Codec: ...
    def getCodecOptions(self) -> loci.formats.codec.CodecOptions: ...
    def getColorModel(self) -> java.awt.image.ColorModel: ...
    def getCompression(self) -> java.lang.String: ...
    def getCompressionTypes(self) -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def getDefaultWriterClasses() -> ClassList[IFormatWriter]: ...
    @typing.overload
    def getFormat(self) -> java.lang.String: ...
    @typing.overload
    def getFormat(self, string: java.lang.String | str) -> java.lang.String: ...
    def getFramesPerSecond(self) -> int: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getMetadataRetrieve(self) -> loci.formats.meta.MetadataRetrieve: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    @typing.overload
    def getPixelTypes(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getPixelTypes(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[int]: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getResolutions(self) -> java.util.List[Resolution]: ...
    def getSeries(self) -> int: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def getTileSizeX(self) -> int: ...
    def getTileSizeY(self) -> int: ...
    @typing.overload
    def getWriter(self) -> IFormatWriter: ...
    @typing.overload
    def getWriter(self, class_: type[IFormatWriter]) -> IFormatWriter: ...
    @typing.overload
    def getWriter(self, string: java.lang.String | str) -> IFormatWriter: ...
    def getWriters(self) -> typing.MutableSequence[IFormatWriter]: ...
    def isInterleaved(self) -> bool: ...
    def isSupportedType(self, int: int) -> bool: ...
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def saveBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        region: loci.common.Region,
    ) -> None: ...
    def saveCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def savePlane(self, int: int, object: typing.Any) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, int2: int, int3: int, int4: int, int5: int
    ) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, region: loci.common.Region
    ) -> None: ...
    def setCodecOptions(
        self, codecOptions: loci.formats.codec.CodecOptions
    ) -> None: ...
    def setColorModel(self, colorModel: java.awt.image.ColorModel) -> None: ...
    def setCompression(self, string: java.lang.String | str) -> None: ...
    def setFramesPerSecond(self, int: int) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setInterleaved(self, boolean: bool) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataRetrieve(
        self, metadataRetrieve: loci.formats.meta.MetadataRetrieve
    ) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setResolutions(self, list: java.util.List[Resolution]) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def setTileSizeX(self, int: int) -> int: ...
    def setTileSizeY(self, int: int) -> int: ...
    def setValidBitsPerPixel(self, int: int) -> None: ...
    def setWriteSequentially(self, boolean: bool) -> None: ...

class ReaderWrapper(IFormatReader):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def duplicate(self, class_: type[IFormatReader]) -> ReaderWrapper: ...
    def fileGroupOption(self, string: java.lang.String | str) -> int: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getAdvancedSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAdvancedUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getCurrentFile(self) -> java.lang.String: ...
    def getDatasetStructureDescription(self) -> java.lang.String: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getDomains(self) -> typing.MutableSequence[java.lang.String]: ...
    def getEffectiveSizeC(self) -> int: ...
    def getFillColor(self) -> int: ...
    def getFormat(self) -> java.lang.String: ...
    def getGlobalMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    def getModuloC(self) -> Modulo: ...
    def getModuloT(self) -> Modulo: ...
    def getModuloZ(self) -> Modulo: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    def getPixelType(self) -> int: ...
    def getPossibleDomains(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getRGBChannelCount(self) -> int: ...
    def getReader(self) -> IFormatReader: ...
    def getRequiredDirectories(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> int: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getSeriesMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getTileColumns(self, int: int) -> int: ...
    def getTileRows(self, int: int) -> int: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def hasCompanionFiles(self) -> bool: ...
    def hasFlattenedResolutions(self) -> bool: ...
    def isFalseColor(self) -> bool: ...
    def isGroupFiles(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isMetadataComplete(self) -> bool: ...
    def isMetadataFiltered(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isOriginalMetadataPopulated(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isSingleFile(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str, boolean: bool) -> bool: ...
    @typing.overload
    def isThisType(
        self, randomAccessInputStream: loci.common.RandomAccessInputStream
    ) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFillColor(self, byte: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setMetadataFiltered(self, boolean: bool) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...
    @typing.overload
    def unwrap(self) -> IFormatReader: ...
    @typing.overload
    def unwrap(
        self, class_: type[IFormatReader], string: java.lang.String | str
    ) -> IFormatReader: ...
    @typing.overload
    def unwrap(self, string: java.lang.String | str) -> IFormatReader: ...

class WriterWrapper(IFormatWriter):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatWriter: IFormatWriter): ...
    def canDoStacks(self) -> bool: ...
    def changeOutputFile(self, string: java.lang.String | str) -> None: ...
    def close(self) -> None: ...
    def duplicate(self, class_: type[IFormatWriter]) -> WriterWrapper: ...
    def getCodec(self) -> loci.formats.codec.Codec: ...
    def getCodecOptions(self) -> loci.formats.codec.CodecOptions: ...
    def getColorModel(self) -> java.awt.image.ColorModel: ...
    def getCompression(self) -> java.lang.String: ...
    def getCompressionTypes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getFormat(self) -> java.lang.String: ...
    def getFramesPerSecond(self) -> int: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getMetadataRetrieve(self) -> loci.formats.meta.MetadataRetrieve: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    @typing.overload
    def getPixelTypes(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getPixelTypes(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[int]: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getResolutions(self) -> java.util.List[Resolution]: ...
    def getSeries(self) -> int: ...
    def getSuffixes(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def getTileSizeX(self) -> int: ...
    def getTileSizeY(self) -> int: ...
    def getWriter(self) -> IFormatWriter: ...
    def isInterleaved(self) -> bool: ...
    def isSupportedType(self, int: int) -> bool: ...
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def saveBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def saveBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        region: loci.common.Region,
    ) -> None: ...
    def saveCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> None: ...
    @typing.overload
    def savePlane(self, int: int, object: typing.Any) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, int2: int, int3: int, int4: int, int5: int
    ) -> None: ...
    @typing.overload
    def savePlane(
        self, int: int, object: typing.Any, region: loci.common.Region
    ) -> None: ...
    def setCodecOptions(
        self, codecOptions: loci.formats.codec.CodecOptions
    ) -> None: ...
    def setColorModel(self, colorModel: java.awt.image.ColorModel) -> None: ...
    def setCompression(self, string: java.lang.String | str) -> None: ...
    def setFramesPerSecond(self, int: int) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setInterleaved(self, boolean: bool) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataRetrieve(
        self, metadataRetrieve: loci.formats.meta.MetadataRetrieve
    ) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setResolutions(self, list: java.util.List[Resolution]) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def setTileSizeX(self, int: int) -> int: ...
    def setTileSizeY(self, int: int) -> int: ...
    def setValidBitsPerPixel(self, int: int) -> None: ...
    def setWriteSequentially(self, boolean: bool) -> None: ...
    @typing.overload
    def unwrap(self) -> IFormatWriter: ...
    @typing.overload
    def unwrap(
        self, class_: type[IFormatWriter], string: java.lang.String | str
    ) -> IFormatWriter: ...
    @typing.overload
    def unwrap(self, string: java.lang.String | str) -> IFormatWriter: ...

class ChannelFiller(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getBitsPerPixel(self) -> int: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getSizeC(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def isFilled(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    def isRGB(self) -> bool: ...
    @staticmethod
    def makeChannelFiller(iFormatReader: IFormatReader) -> ChannelFiller: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def setFilled(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...

class ChannelMerger(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    def canMerge(self) -> bool: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getOriginalIndex(self, int: int) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isRGB(self) -> bool: ...
    @staticmethod
    def makeChannelMerger(iFormatReader: IFormatReader) -> ChannelMerger: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...

class ChannelSeparator(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getOriginalIndex(self, int: int) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def isRGB(self) -> bool: ...
    @staticmethod
    def makeChannelSeparator(iFormatReader: IFormatReader) -> ChannelSeparator: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def setId(self, string: java.lang.String | str) -> None: ...

class DelegateReader(FormatReader):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getMetadataOptions(self) -> loci.formats.in_.MetadataOptions: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    def getSupportedMetadataLevels(
        self,
    ) -> java.util.Set[loci.formats.in_.MetadataLevel]: ...
    def isLegacy(self) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str, boolean: bool) -> bool: ...
    @typing.overload
    def isThisType(
        self, randomAccessInputStream: loci.common.RandomAccessInputStream
    ) -> bool: ...
    @typing.overload
    def isThisType(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def isThisType(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setLegacy(self, boolean: bool) -> None: ...
    def setMetadataFiltered(self, boolean: bool) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...

class DimensionSwapper(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getInputOrder(self) -> java.lang.String: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    @staticmethod
    def makeDimensionSwapper(iFormatReader: IFormatReader) -> DimensionSwapper: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setOutputOrder(self, string: java.lang.String | str) -> None: ...
    def swapDimensions(self, string: java.lang.String | str) -> None: ...

class FileStitcher(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader, boolean: bool): ...
    def canChangePattern(self) -> bool: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def findPattern(self, string: java.lang.String | str) -> FilePattern: ...
    def findPatterns(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getAdjustedIndex(self, int: int) -> int: ...
    def getAdvancedSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAdvancedUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[FileInfo]: ...
    def getAxisGuesser(self) -> AxisGuesser: ...
    def getAxisTypes(self) -> typing.MutableSequence[int]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getFilePattern(self) -> FilePattern: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getPixelType(self) -> int: ...
    @typing.overload
    def getReader(self, int: int, int2: int) -> DimensionSwapper: ...
    @typing.overload
    def getReader(self) -> IFormatReader: ...
    @typing.overload
    def getReader(self, int: int) -> IFormatReader: ...
    def getRequiredDirectories(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> int: ...
    def getResolution(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def getZCTModuloCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def isFalseColor(self) -> bool: ...
    def isGroupFiles(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    def isUsingPatternIds(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setAxisTypes(self, intArray: list[int] | jpype.JArray) -> None: ...
    def setCanChangePattern(self, boolean: bool) -> None: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setFlattenedResolutions(self, boolean: bool) -> None: ...
    def setGroupFiles(self, boolean: bool) -> None: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setMetadataOptions(
        self, metadataOptions: loci.formats.in_.MetadataOptions
    ) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setNormalized(self, boolean: bool) -> None: ...
    def setOriginalMetadataPopulated(self, boolean: bool) -> None: ...
    def setReaderClassList(self, classList: ClassList[IFormatReader]) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...
    def setUsingPatternIds(self, boolean: bool) -> None: ...

class MinMaxCalculator(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    def getChannelGlobalMaximum(self, int: int) -> float: ...
    def getChannelGlobalMinimum(self, int: int) -> float: ...
    def getChannelKnownMaximum(self, int: int) -> float: ...
    def getChannelKnownMinimum(self, int: int) -> float: ...
    def getMinMaxStore(self) -> loci.formats.meta.IMinMaxStore: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getPlaneMaximum(self, int: int) -> typing.MutableSequence[float]: ...
    def getPlaneMinimum(self, int: int) -> typing.MutableSequence[float]: ...
    def isMinMaxPopulated(self) -> bool: ...
    @staticmethod
    def makeMinMaxCalculator(iFormatReader: IFormatReader) -> MinMaxCalculator: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    def setMinMaxStore(
        self, iMinMaxStore: loci.formats.meta.IMinMaxStore | typing.Callable
    ) -> None: ...

class SubResolutionFormatReader(FormatReader):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...

class TileStitcher(ReaderWrapper):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getSeriesCount(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getTileCodec(self, int: int) -> loci.formats.codec.Codec: ...
    def getTileCodecOptions(
        self, int: int, int2: int, int3: int
    ) -> loci.formats.codec.CodecOptions: ...
    def getTileColumns(self, int: int) -> int: ...
    def getTileRows(self, int: int) -> int: ...
    @staticmethod
    def makeTileStitcher(iFormatReader: IFormatReader) -> TileStitcher: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openCompressedBytes(
        self, int: int, int2: int, int3: int
    ) -> typing.MutableSequence[int]: ...
    def setId(self, string: java.lang.String | str) -> None: ...

class WrappedReader(FormatReader):
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def coreIndexToSeries(self, int: int) -> int: ...
    def get16BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def get8BitLookupTable(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[int]]: ...
    def getBitsPerPixel(self) -> int: ...
    def getCoreIndex(self) -> int: ...
    def getCoreMetadataList(self) -> java.util.List[CoreMetadata]: ...
    def getDatasetStructureDescription(self) -> java.lang.String: ...
    def getDimensionOrder(self) -> java.lang.String: ...
    def getDomains(self) -> typing.MutableSequence[java.lang.String]: ...
    def getEffectiveSizeC(self) -> int: ...
    def getGlobalMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getImageCount(self) -> int: ...
    @typing.overload
    def getIndex(
        self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int
    ) -> int: ...
    @typing.overload
    def getIndex(self, int: int, int2: int, int3: int) -> int: ...
    def getMetadataStoreRoot(self) -> typing.Any: ...
    def getMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    def getModuloC(self) -> Modulo: ...
    def getModuloT(self) -> Modulo: ...
    def getModuloZ(self) -> Modulo: ...
    def getNativeDataType(self) -> type[typing.Any]: ...
    def getOptimalTileHeight(self) -> int: ...
    def getOptimalTileWidth(self) -> int: ...
    def getPixelType(self) -> int: ...
    def getPossibleDomains(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getRGBChannelCount(self) -> int: ...
    def getResolution(self) -> int: ...
    def getResolutionCount(self) -> int: ...
    def getSeries(self) -> int: ...
    def getSeriesCount(self) -> int: ...
    def getSeriesMetadata(
        self,
    ) -> java.util.Hashtable[java.lang.String, typing.Any]: ...
    def getSeriesMetadataValue(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def getSeriesUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getSeriesUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getSizeC(self) -> int: ...
    def getSizeT(self) -> int: ...
    def getSizeX(self) -> int: ...
    def getSizeY(self) -> int: ...
    def getSizeZ(self) -> int: ...
    def getThumbSizeX(self) -> int: ...
    def getThumbSizeY(self) -> int: ...
    def getUnderlyingReaders(self) -> typing.MutableSequence[IFormatReader]: ...
    @typing.overload
    def getUsedFiles(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def getUsedFiles(
        self, boolean: bool
    ) -> typing.MutableSequence[java.lang.String]: ...
    def getZCTCoords(self, int: int) -> typing.MutableSequence[int]: ...
    def hasCompanionFiles(self) -> bool: ...
    def isFalseColor(self) -> bool: ...
    def isIndexed(self) -> bool: ...
    @typing.overload
    def isInterleaved(self) -> bool: ...
    @typing.overload
    def isInterleaved(self, int: int) -> bool: ...
    def isLittleEndian(self) -> bool: ...
    def isMetadataComplete(self) -> bool: ...
    def isOrderCertain(self) -> bool: ...
    def isRGB(self) -> bool: ...
    def isSingleFile(self, string: java.lang.String | str) -> bool: ...
    def isThumbnailSeries(self) -> bool: ...
    @typing.overload
    def openBytes(self, int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
        int5: int,
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def openBytes(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.MutableSequence[int]: ...
    def openPlane(
        self, int: int, int2: int, int3: int, int4: int, int5: int
    ) -> typing.Any: ...
    def openThumbBytes(self, int: int) -> typing.MutableSequence[int]: ...
    def reopenFile(self) -> None: ...
    def seriesToCoreIndex(self, int: int) -> int: ...
    def setCoreIndex(self, int: int) -> None: ...
    def setResolution(self, int: int) -> None: ...
    def setSeries(self, int: int) -> None: ...

class Memoizer(ReaderWrapper):
    VERSION: typing.ClassVar[int] = ...
    DEFAULT_MINIMUM_ELAPSED: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader): ...
    @typing.overload
    def __init__(
        self,
        iFormatReader: IFormatReader,
        file: java.io.File | jpype.protocol.SupportsPath,
    ): ...
    @typing.overload
    def __init__(self, iFormatReader: IFormatReader, long: int): ...
    @typing.overload
    def __init__(
        self,
        iFormatReader: IFormatReader,
        long: int,
        file: java.io.File | jpype.protocol.SupportsPath,
    ): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def __init__(self, long: int, file: java.io.File | jpype.protocol.SupportsPath): ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, boolean: bool) -> None: ...
    def deleteMemo(self) -> bool: ...
    def generateMemo(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def getMemoFile(self) -> java.io.File: ...
    @typing.overload
    def getMemoFile(self, string: java.lang.String | str) -> java.io.File: ...
    def getMetadataStore(self) -> loci.formats.meta.MetadataStore: ...
    def isLoadedFromMemo(self) -> bool: ...
    def isSavedToMemo(self) -> bool: ...
    def isVersionChecking(self) -> bool: ...
    def loadMemo(self) -> IFormatReader: ...
    @staticmethod
    def main(stringArray: list[java.lang.String] | jpype.JArray) -> None: ...
    def saveMemo(self) -> bool: ...
    def setId(self, string: java.lang.String | str) -> None: ...
    def setMetadataStore(
        self, metadataStore: loci.formats.meta.MetadataStore
    ) -> None: ...
    def setVersionChecking(self, boolean: bool) -> None: ...
    def skipSave(self, boolean: bool) -> None: ...
    def versionMismatch(self) -> bool: ...
    class Deser:
        def close(self) -> None: ...
        def loadReader(self) -> IFormatReader: ...
        def loadReleaseVersion(self) -> java.lang.String: ...
        def loadRevision(self) -> java.lang.String: ...
        def loadStart(
            self, file: java.io.File | jpype.protocol.SupportsPath
        ) -> None: ...
        def loadStop(self) -> None: ...
        def loadVersion(self) -> int: ...
        def saveReader(self, iFormatReader: IFormatReader) -> None: ...
        def saveReleaseVersion(self, string: java.lang.String | str) -> None: ...
        def saveRevision(self, string: java.lang.String | str) -> None: ...
        def saveStart(
            self, file: java.io.File | jpype.protocol.SupportsPath
        ) -> None: ...
        def saveStop(self) -> None: ...
        def saveVersion(self, integer: int) -> None: ...

    class KryoDeser(loci.formats.Memoizer.Deser):
        kryo: com.esotericsoftware.kryo.Kryo = ...
        def __init__(self): ...
        def close(self) -> None: ...
        def loadReader(self) -> IFormatReader: ...
        def loadReleaseVersion(self) -> java.lang.String: ...
        def loadRevision(self) -> java.lang.String: ...
        def loadStart(
            self, file: java.io.File | jpype.protocol.SupportsPath
        ) -> None: ...
        def loadStop(self) -> None: ...
        def loadVersion(self) -> int: ...
        def saveReader(self, iFormatReader: IFormatReader) -> None: ...
        def saveReleaseVersion(self, string: java.lang.String | str) -> None: ...
        def saveRevision(self, string: java.lang.String | str) -> None: ...
        def saveStart(
            self, file: java.io.File | jpype.protocol.SupportsPath
        ) -> None: ...
        def saveStop(self) -> None: ...
        def saveVersion(self, integer: int) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("loci.formats")``.

    AxisGuesser: type[AxisGuesser]
    ChannelFiller: type[ChannelFiller]
    ChannelMerger: type[ChannelMerger]
    ChannelSeparator: type[ChannelSeparator]
    ClassList: type[ClassList]
    CoreMetadata: type[CoreMetadata]
    CoreMetadataList: type[CoreMetadataList]
    DelegateReader: type[DelegateReader]
    DimensionSwapper: type[DimensionSwapper]
    FileInfo: type[FileInfo]
    FilePattern: type[FilePattern]
    FilePatternBlock: type[FilePatternBlock]
    FileStitcher: type[FileStitcher]
    FormatException: type[FormatException]
    FormatHandler: type[FormatHandler]
    FormatReader: type[FormatReader]
    FormatTools: type[FormatTools]
    FormatWriter: type[FormatWriter]
    ICompressedTileReader: type[ICompressedTileReader]
    ICompressedTileWriter: type[ICompressedTileWriter]
    IFormatHandler: type[IFormatHandler]
    IFormatReader: type[IFormatReader]
    IFormatWriter: type[IFormatWriter]
    IMetadataConfigurable: type[IMetadataConfigurable]
    IPyramidHandler: type[IPyramidHandler]
    IllegalBlockException: type[IllegalBlockException]
    ImageReader: type[ImageReader]
    ImageTools: type[ImageTools]
    ImageWriter: type[ImageWriter]
    Memoizer: type[Memoizer]
    MetadataList: type[MetadataList]
    MetadataTools: type[MetadataTools]
    MinMaxCalculator: type[MinMaxCalculator]
    MissingLibraryException: type[MissingLibraryException]
    Modulo: type[Modulo]
    NumberFilter: type[NumberFilter]
    ReaderWrapper: type[ReaderWrapper]
    Resolution: type[Resolution]
    ResourceNamer: type[ResourceNamer]
    SubResolutionFormatReader: type[SubResolutionFormatReader]
    SwappableMetadata: type[SwappableMetadata]
    TileStitcher: type[TileStitcher]
    UnknownFormatException: type[UnknownFormatException]
    UnsupportedCompressionException: type[UnsupportedCompressionException]
    UpgradeChecker: type[UpgradeChecker]
    WrappedReader: type[WrappedReader]
    WriterWrapper: type[WriterWrapper]
    cache: loci.formats.cache.__module_protocol__
    codec: loci.formats.codec.__module_protocol__
    dicom: loci.formats.dicom.__module_protocol__
    filter: loci.formats.filter.__module_protocol__
    gui: loci.formats.gui.__module_protocol__
    in_: loci.formats.in_.__module_protocol__
    meta: loci.formats.meta.__module_protocol__
    ome: loci.formats.ome.__module_protocol__
    out: loci.formats.out.__module_protocol__
    services: loci.formats.services.__module_protocol__
    tiff: loci.formats.tiff.__module_protocol__
    tools: loci.formats.tools.__module_protocol__
