import typing
from typing import Protocol

import java
import java.io
import java.lang
import java.net
import java.nio
import java.security.cert
import java.security.interfaces
import java.security.spec
import java.util
import java.util.function
import java.util.stream
import javax.crypto
import javax.security.auth
import javax.security.auth.callback
import javax.security.auth.login
import jpype
import jpype.protocol

class AccessControlContext:
    @typing.overload
    def __init__(
        self,
        accessControlContext: AccessControlContext,
        domainCombiner: DomainCombiner | typing.Callable,
    ): ...
    @typing.overload
    def __init__(
        self, protectionDomainArray: list[ProtectionDomain] | jpype.JArray
    ): ...
    def checkPermission(self, permission: Permission) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDomainCombiner(self) -> DomainCombiner: ...
    def hashCode(self) -> int: ...

class AccessControlException(java.lang.SecurityException):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, permission: Permission): ...
    def getPermission(self) -> Permission: ...

class AccessController:
    @staticmethod
    def checkPermission(permission: Permission) -> None: ...
    _doPrivileged_0__T = typing.TypeVar("_doPrivileged_0__T")  # <T>
    _doPrivileged_1__T = typing.TypeVar("_doPrivileged_1__T")  # <T>
    _doPrivileged_2__T = typing.TypeVar("_doPrivileged_2__T")  # <T>
    _doPrivileged_3__T = typing.TypeVar("_doPrivileged_3__T")  # <T>
    _doPrivileged_4__T = typing.TypeVar("_doPrivileged_4__T")  # <T>
    _doPrivileged_5__T = typing.TypeVar("_doPrivileged_5__T")  # <T>
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedAction: PrivilegedAction[_doPrivileged_0__T]
        | typing.Callable[[], _doPrivileged_0__T],
    ) -> _doPrivileged_0__T: ...
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedAction: PrivilegedAction[_doPrivileged_1__T]
        | typing.Callable[[], _doPrivileged_1__T],
        accessControlContext: AccessControlContext,
    ) -> _doPrivileged_1__T: ...
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedAction: PrivilegedAction[_doPrivileged_2__T]
        | typing.Callable[[], _doPrivileged_2__T],
        accessControlContext: AccessControlContext,
        *permission: Permission,
    ) -> _doPrivileged_2__T: ...
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedExceptionAction: PrivilegedExceptionAction[_doPrivileged_3__T]
        | typing.Callable[[], _doPrivileged_3__T],
    ) -> _doPrivileged_3__T: ...
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedExceptionAction: PrivilegedExceptionAction[_doPrivileged_4__T]
        | typing.Callable[[], _doPrivileged_4__T],
        accessControlContext: AccessControlContext,
    ) -> _doPrivileged_4__T: ...
    @typing.overload
    @staticmethod
    def doPrivileged(
        privilegedExceptionAction: PrivilegedExceptionAction[_doPrivileged_5__T]
        | typing.Callable[[], _doPrivileged_5__T],
        accessControlContext: AccessControlContext,
        *permission: Permission,
    ) -> _doPrivileged_5__T: ...
    _doPrivilegedWithCombiner_0__T = typing.TypeVar(
        "_doPrivilegedWithCombiner_0__T"
    )  # <T>
    _doPrivilegedWithCombiner_1__T = typing.TypeVar(
        "_doPrivilegedWithCombiner_1__T"
    )  # <T>
    _doPrivilegedWithCombiner_2__T = typing.TypeVar(
        "_doPrivilegedWithCombiner_2__T"
    )  # <T>
    _doPrivilegedWithCombiner_3__T = typing.TypeVar(
        "_doPrivilegedWithCombiner_3__T"
    )  # <T>
    @typing.overload
    @staticmethod
    def doPrivilegedWithCombiner(
        privilegedAction: PrivilegedAction[_doPrivilegedWithCombiner_0__T]
        | typing.Callable[[], _doPrivilegedWithCombiner_0__T],
    ) -> _doPrivilegedWithCombiner_0__T: ...
    @typing.overload
    @staticmethod
    def doPrivilegedWithCombiner(
        privilegedAction: PrivilegedAction[_doPrivilegedWithCombiner_1__T]
        | typing.Callable[[], _doPrivilegedWithCombiner_1__T],
        accessControlContext: AccessControlContext,
        *permission: Permission,
    ) -> _doPrivilegedWithCombiner_1__T: ...
    @typing.overload
    @staticmethod
    def doPrivilegedWithCombiner(
        privilegedExceptionAction: PrivilegedExceptionAction[
            _doPrivilegedWithCombiner_2__T
        ]
        | typing.Callable[[], _doPrivilegedWithCombiner_2__T],
    ) -> _doPrivilegedWithCombiner_2__T: ...
    @typing.overload
    @staticmethod
    def doPrivilegedWithCombiner(
        privilegedExceptionAction: PrivilegedExceptionAction[
            _doPrivilegedWithCombiner_3__T
        ]
        | typing.Callable[[], _doPrivilegedWithCombiner_3__T],
        accessControlContext: AccessControlContext,
        *permission: Permission,
    ) -> _doPrivilegedWithCombiner_3__T: ...
    @staticmethod
    def getContext() -> AccessControlContext: ...

class AlgorithmConstraints:
    @typing.overload
    def permits(
        self,
        set: java.util.Set[CryptoPrimitive],
        string: java.lang.String | str,
        algorithmParameters: AlgorithmParameters,
    ) -> bool: ...
    @typing.overload
    def permits(
        self,
        set: java.util.Set[CryptoPrimitive],
        string: java.lang.String | str,
        key: Key,
        algorithmParameters: AlgorithmParameters,
    ) -> bool: ...
    @typing.overload
    def permits(self, set: java.util.Set[CryptoPrimitive], key: Key) -> bool: ...

class AlgorithmParameterGenerator:
    def generateParameters(self) -> AlgorithmParameters: ...
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> AlgorithmParameterGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> AlgorithmParameterGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> AlgorithmParameterGenerator: ...
    def getProvider(self) -> Provider: ...
    @typing.overload
    def init(self, int: int) -> None: ...
    @typing.overload
    def init(self, int: int, secureRandom: SecureRandom) -> None: ...
    @typing.overload
    def init(
        self, algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec
    ) -> None: ...
    @typing.overload
    def init(
        self,
        algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec,
        secureRandom: SecureRandom,
    ) -> None: ...

class AlgorithmParameterGeneratorSpi:
    def __init__(self): ...

class AlgorithmParameters:
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    def getEncoded(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def getEncoded(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> AlgorithmParameters: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> AlgorithmParameters: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> AlgorithmParameters: ...
    _getParameterSpec__T = typing.TypeVar(
        "_getParameterSpec__T", bound=java.security.spec.AlgorithmParameterSpec
    )  # <T>
    def getParameterSpec(
        self, class_: type[_getParameterSpec__T]
    ) -> _getParameterSpec__T: ...
    def getProvider(self) -> Provider: ...
    @typing.overload
    def init(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def init(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        string: java.lang.String | str,
    ) -> None: ...
    @typing.overload
    def init(
        self, algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec
    ) -> None: ...
    def toString(self) -> java.lang.String: ...

class AlgorithmParametersSpi:
    def __init__(self): ...

class Certificate:
    def decode(self, inputStream: java.io.InputStream) -> None: ...
    def encode(self, outputStream: java.io.OutputStream) -> None: ...
    def getFormat(self) -> java.lang.String: ...
    def getGuarantor(self) -> Principal: ...
    def getPrincipal(self) -> Principal: ...
    def getPublicKey(self) -> PublicKey: ...
    def toString(self, boolean: bool) -> java.lang.String: ...

class CodeSigner(java.io.Serializable):
    def __init__(self, certPath: java.security.cert.CertPath, timestamp: Timestamp): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getSignerCertPath(self) -> java.security.cert.CertPath: ...
    def getTimestamp(self) -> Timestamp: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class CodeSource(java.io.Serializable):
    @typing.overload
    def __init__(
        self, uRL: java.net.URL, codeSignerArray: list[CodeSigner] | jpype.JArray
    ): ...
    @typing.overload
    def __init__(
        self,
        uRL: java.net.URL,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getCertificates(
        self,
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def getCodeSigners(self) -> typing.MutableSequence[CodeSigner]: ...
    def getLocation(self) -> java.net.URL: ...
    def hashCode(self) -> int: ...
    def implies(self, codeSource: CodeSource) -> bool: ...
    def toString(self) -> java.lang.String: ...

class CryptoPrimitive(java.lang.Enum["CryptoPrimitive"]):
    MESSAGE_DIGEST: typing.ClassVar[CryptoPrimitive] = ...
    SECURE_RANDOM: typing.ClassVar[CryptoPrimitive] = ...
    BLOCK_CIPHER: typing.ClassVar[CryptoPrimitive] = ...
    STREAM_CIPHER: typing.ClassVar[CryptoPrimitive] = ...
    MAC: typing.ClassVar[CryptoPrimitive] = ...
    KEY_WRAP: typing.ClassVar[CryptoPrimitive] = ...
    PUBLIC_KEY_ENCRYPTION: typing.ClassVar[CryptoPrimitive] = ...
    SIGNATURE: typing.ClassVar[CryptoPrimitive] = ...
    KEY_ENCAPSULATION: typing.ClassVar[CryptoPrimitive] = ...
    KEY_AGREEMENT: typing.ClassVar[CryptoPrimitive] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: type[_valueOf_0__T], string: java.lang.String | str
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: java.lang.String | str) -> CryptoPrimitive: ...
    @staticmethod
    def values() -> typing.MutableSequence[CryptoPrimitive]: ...

class DEREncodable: ...

class DigestInputStream(java.io.FilterInputStream):
    def __init__(
        self, inputStream: java.io.InputStream, messageDigest: MessageDigest
    ): ...
    def getMessageDigest(self) -> MessageDigest: ...
    def on(self, boolean: bool) -> None: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    def setMessageDigest(self, messageDigest: MessageDigest) -> None: ...
    def toString(self) -> java.lang.String: ...

class DigestOutputStream(java.io.FilterOutputStream):
    def __init__(
        self, outputStream: java.io.OutputStream, messageDigest: MessageDigest
    ): ...
    def getMessageDigest(self) -> MessageDigest: ...
    def on(self, boolean: bool) -> None: ...
    def setMessageDigest(self, messageDigest: MessageDigest) -> None: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class DomainCombiner:
    def combine(
        self,
        protectionDomainArray: list[ProtectionDomain] | jpype.JArray,
        protectionDomainArray2: list[ProtectionDomain] | jpype.JArray,
    ) -> typing.MutableSequence[ProtectionDomain]: ...

class GeneralSecurityException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Guard:
    def checkGuard(self, object: typing.Any) -> None: ...

class GuardedObject(java.io.Serializable):
    def __init__(self, object: typing.Any, guard: Guard | typing.Callable): ...
    def getObject(self) -> typing.Any: ...

class InvalidParameterException(java.lang.IllegalArgumentException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Key(java.io.Serializable):
    serialVersionUID: typing.ClassVar[int] = ...
    def getAlgorithm(self) -> java.lang.String: ...
    def getEncoded(self) -> typing.MutableSequence[int]: ...
    def getFormat(self) -> java.lang.String: ...

class KeyFactory:
    def generatePrivate(self, keySpec: java.security.spec.KeySpec) -> PrivateKey: ...
    def generatePublic(self, keySpec: java.security.spec.KeySpec) -> PublicKey: ...
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> KeyFactory: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> KeyFactory: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> KeyFactory: ...
    _getKeySpec__T = typing.TypeVar(
        "_getKeySpec__T", bound=java.security.spec.KeySpec
    )  # <T>
    def getKeySpec(self, key: Key, class_: type[_getKeySpec__T]) -> _getKeySpec__T: ...
    def getProvider(self) -> Provider: ...
    def translateKey(self, key: Key) -> Key: ...

class KeyFactorySpi:
    def __init__(self): ...

class KeyPairGeneratorSpi:
    def __init__(self): ...
    def generateKeyPair(self) -> KeyPair: ...
    @typing.overload
    def initialize(self, int: int, secureRandom: SecureRandom) -> None: ...
    @typing.overload
    def initialize(
        self,
        algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec,
        secureRandom: SecureRandom,
    ) -> None: ...

class KeyRep(java.io.Serializable):
    def __init__(
        self,
        type: KeyRep.Type,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        byteArray: list[int] | jpype.JArray | bytes,
    ): ...
    class Type(java.lang.Enum["KeyRep.Type"]):
        SECRET: typing.ClassVar[KeyRep.Type] = ...
        PUBLIC: typing.ClassVar[KeyRep.Type] = ...
        PRIVATE: typing.ClassVar[KeyRep.Type] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> KeyRep.Type: ...
        @staticmethod
        def values() -> typing.MutableSequence[KeyRep.Type]: ...

class KeyStoreSpi:
    def __init__(self): ...
    def engineAliases(self) -> java.util.Enumeration[java.lang.String]: ...
    def engineContainsAlias(self, string: java.lang.String | str) -> bool: ...
    def engineDeleteEntry(self, string: java.lang.String | str) -> None: ...
    def engineEntryInstanceOf(
        self, string: java.lang.String | str, class_: type[KeyStore.Entry]
    ) -> bool: ...
    def engineGetAttributes(
        self, string: java.lang.String | str
    ) -> java.util.Set[KeyStore.Entry.Attribute]: ...
    def engineGetCertificate(
        self, string: java.lang.String | str
    ) -> java.security.cert.Certificate: ...
    def engineGetCertificateAlias(
        self, certificate: java.security.cert.Certificate
    ) -> java.lang.String: ...
    def engineGetCertificateChain(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def engineGetCreationDate(
        self, string: java.lang.String | str
    ) -> java.util.Date: ...
    def engineGetEntry(
        self,
        string: java.lang.String | str,
        protectionParameter: KeyStore.ProtectionParameter,
    ) -> KeyStore.Entry: ...
    def engineGetKey(
        self, string: java.lang.String | str, charArray: list[str] | jpype.JArray
    ) -> Key: ...
    def engineIsCertificateEntry(self, string: java.lang.String | str) -> bool: ...
    def engineIsKeyEntry(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def engineLoad(
        self, inputStream: java.io.InputStream, charArray: list[str] | jpype.JArray
    ) -> None: ...
    @typing.overload
    def engineLoad(
        self, loadStoreParameter: KeyStore.LoadStoreParameter | typing.Callable
    ) -> None: ...
    def engineProbe(self, inputStream: java.io.InputStream) -> bool: ...
    def engineSetCertificateEntry(
        self,
        string: java.lang.String | str,
        certificate: java.security.cert.Certificate,
    ) -> None: ...
    def engineSetEntry(
        self,
        string: java.lang.String | str,
        entry: KeyStore.Entry,
        protectionParameter: KeyStore.ProtectionParameter,
    ) -> None: ...
    @typing.overload
    def engineSetKeyEntry(
        self,
        string: java.lang.String | str,
        byteArray: list[int] | jpype.JArray | bytes,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ) -> None: ...
    @typing.overload
    def engineSetKeyEntry(
        self,
        string: java.lang.String | str,
        key: Key,
        charArray: list[str] | jpype.JArray,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ) -> None: ...
    def engineSize(self) -> int: ...
    @typing.overload
    def engineStore(
        self, outputStream: java.io.OutputStream, charArray: list[str] | jpype.JArray
    ) -> None: ...
    @typing.overload
    def engineStore(
        self, loadStoreParameter: KeyStore.LoadStoreParameter | typing.Callable
    ) -> None: ...

class MessageDigestSpi:
    def __init__(self): ...
    def clone(self) -> typing.Any: ...

class PEMDecoder:
    _decode_1__S = typing.TypeVar("_decode_1__S", bound=DEREncodable)  # <S>
    _decode_3__S = typing.TypeVar("_decode_3__S", bound=DEREncodable)  # <S>
    @typing.overload
    def decode(self, inputStream: java.io.InputStream) -> DEREncodable: ...
    @typing.overload
    def decode(
        self, inputStream: java.io.InputStream, class_: type[_decode_1__S]
    ) -> _decode_1__S: ...
    @typing.overload
    def decode(self, string: java.lang.String | str) -> DEREncodable: ...
    @typing.overload
    def decode(
        self, string: java.lang.String | str, class_: type[_decode_3__S]
    ) -> _decode_3__S: ...
    @staticmethod
    def of() -> PEMDecoder: ...
    def withDecryption(self, charArray: list[str] | jpype.JArray) -> PEMDecoder: ...
    def withFactory(self, provider: Provider) -> PEMDecoder: ...

class PEMEncoder:
    def encode(self, dEREncodable: DEREncodable) -> typing.MutableSequence[int]: ...
    def encodeToString(self, dEREncodable: DEREncodable) -> java.lang.String: ...
    @staticmethod
    def of() -> PEMEncoder: ...
    def withEncryption(self, charArray: list[str] | jpype.JArray) -> PEMEncoder: ...

class PermissionCollection(java.io.Serializable):
    def __init__(self): ...
    def add(self, permission: Permission) -> None: ...
    def elements(self) -> java.util.Enumeration[Permission]: ...
    def elementsAsStream(self) -> java.util.stream.Stream[Permission]: ...
    def implies(self, permission: Permission) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def setReadOnly(self) -> None: ...
    def toString(self) -> java.lang.String: ...

class Policy:
    UNSUPPORTED_EMPTY_COLLECTION: typing.ClassVar[PermissionCollection] = ...
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, parameters: Policy.Parameters
    ) -> Policy: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str,
        parameters: Policy.Parameters,
        string2: java.lang.String | str,
    ) -> Policy: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str,
        parameters: Policy.Parameters,
        provider: Provider,
    ) -> Policy: ...
    def getParameters(self) -> Policy.Parameters: ...
    @typing.overload
    def getPermissions(self, codeSource: CodeSource) -> PermissionCollection: ...
    @typing.overload
    def getPermissions(
        self, protectionDomain: ProtectionDomain
    ) -> PermissionCollection: ...
    @staticmethod
    def getPolicy() -> Policy: ...
    def getProvider(self) -> Provider: ...
    def getType(self) -> java.lang.String: ...
    def implies(
        self, protectionDomain: ProtectionDomain, permission: Permission
    ) -> bool: ...
    def refresh(self) -> None: ...
    @staticmethod
    def setPolicy(policy: Policy) -> None: ...
    class Parameters: ...

class PolicySpi:
    def __init__(self): ...

class Principal:
    def equals(self, object: typing.Any) -> bool: ...
    def getName(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, subject: javax.security.auth.Subject) -> bool: ...
    def toString(self) -> java.lang.String: ...

_PrivilegedAction__T = typing.TypeVar("_PrivilegedAction__T")  # <T>

class PrivilegedAction(typing.Generic[_PrivilegedAction__T]):
    def run(self) -> _PrivilegedAction__T: ...

class PrivilegedActionException(java.lang.Exception):
    def __init__(self, exception: java.lang.Exception): ...
    def getException(self) -> java.lang.Exception: ...
    def toString(self) -> java.lang.String: ...

_PrivilegedExceptionAction__T = typing.TypeVar("_PrivilegedExceptionAction__T")  # <T>

class PrivilegedExceptionAction(typing.Generic[_PrivilegedExceptionAction__T]):
    def run(self) -> _PrivilegedExceptionAction__T: ...

class ProtectionDomain:
    @typing.overload
    def __init__(
        self, codeSource: CodeSource, permissionCollection: PermissionCollection
    ): ...
    @typing.overload
    def __init__(
        self,
        codeSource: CodeSource,
        permissionCollection: PermissionCollection,
        classLoader: java.lang.ClassLoader,
        principalArray: list[Principal] | jpype.JArray,
    ): ...
    def getClassLoader(self) -> java.lang.ClassLoader: ...
    def getCodeSource(self) -> CodeSource: ...
    def getPermissions(self) -> PermissionCollection: ...
    def getPrincipals(self) -> typing.MutableSequence[Principal]: ...
    def implies(self, permission: Permission) -> bool: ...
    def staticPermissionsOnly(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class Provider(java.util.Properties):
    def clear(self) -> None: ...
    def compute(
        self,
        object: typing.Any,
        biFunction: java.util.function.BiFunction[typing.Any, typing.Any, typing.Any]
        | typing.Callable[[typing.Any, typing.Any], typing.Any],
    ) -> typing.Any: ...
    def computeIfAbsent(
        self,
        object: typing.Any,
        function: java.util.function.Function[typing.Any, typing.Any]
        | typing.Callable[[typing.Any], typing.Any],
    ) -> typing.Any: ...
    def computeIfPresent(
        self,
        object: typing.Any,
        biFunction: java.util.function.BiFunction[typing.Any, typing.Any, typing.Any]
        | typing.Callable[[typing.Any, typing.Any], typing.Any],
    ) -> typing.Any: ...
    def configure(self, string: java.lang.String | str) -> Provider: ...
    def elements(self) -> java.util.Enumeration[typing.Any]: ...
    def entrySet(
        self,
    ) -> java.util.Set[java.util.Map.Entry[typing.Any, typing.Any]]: ...
    def forEach(
        self,
        biConsumer: java.util.function.BiConsumer[typing.Any, typing.Any]
        | typing.Callable[[typing.Any, typing.Any], None],
    ) -> None: ...
    def get(self, object: typing.Any) -> typing.Any: ...
    def getInfo(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getOrDefault(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @typing.overload
    def getProperty(self, string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    def getProperty(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    def getService(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> Provider.Service: ...
    def getServices(self) -> java.util.Set[Provider.Service]: ...
    def getVersion(self) -> float: ...
    def getVersionStr(self) -> java.lang.String: ...
    def isConfigured(self) -> bool: ...
    def keySet(self) -> java.util.Set[typing.Any]: ...
    def keys(self) -> java.util.Enumeration[typing.Any]: ...
    @typing.overload
    def load(self, inputStream: java.io.InputStream) -> None: ...
    @typing.overload
    def load(self, reader: java.io.Reader) -> None: ...
    def merge(
        self,
        object: typing.Any,
        object2: typing.Any,
        biFunction: java.util.function.BiFunction[typing.Any, typing.Any, typing.Any]
        | typing.Callable[[typing.Any, typing.Any], typing.Any],
    ) -> typing.Any: ...
    def put(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def putAll(
        self,
        map: java.util.Map[typing.Any, typing.Any]
        | typing.Mapping[typing.Any, typing.Any],
    ) -> None: ...
    def putIfAbsent(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> typing.Any: ...
    @typing.overload
    def replace(
        self, object: typing.Any, object2: typing.Any, object3: typing.Any
    ) -> bool: ...
    @typing.overload
    def replace(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def replaceAll(
        self,
        biFunction: java.util.function.BiFunction[typing.Any, typing.Any, typing.Any]
        | typing.Callable[[typing.Any, typing.Any], typing.Any],
    ) -> None: ...
    def toString(self) -> java.lang.String: ...
    def values(self) -> java.util.Collection[typing.Any]: ...
    class Service:
        def __init__(
            self,
            provider: Provider,
            string: java.lang.String | str,
            string2: java.lang.String | str,
            string3: java.lang.String | str,
            list: java.util.List[java.lang.String | str],
            map: java.util.Map[java.lang.String | str, java.lang.String | str]
            | typing.Mapping[java.lang.String | str, java.lang.String | str],
        ): ...
        def getAlgorithm(self) -> java.lang.String: ...
        def getAttribute(self, string: java.lang.String | str) -> java.lang.String: ...
        def getClassName(self) -> java.lang.String: ...
        def getProvider(self) -> Provider: ...
        def getType(self) -> java.lang.String: ...
        def newInstance(self, object: typing.Any) -> typing.Any: ...
        def supportsParameter(self, object: typing.Any) -> bool: ...
        def toString(self) -> java.lang.String: ...

class ProviderException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class SecureClassLoader(java.lang.ClassLoader): ...

class SecureRandom(java.util.Random):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    def generateSeed(self, int: int) -> typing.MutableSequence[int]: ...
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> SecureRandom: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> SecureRandom: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> SecureRandom: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, secureRandomParameters: SecureRandomParameters
    ) -> SecureRandom: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str,
        secureRandomParameters: SecureRandomParameters,
        string2: java.lang.String | str,
    ) -> SecureRandom: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str,
        secureRandomParameters: SecureRandomParameters,
        provider: Provider,
    ) -> SecureRandom: ...
    @staticmethod
    def getInstanceStrong() -> SecureRandom: ...
    def getParameters(self) -> SecureRandomParameters: ...
    def getProvider(self) -> Provider: ...
    @staticmethod
    def getSeed(int: int) -> typing.MutableSequence[int]: ...
    @typing.overload
    def nextBytes(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def nextBytes(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        secureRandomParameters: SecureRandomParameters,
    ) -> None: ...
    @typing.overload
    def reseed(self) -> None: ...
    @typing.overload
    def reseed(self, secureRandomParameters: SecureRandomParameters) -> None: ...
    @typing.overload
    def setSeed(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def setSeed(self, long: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class SecureRandomParameters: ...

class SecureRandomSpi(java.io.Serializable):
    def __init__(self): ...
    def toString(self) -> java.lang.String: ...

class Security:
    @staticmethod
    def addProvider(provider: Provider) -> int: ...
    @staticmethod
    def getAlgorithmProperty(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @staticmethod
    def getAlgorithms(
        string: java.lang.String | str,
    ) -> java.util.Set[java.lang.String]: ...
    @staticmethod
    def getProperty(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def getProvider(string: java.lang.String | str) -> Provider: ...
    @typing.overload
    @staticmethod
    def getProviders() -> typing.MutableSequence[Provider]: ...
    @typing.overload
    @staticmethod
    def getProviders(
        string: java.lang.String | str,
    ) -> typing.MutableSequence[Provider]: ...
    @typing.overload
    @staticmethod
    def getProviders(
        map: java.util.Map[java.lang.String | str, java.lang.String | str]
        | typing.Mapping[java.lang.String | str, java.lang.String | str],
    ) -> typing.MutableSequence[Provider]: ...
    @staticmethod
    def insertProviderAt(provider: Provider, int: int) -> int: ...
    @staticmethod
    def removeProvider(string: java.lang.String | str) -> None: ...
    @staticmethod
    def setProperty(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...

class SignatureSpi:
    def __init__(self): ...
    def clone(self) -> typing.Any: ...

class SignedObject(java.io.Serializable):
    def __init__(
        self,
        serializable: java.io.Serializable,
        privateKey: PrivateKey,
        signature: Signature,
    ): ...
    def getAlgorithm(self) -> java.lang.String: ...
    def getObject(self) -> typing.Any: ...
    def getSignature(self) -> typing.MutableSequence[int]: ...
    def verify(self, publicKey: PublicKey, signature: Signature) -> bool: ...

class Timestamp(java.io.Serializable):
    def __init__(self, date: java.util.Date, certPath: java.security.cert.CertPath): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getSignerCertPath(self) -> java.security.cert.CertPath: ...
    def getTimestamp(self) -> java.util.Date: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class AsymmetricKey(Key, DEREncodable):
    def getParams(self) -> java.security.spec.AlgorithmParameterSpec: ...

class AuthProvider(Provider):
    def login(
        self,
        subject: javax.security.auth.Subject,
        callbackHandler: javax.security.auth.callback.CallbackHandler | typing.Callable,
    ) -> None: ...
    def logout(self) -> None: ...
    def setCallbackHandler(
        self,
        callbackHandler: javax.security.auth.callback.CallbackHandler | typing.Callable,
    ) -> None: ...

class DigestException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class DrbgParameters:
    @staticmethod
    def instantiation(
        int: int,
        capability: DrbgParameters.Capability,
        byteArray: list[int] | jpype.JArray | bytes,
    ) -> DrbgParameters.Instantiation: ...
    @staticmethod
    def nextBytes(
        int: int, boolean: bool, byteArray: list[int] | jpype.JArray | bytes
    ) -> DrbgParameters.NextBytes: ...
    @staticmethod
    def reseed(
        boolean: bool, byteArray: list[int] | jpype.JArray | bytes
    ) -> DrbgParameters.Reseed: ...
    class Capability(java.lang.Enum["DrbgParameters.Capability"]):
        PR_AND_RESEED: typing.ClassVar[DrbgParameters.Capability] = ...
        RESEED_ONLY: typing.ClassVar[DrbgParameters.Capability] = ...
        NONE: typing.ClassVar[DrbgParameters.Capability] = ...
        def supportsPredictionResistance(self) -> bool: ...
        def supportsReseeding(self) -> bool: ...
        def toString(self) -> java.lang.String: ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> DrbgParameters.Capability: ...
        @staticmethod
        def values() -> typing.MutableSequence[DrbgParameters.Capability]: ...

    class Instantiation(SecureRandomParameters):
        def getCapability(self) -> DrbgParameters.Capability: ...
        def getPersonalizationString(self) -> typing.MutableSequence[int]: ...
        def getStrength(self) -> int: ...
        def toString(self) -> java.lang.String: ...

    class NextBytes(SecureRandomParameters):
        def getAdditionalInput(self) -> typing.MutableSequence[int]: ...
        def getPredictionResistance(self) -> bool: ...
        def getStrength(self) -> int: ...

    class Reseed(SecureRandomParameters):
        def getAdditionalInput(self) -> typing.MutableSequence[int]: ...
        def getPredictionResistance(self) -> bool: ...

class Identity(Principal, java.io.Serializable):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, identityScope: IdentityScope
    ): ...
    def addCertificate(self, certificate: Certificate) -> None: ...
    def certificates(self) -> typing.MutableSequence[Certificate]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getInfo(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getPublicKey(self) -> PublicKey: ...
    def getScope(self) -> IdentityScope: ...
    def hashCode(self) -> int: ...
    def removeCertificate(self, certificate: Certificate) -> None: ...
    def setInfo(self, string: java.lang.String | str) -> None: ...
    def setPublicKey(self, publicKey: PublicKey) -> None: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def toString(self, boolean: bool) -> java.lang.String: ...

class InvalidAlgorithmParameterException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class KeyException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class KeyPair(java.io.Serializable, DEREncodable):
    def __init__(self, publicKey: PublicKey, privateKey: PrivateKey): ...
    def getPrivate(self) -> PrivateKey: ...
    def getPublic(self) -> PublicKey: ...

class KeyPairGenerator(KeyPairGeneratorSpi):
    def genKeyPair(self) -> KeyPair: ...
    def generateKeyPair(self) -> KeyPair: ...
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> KeyPairGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> KeyPairGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> KeyPairGenerator: ...
    def getProvider(self) -> Provider: ...
    @typing.overload
    def initialize(self, int: int) -> None: ...
    @typing.overload
    def initialize(self, int: int, secureRandom: SecureRandom) -> None: ...
    @typing.overload
    def initialize(
        self, algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec
    ) -> None: ...
    @typing.overload
    def initialize(
        self,
        algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec,
        secureRandom: SecureRandom,
    ) -> None: ...

class KeyStoreException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class MessageDigest(MessageDigestSpi):
    def clone(self) -> typing.Any: ...
    @typing.overload
    def digest(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def digest(
        self, byteArray: list[int] | jpype.JArray | bytes
    ) -> typing.MutableSequence[int]: ...
    @typing.overload
    def digest(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    def getAlgorithm(self) -> java.lang.String: ...
    def getDigestLength(self) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> MessageDigest: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> MessageDigest: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> MessageDigest: ...
    def getProvider(self) -> Provider: ...
    @staticmethod
    def isEqual(
        byteArray: list[int] | jpype.JArray | bytes,
        byteArray2: list[int] | jpype.JArray | bytes,
    ) -> bool: ...
    def reset(self) -> None: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def update(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def update(self, byte: int) -> None: ...
    @typing.overload
    def update(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def update(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...

class NoSuchAlgorithmException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class NoSuchProviderException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class PEMRecord(java.lang.Record, DEREncodable):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        type: java.lang.String | str,
        content: java.lang.String | str,
        leadingData: list[int] | jpype.JArray | bytes,
    ): ...
    def content(self) -> java.lang.String: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def leadingData(self) -> typing.MutableSequence[int]: ...
    def toString(self) -> java.lang.String: ...
    def type(self) -> java.lang.String: ...

class Permission(Guard, java.io.Serializable):
    def __init__(self, string: java.lang.String | str): ...
    def checkGuard(self, object: typing.Any) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: Permission) -> bool: ...
    def newPermissionCollection(self) -> PermissionCollection: ...
    def toString(self) -> java.lang.String: ...

class Permissions(PermissionCollection, java.io.Serializable):
    def __init__(self): ...
    def add(self, permission: Permission) -> None: ...
    def elements(self) -> java.util.Enumeration[Permission]: ...
    def implies(self, permission: Permission) -> bool: ...

class Signature(SignatureSpi):
    def clone(self) -> typing.Any: ...
    def getAlgorithm(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> Signature: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> Signature: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, provider: Provider
    ) -> Signature: ...
    def getParameter(self, string: java.lang.String | str) -> typing.Any: ...
    def getParameters(self) -> AlgorithmParameters: ...
    def getProvider(self) -> Provider: ...
    @typing.overload
    def initSign(self, privateKey: PrivateKey) -> None: ...
    @typing.overload
    def initSign(self, privateKey: PrivateKey, secureRandom: SecureRandom) -> None: ...
    @typing.overload
    def initVerify(self, publicKey: PublicKey) -> None: ...
    @typing.overload
    def initVerify(self, certificate: java.security.cert.Certificate) -> None: ...
    @typing.overload
    def setParameter(
        self, string: java.lang.String | str, object: typing.Any
    ) -> None: ...
    @typing.overload
    def setParameter(
        self, algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec
    ) -> None: ...
    @typing.overload
    def sign(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    def sign(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def update(self, byte: int) -> None: ...
    @typing.overload
    def update(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def update(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def update(self, byteBuffer: java.nio.ByteBuffer) -> None: ...
    @typing.overload
    def verify(self, byteArray: list[int] | jpype.JArray | bytes) -> bool: ...
    @typing.overload
    def verify(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> bool: ...

class SignatureException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class URIParameter(
    Policy.Parameters, javax.security.auth.login.Configuration.Parameters
):
    def __init__(self, uRI: java.net.URI): ...
    def getURI(self) -> java.net.URI: ...

class UnrecoverableEntryException(GeneralSecurityException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class AllPermission(Permission):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: Permission) -> bool: ...
    def newPermissionCollection(self) -> PermissionCollection: ...

class BasicPermission(Permission, java.io.Serializable):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: Permission) -> bool: ...
    def newPermissionCollection(self) -> PermissionCollection: ...

class IdentityScope(Identity):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, identityScope: IdentityScope
    ): ...
    def addIdentity(self, identity: Identity) -> None: ...
    @typing.overload
    def getIdentity(self, string: java.lang.String | str) -> Identity: ...
    @typing.overload
    def getIdentity(self, publicKey: PublicKey) -> Identity: ...
    @typing.overload
    def getIdentity(self, principal: Principal | typing.Callable) -> Identity: ...
    @staticmethod
    def getSystemScope() -> IdentityScope: ...
    def identities(self) -> java.util.Enumeration[Identity]: ...
    def removeIdentity(self, identity: Identity) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def toString(self, boolean: bool) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...

class InvalidKeyException(KeyException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class KeyManagementException(KeyException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class PrivateKey(AsymmetricKey, javax.security.auth.Destroyable):
    serialVersionUID: typing.ClassVar[int] = ...

class PublicKey(AsymmetricKey):
    serialVersionUID: typing.ClassVar[int] = ...

class Signer(Identity):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, identityScope: IdentityScope
    ): ...
    def getPrivateKey(self) -> PrivateKey: ...
    def setKeyPair(self, keyPair: KeyPair) -> None: ...
    @typing.overload
    def toString(self, boolean: bool) -> java.lang.String: ...
    @typing.overload
    def toString(self) -> java.lang.String: ...

class UnrecoverableKeyException(UnrecoverableEntryException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class UnresolvedPermission(Permission, java.io.Serializable):
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def getUnresolvedActions(self) -> java.lang.String: ...
    def getUnresolvedCerts(
        self,
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def getUnresolvedName(self) -> java.lang.String: ...
    def getUnresolvedType(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: Permission) -> bool: ...
    def newPermissionCollection(self) -> PermissionCollection: ...
    def toString(self) -> java.lang.String: ...

class SecurityPermission(BasicPermission):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...

class DomainLoadStoreParameter(java.security.KeyStore.LoadStoreParameter):
    def __init__(
        self,
        uRI: java.net.URI,
        map: java.util.Map[java.lang.String | str, KeyStore.ProtectionParameter]
        | typing.Mapping[java.lang.String | str, KeyStore.ProtectionParameter],
    ): ...
    def getConfiguration(self) -> java.net.URI: ...
    def getProtectionParameter(self) -> KeyStore.ProtectionParameter: ...
    def getProtectionParams(
        self,
    ) -> java.util.Map[java.lang.String, KeyStore.ProtectionParameter]: ...

class KeyStore:
    def aliases(self) -> java.util.Enumeration[java.lang.String]: ...
    def containsAlias(self, string: java.lang.String | str) -> bool: ...
    def deleteEntry(self, string: java.lang.String | str) -> None: ...
    def entryInstanceOf(
        self, string: java.lang.String | str, class_: type[KeyStore.Entry]
    ) -> bool: ...
    def getAttributes(
        self, string: java.lang.String | str
    ) -> java.util.Set[KeyStore.Entry.Attribute]: ...
    def getCertificate(
        self, string: java.lang.String | str
    ) -> java.security.cert.Certificate: ...
    def getCertificateAlias(
        self, certificate: java.security.cert.Certificate
    ) -> java.lang.String: ...
    def getCertificateChain(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def getCreationDate(self, string: java.lang.String | str) -> java.util.Date: ...
    @staticmethod
    def getDefaultType() -> java.lang.String: ...
    def getEntry(
        self,
        string: java.lang.String | str,
        protectionParameter: KeyStore.ProtectionParameter,
    ) -> KeyStore.Entry: ...
    @typing.overload
    @staticmethod
    def getInstance(
        file: java.io.File | jpype.protocol.SupportsPath,
        charArray: list[str] | jpype.JArray,
    ) -> KeyStore: ...
    @typing.overload
    @staticmethod
    def getInstance(
        file: java.io.File | jpype.protocol.SupportsPath,
        loadStoreParameter: KeyStore.LoadStoreParameter | typing.Callable,
    ) -> KeyStore: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str) -> KeyStore: ...
    @typing.overload
    @staticmethod
    def getInstance(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> KeyStore: ...
    @typing.overload
    @staticmethod
    def getInstance(string: java.lang.String | str, provider: Provider) -> KeyStore: ...
    def getKey(
        self, string: java.lang.String | str, charArray: list[str] | jpype.JArray
    ) -> Key: ...
    def getProvider(self) -> Provider: ...
    def getType(self) -> java.lang.String: ...
    def isCertificateEntry(self, string: java.lang.String | str) -> bool: ...
    def isKeyEntry(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def load(
        self, inputStream: java.io.InputStream, charArray: list[str] | jpype.JArray
    ) -> None: ...
    @typing.overload
    def load(
        self, loadStoreParameter: KeyStore.LoadStoreParameter | typing.Callable
    ) -> None: ...
    def setCertificateEntry(
        self,
        string: java.lang.String | str,
        certificate: java.security.cert.Certificate,
    ) -> None: ...
    def setEntry(
        self,
        string: java.lang.String | str,
        entry: KeyStore.Entry,
        protectionParameter: KeyStore.ProtectionParameter,
    ) -> None: ...
    @typing.overload
    def setKeyEntry(
        self,
        string: java.lang.String | str,
        byteArray: list[int] | jpype.JArray | bytes,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ) -> None: ...
    @typing.overload
    def setKeyEntry(
        self,
        string: java.lang.String | str,
        key: Key,
        charArray: list[str] | jpype.JArray,
        certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
    ) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def store(
        self, outputStream: java.io.OutputStream, charArray: list[str] | jpype.JArray
    ) -> None: ...
    @typing.overload
    def store(
        self, loadStoreParameter: KeyStore.LoadStoreParameter | typing.Callable
    ) -> None: ...
    class Builder:
        def getKeyStore(self) -> KeyStore: ...
        def getProtectionParameter(
            self, string: java.lang.String | str
        ) -> KeyStore.ProtectionParameter: ...
        @typing.overload
        @staticmethod
        def newInstance(
            file: java.io.File | jpype.protocol.SupportsPath,
            protectionParameter: KeyStore.ProtectionParameter,
        ) -> KeyStore.Builder: ...
        @typing.overload
        @staticmethod
        def newInstance(
            string: java.lang.String | str,
            provider: Provider,
            file: java.io.File | jpype.protocol.SupportsPath,
            protectionParameter: KeyStore.ProtectionParameter,
        ) -> KeyStore.Builder: ...
        @typing.overload
        @staticmethod
        def newInstance(
            string: java.lang.String | str,
            provider: Provider,
            protectionParameter: KeyStore.ProtectionParameter,
        ) -> KeyStore.Builder: ...
        @typing.overload
        @staticmethod
        def newInstance(
            keyStore: KeyStore, protectionParameter: KeyStore.ProtectionParameter
        ) -> KeyStore.Builder: ...

    class CallbackHandlerProtection(java.security.KeyStore.ProtectionParameter):
        def __init__(
            self,
            callbackHandler: javax.security.auth.callback.CallbackHandler
            | typing.Callable,
        ): ...
        def getCallbackHandler(
            self,
        ) -> javax.security.auth.callback.CallbackHandler: ...

    class Entry:
        def getAttributes(self) -> java.util.Set[KeyStore.Entry.Attribute]: ...
        class Attribute:
            def getName(self) -> java.lang.String: ...
            def getValue(self) -> java.lang.String: ...

    class LoadStoreParameter:
        def getProtectionParameter(self) -> KeyStore.ProtectionParameter: ...

    class PasswordProtection(
        java.security.KeyStore.ProtectionParameter, javax.security.auth.Destroyable
    ):
        @typing.overload
        def __init__(self, charArray: list[str] | jpype.JArray): ...
        @typing.overload
        def __init__(
            self,
            charArray: list[str] | jpype.JArray,
            string: java.lang.String | str,
            algorithmParameterSpec: java.security.spec.AlgorithmParameterSpec,
        ): ...
        def destroy(self) -> None: ...
        def getPassword(self) -> typing.MutableSequence[str]: ...
        def getProtectionAlgorithm(self) -> java.lang.String: ...
        def getProtectionParameters(
            self,
        ) -> java.security.spec.AlgorithmParameterSpec: ...
        def isDestroyed(self) -> bool: ...

    class PrivateKeyEntry(java.security.KeyStore.Entry):
        @typing.overload
        def __init__(
            self,
            privateKey: PrivateKey,
            certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
        ): ...
        @typing.overload
        def __init__(
            self,
            privateKey: PrivateKey,
            certificateArray: list[java.security.cert.Certificate] | jpype.JArray,
            set: java.util.Set[KeyStore.Entry.Attribute],
        ): ...
        def getAttributes(self) -> java.util.Set[KeyStore.Entry.Attribute]: ...
        def getCertificate(self) -> java.security.cert.Certificate: ...
        def getCertificateChain(
            self,
        ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
        def getPrivateKey(self) -> PrivateKey: ...
        def toString(self) -> java.lang.String: ...

    class ProtectionParameter: ...

    class SecretKeyEntry(java.security.KeyStore.Entry):
        @typing.overload
        def __init__(self, secretKey: javax.crypto.SecretKey): ...
        @typing.overload
        def __init__(
            self,
            secretKey: javax.crypto.SecretKey,
            set: java.util.Set[KeyStore.Entry.Attribute],
        ): ...
        def getAttributes(self) -> java.util.Set[KeyStore.Entry.Attribute]: ...
        def getSecretKey(self) -> javax.crypto.SecretKey: ...
        def toString(self) -> java.lang.String: ...

    class TrustedCertificateEntry(java.security.KeyStore.Entry):
        @typing.overload
        def __init__(self, certificate: java.security.cert.Certificate): ...
        @typing.overload
        def __init__(
            self,
            certificate: java.security.cert.Certificate,
            set: java.util.Set[KeyStore.Entry.Attribute],
        ): ...
        def getAttributes(self) -> java.util.Set[KeyStore.Entry.Attribute]: ...
        def getTrustedCertificate(self) -> java.security.cert.Certificate: ...
        def toString(self) -> java.lang.String: ...

class PKCS12Attribute(KeyStore.Entry.Attribute):
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getEncoded(self) -> typing.MutableSequence[int]: ...
    def getName(self) -> java.lang.String: ...
    def getValue(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.security")``.

    AccessControlContext: type[AccessControlContext]
    AccessControlException: type[AccessControlException]
    AccessController: type[AccessController]
    AlgorithmConstraints: type[AlgorithmConstraints]
    AlgorithmParameterGenerator: type[AlgorithmParameterGenerator]
    AlgorithmParameterGeneratorSpi: type[AlgorithmParameterGeneratorSpi]
    AlgorithmParameters: type[AlgorithmParameters]
    AlgorithmParametersSpi: type[AlgorithmParametersSpi]
    AllPermission: type[AllPermission]
    AsymmetricKey: type[AsymmetricKey]
    AuthProvider: type[AuthProvider]
    BasicPermission: type[BasicPermission]
    Certificate: type[Certificate]
    CodeSigner: type[CodeSigner]
    CodeSource: type[CodeSource]
    CryptoPrimitive: type[CryptoPrimitive]
    DEREncodable: type[DEREncodable]
    DigestException: type[DigestException]
    DigestInputStream: type[DigestInputStream]
    DigestOutputStream: type[DigestOutputStream]
    DomainCombiner: type[DomainCombiner]
    DomainLoadStoreParameter: type[DomainLoadStoreParameter]
    DrbgParameters: type[DrbgParameters]
    GeneralSecurityException: type[GeneralSecurityException]
    Guard: type[Guard]
    GuardedObject: type[GuardedObject]
    Identity: type[Identity]
    IdentityScope: type[IdentityScope]
    InvalidAlgorithmParameterException: type[InvalidAlgorithmParameterException]
    InvalidKeyException: type[InvalidKeyException]
    InvalidParameterException: type[InvalidParameterException]
    Key: type[Key]
    KeyException: type[KeyException]
    KeyFactory: type[KeyFactory]
    KeyFactorySpi: type[KeyFactorySpi]
    KeyManagementException: type[KeyManagementException]
    KeyPair: type[KeyPair]
    KeyPairGenerator: type[KeyPairGenerator]
    KeyPairGeneratorSpi: type[KeyPairGeneratorSpi]
    KeyRep: type[KeyRep]
    KeyStore: type[KeyStore]
    KeyStoreException: type[KeyStoreException]
    KeyStoreSpi: type[KeyStoreSpi]
    MessageDigest: type[MessageDigest]
    MessageDigestSpi: type[MessageDigestSpi]
    NoSuchAlgorithmException: type[NoSuchAlgorithmException]
    NoSuchProviderException: type[NoSuchProviderException]
    PEMDecoder: type[PEMDecoder]
    PEMEncoder: type[PEMEncoder]
    PEMRecord: type[PEMRecord]
    PKCS12Attribute: type[PKCS12Attribute]
    Permission: type[Permission]
    PermissionCollection: type[PermissionCollection]
    Permissions: type[Permissions]
    Policy: type[Policy]
    PolicySpi: type[PolicySpi]
    Principal: type[Principal]
    PrivateKey: type[PrivateKey]
    PrivilegedAction: type[PrivilegedAction]
    PrivilegedActionException: type[PrivilegedActionException]
    PrivilegedExceptionAction: type[PrivilegedExceptionAction]
    ProtectionDomain: type[ProtectionDomain]
    Provider: type[Provider]
    ProviderException: type[ProviderException]
    PublicKey: type[PublicKey]
    SecureClassLoader: type[SecureClassLoader]
    SecureRandom: type[SecureRandom]
    SecureRandomParameters: type[SecureRandomParameters]
    SecureRandomSpi: type[SecureRandomSpi]
    Security: type[Security]
    SecurityPermission: type[SecurityPermission]
    Signature: type[Signature]
    SignatureException: type[SignatureException]
    SignatureSpi: type[SignatureSpi]
    SignedObject: type[SignedObject]
    Signer: type[Signer]
    Timestamp: type[Timestamp]
    URIParameter: type[URIParameter]
    UnrecoverableEntryException: type[UnrecoverableEntryException]
    UnrecoverableKeyException: type[UnrecoverableKeyException]
    UnresolvedPermission: type[UnresolvedPermission]
    cert: java.security.cert.__module_protocol__
    interfaces: java.security.interfaces.__module_protocol__
    spec: java.security.spec.__module_protocol__
