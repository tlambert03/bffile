import typing
from typing import Protocol

import java.io
import java.lang
import java.math
import java.text.spi
import java.util
import jpype

class Annotation:
    def __init__(self, object: typing.Any): ...
    def getValue(self) -> typing.Any: ...
    def toString(self) -> java.lang.String: ...

class AttributedString:
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        map: java.util.Map[AttributedCharacterIterator.Attribute, typing.Any]
        | typing.Mapping[AttributedCharacterIterator.Attribute, typing.Any],
    ): ...
    @typing.overload
    def __init__(self, attributedCharacterIterator: AttributedCharacterIterator): ...
    @typing.overload
    def __init__(
        self,
        attributedCharacterIterator: AttributedCharacterIterator,
        int: int,
        int2: int,
    ): ...
    @typing.overload
    def __init__(
        self,
        attributedCharacterIterator: AttributedCharacterIterator,
        int: int,
        int2: int,
        attributeArray: list[AttributedCharacterIterator.Attribute] | jpype.JArray,
    ): ...
    @typing.overload
    def addAttribute(
        self, attribute: AttributedCharacterIterator.Attribute, object: typing.Any
    ) -> None: ...
    @typing.overload
    def addAttribute(
        self,
        attribute: AttributedCharacterIterator.Attribute,
        object: typing.Any,
        int: int,
        int2: int,
    ) -> None: ...
    def addAttributes(
        self,
        map: java.util.Map[AttributedCharacterIterator.Attribute, typing.Any]
        | typing.Mapping[AttributedCharacterIterator.Attribute, typing.Any],
        int: int,
        int2: int,
    ) -> None: ...
    @typing.overload
    def getIterator(self) -> AttributedCharacterIterator: ...
    @typing.overload
    def getIterator(
        self, attributeArray: list[AttributedCharacterIterator.Attribute] | jpype.JArray
    ) -> AttributedCharacterIterator: ...
    @typing.overload
    def getIterator(
        self,
        attributeArray: list[AttributedCharacterIterator.Attribute] | jpype.JArray,
        int: int,
        int2: int,
    ) -> AttributedCharacterIterator: ...

class Bidi:
    DIRECTION_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DIRECTION_DEFAULT_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_DEFAULT_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(
        self,
        charArray: list[str] | jpype.JArray,
        int: int,
        byteArray: list[int] | jpype.JArray | bytes,
        int2: int,
        int3: int,
        int4: int,
    ): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(self, attributedCharacterIterator: AttributedCharacterIterator): ...
    def baseIsLeftToRight(self) -> bool: ...
    def createLineBidi(self, int: int, int2: int) -> Bidi: ...
    def getBaseLevel(self) -> int: ...
    def getLength(self) -> int: ...
    def getLevelAt(self, int: int) -> int: ...
    def getRunCount(self) -> int: ...
    def getRunLevel(self, int: int) -> int: ...
    def getRunLimit(self, int: int) -> int: ...
    def getRunStart(self, int: int) -> int: ...
    def isLeftToRight(self) -> bool: ...
    def isMixed(self) -> bool: ...
    def isRightToLeft(self) -> bool: ...
    @staticmethod
    def reorderVisually(
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        objectArray: list[typing.Any] | jpype.JArray,
        int2: int,
        int3: int,
    ) -> None: ...
    @staticmethod
    def requiresBidi(
        charArray: list[str] | jpype.JArray, int: int, int2: int
    ) -> bool: ...
    def toString(self) -> java.lang.String: ...

class BreakIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[int] = ...
    def clone(self) -> typing.Any: ...
    def current(self) -> int: ...
    def first(self) -> int: ...
    def following(self, int: int) -> int: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance(locale: java.util.Locale) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance(locale: java.util.Locale) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance(locale: java.util.Locale) -> BreakIterator: ...
    def getText(self) -> CharacterIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance(locale: java.util.Locale) -> BreakIterator: ...
    def isBoundary(self, int: int) -> bool: ...
    def last(self) -> int: ...
    @typing.overload
    def next(self) -> int: ...
    @typing.overload
    def next(self, int: int) -> int: ...
    def preceding(self, int: int) -> int: ...
    def previous(self) -> int: ...
    @typing.overload
    def setText(self, characterIterator: CharacterIterator) -> None: ...
    @typing.overload
    def setText(self, string: java.lang.String | str) -> None: ...

class CharacterIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[str] = ...
    def clone(self) -> typing.Any: ...
    def current(self) -> str: ...
    def first(self) -> str: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def last(self) -> str: ...
    def next(self) -> str: ...
    def previous(self) -> str: ...
    def setIndex(self, int: int) -> str: ...

class CollationElementIterator:
    NULLORDER: typing.ClassVar[int] = ...
    def getMaxExpansion(self, int: int) -> int: ...
    def getOffset(self) -> int: ...
    def next(self) -> int: ...
    def previous(self) -> int: ...
    @staticmethod
    def primaryOrder(int: int) -> int: ...
    def reset(self) -> None: ...
    @staticmethod
    def secondaryOrder(int: int) -> int: ...
    def setOffset(self, int: int) -> None: ...
    @typing.overload
    def setText(self, string: java.lang.String | str) -> None: ...
    @typing.overload
    def setText(self, characterIterator: CharacterIterator) -> None: ...
    @staticmethod
    def tertiaryOrder(int: int) -> int: ...

class CollationKey(java.lang.Comparable["CollationKey"]):
    def compareTo(self, collationKey: CollationKey) -> int: ...
    def getSourceString(self) -> java.lang.String: ...
    def toByteArray(self) -> typing.MutableSequence[int]: ...

class Collator(java.util.Comparator[typing.Any], java.lang.Cloneable):
    PRIMARY: typing.ClassVar[int] = ...
    SECONDARY: typing.ClassVar[int] = ...
    TERTIARY: typing.ClassVar[int] = ...
    IDENTICAL: typing.ClassVar[int] = ...
    NO_DECOMPOSITION: typing.ClassVar[int] = ...
    CANONICAL_DECOMPOSITION: typing.ClassVar[int] = ...
    FULL_DECOMPOSITION: typing.ClassVar[int] = ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compare(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> int: ...
    @typing.overload
    def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    def getCollationKey(self, string: java.lang.String | str) -> CollationKey: ...
    def getDecomposition(self) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale) -> Collator: ...
    @typing.overload
    @staticmethod
    def getInstance() -> Collator: ...
    def getStrength(self) -> int: ...
    def hashCode(self) -> int: ...
    def setDecomposition(self, int: int) -> None: ...
    def setStrength(self, int: int) -> None: ...

class DateFormatSymbols(java.io.Serializable, java.lang.Cloneable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, locale: java.util.Locale): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAmPmStrings(self) -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    def getEras(self) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DateFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale) -> DateFormatSymbols: ...
    def getLocalPatternChars(self) -> java.lang.String: ...
    def getMonths(self) -> typing.MutableSequence[java.lang.String]: ...
    def getShortMonths(self) -> typing.MutableSequence[java.lang.String]: ...
    def getShortWeekdays(self) -> typing.MutableSequence[java.lang.String]: ...
    def getWeekdays(self) -> typing.MutableSequence[java.lang.String]: ...
    def getZoneStrings(
        self,
    ) -> typing.MutableSequence[typing.MutableSequence[java.lang.String]]: ...
    def hashCode(self) -> int: ...
    def setAmPmStrings(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> None: ...
    def setEras(self, stringArray: list[java.lang.String] | jpype.JArray) -> None: ...
    def setLocalPatternChars(self, string: java.lang.String | str) -> None: ...
    def setMonths(self, stringArray: list[java.lang.String] | jpype.JArray) -> None: ...
    def setShortMonths(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> None: ...
    def setShortWeekdays(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> None: ...
    def setWeekdays(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> None: ...
    def setZoneStrings(
        self, stringArray: list[typing.MutableSequence[java.lang.String]] | jpype.JArray
    ) -> None: ...

class DecimalFormatSymbols(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, locale: java.util.Locale): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    def getCurrency(self) -> java.util.Currency: ...
    def getCurrencySymbol(self) -> java.lang.String: ...
    def getDecimalSeparator(self) -> str: ...
    def getDigit(self) -> str: ...
    def getExponentSeparator(self) -> java.lang.String: ...
    def getGroupingSeparator(self) -> str: ...
    def getInfinity(self) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DecimalFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale) -> DecimalFormatSymbols: ...
    def getInternationalCurrencySymbol(self) -> java.lang.String: ...
    def getLocale(self) -> java.util.Locale: ...
    def getMinusSign(self) -> str: ...
    def getMonetaryDecimalSeparator(self) -> str: ...
    def getMonetaryGroupingSeparator(self) -> str: ...
    def getNaN(self) -> java.lang.String: ...
    def getPatternSeparator(self) -> str: ...
    def getPerMill(self) -> str: ...
    def getPercent(self) -> str: ...
    def getZeroDigit(self) -> str: ...
    def hashCode(self) -> int: ...
    def setCurrency(self, currency: java.util.Currency) -> None: ...
    def setCurrencySymbol(self, string: java.lang.String | str) -> None: ...
    def setDecimalSeparator(self, char: str) -> None: ...
    def setDigit(self, char: str) -> None: ...
    def setExponentSeparator(self, string: java.lang.String | str) -> None: ...
    def setGroupingSeparator(self, char: str) -> None: ...
    def setInfinity(self, string: java.lang.String | str) -> None: ...
    def setInternationalCurrencySymbol(
        self, string: java.lang.String | str
    ) -> None: ...
    def setMinusSign(self, char: str) -> None: ...
    def setMonetaryDecimalSeparator(self, char: str) -> None: ...
    def setMonetaryGroupingSeparator(self, char: str) -> None: ...
    def setNaN(self, string: java.lang.String | str) -> None: ...
    def setPatternSeparator(self, char: str) -> None: ...
    def setPerMill(self, char: str) -> None: ...
    def setPercent(self, char: str) -> None: ...
    def setZeroDigit(self, char: str) -> None: ...

class FieldPosition:
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, field: Format.Field): ...
    @typing.overload
    def __init__(self, field: Format.Field, int: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getField(self) -> int: ...
    def getFieldAttribute(self) -> Format.Field: ...
    def hashCode(self) -> int: ...
    def setBeginIndex(self, int: int) -> None: ...
    def setEndIndex(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class Normalizer:
    @staticmethod
    def isNormalized(
        charSequence: java.lang.CharSequence | str, form: Normalizer.Form
    ) -> bool: ...
    @staticmethod
    def normalize(
        charSequence: java.lang.CharSequence | str, form: Normalizer.Form
    ) -> java.lang.String: ...
    class Form(java.lang.Enum["Normalizer.Form"]):
        NFD: typing.ClassVar[Normalizer.Form] = ...
        NFC: typing.ClassVar[Normalizer.Form] = ...
        NFKD: typing.ClassVar[Normalizer.Form] = ...
        NFKC: typing.ClassVar[Normalizer.Form] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> Normalizer.Form: ...
        @staticmethod
        def values() -> typing.MutableSequence[Normalizer.Form]: ...

class ParseException(java.lang.Exception):
    def __init__(self, string: java.lang.String | str, int: int): ...
    def getErrorOffset(self) -> int: ...

class ParsePosition:
    def __init__(self, int: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getErrorIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def setErrorIndex(self, int: int) -> None: ...
    def setIndex(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class AttributedCharacterIterator(CharacterIterator):
    def getAllAttributeKeys(
        self,
    ) -> java.util.Set[AttributedCharacterIterator.Attribute]: ...
    def getAttribute(
        self, attribute: AttributedCharacterIterator.Attribute
    ) -> typing.Any: ...
    def getAttributes(
        self,
    ) -> java.util.Map[AttributedCharacterIterator.Attribute, typing.Any]: ...
    @typing.overload
    def getRunLimit(self) -> int: ...
    @typing.overload
    def getRunLimit(self, attribute: AttributedCharacterIterator.Attribute) -> int: ...
    @typing.overload
    def getRunLimit(
        self, set: java.util.Set[AttributedCharacterIterator.Attribute]
    ) -> int: ...
    @typing.overload
    def getRunStart(self) -> int: ...
    @typing.overload
    def getRunStart(self, attribute: AttributedCharacterIterator.Attribute) -> int: ...
    @typing.overload
    def getRunStart(
        self, set: java.util.Set[AttributedCharacterIterator.Attribute]
    ) -> int: ...
    class Attribute(java.io.Serializable):
        LANGUAGE: typing.ClassVar[AttributedCharacterIterator.Attribute] = ...
        READING: typing.ClassVar[AttributedCharacterIterator.Attribute] = ...
        INPUT_METHOD_SEGMENT: typing.ClassVar[
            AttributedCharacterIterator.Attribute
        ] = ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...

class RuleBasedCollator(Collator):
    def __init__(self, string: java.lang.String | str): ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def compare(self, object: typing.Any, object2: typing.Any) -> int: ...
    @typing.overload
    def compare(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> int: ...
    @typing.overload
    def equals(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def getCollationElementIterator(
        self, string: java.lang.String | str
    ) -> CollationElementIterator: ...
    @typing.overload
    def getCollationElementIterator(
        self, characterIterator: CharacterIterator
    ) -> CollationElementIterator: ...
    def getCollationKey(self, string: java.lang.String | str) -> CollationKey: ...
    def getRules(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...

class StringCharacterIterator(CharacterIterator):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, int: int, int2: int, int3: int
    ): ...
    def clone(self) -> typing.Any: ...
    def current(self) -> str: ...
    def equals(self, object: typing.Any) -> bool: ...
    def first(self) -> str: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def last(self) -> str: ...
    def next(self) -> str: ...
    def previous(self) -> str: ...
    def setIndex(self, int: int) -> str: ...
    def setText(self, string: java.lang.String | str) -> None: ...

class Format(java.io.Serializable, java.lang.Cloneable):
    def clone(self) -> typing.Any: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    @typing.overload
    def parseObject(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.Any: ...
    @typing.overload
    def parseObject(self, string: java.lang.String | str) -> typing.Any: ...
    class Field(AttributedCharacterIterator.Attribute): ...

class DateFormat(Format):
    ERA_FIELD: typing.ClassVar[int] = ...
    YEAR_FIELD: typing.ClassVar[int] = ...
    MONTH_FIELD: typing.ClassVar[int] = ...
    DATE_FIELD: typing.ClassVar[int] = ...
    HOUR_OF_DAY1_FIELD: typing.ClassVar[int] = ...
    HOUR_OF_DAY0_FIELD: typing.ClassVar[int] = ...
    MINUTE_FIELD: typing.ClassVar[int] = ...
    SECOND_FIELD: typing.ClassVar[int] = ...
    MILLISECOND_FIELD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_FIELD: typing.ClassVar[int] = ...
    DAY_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH_FIELD: typing.ClassVar[int] = ...
    WEEK_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    WEEK_OF_MONTH_FIELD: typing.ClassVar[int] = ...
    AM_PM_FIELD: typing.ClassVar[int] = ...
    HOUR1_FIELD: typing.ClassVar[int] = ...
    HOUR0_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_FIELD: typing.ClassVar[int] = ...
    FULL: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    MEDIUM: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar[int] = ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(
        self,
        date: java.util.Date,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, date: java.util.Date) -> java.lang.String: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    def getCalendar(self) -> java.util.Calendar: ...
    @typing.overload
    @staticmethod
    def getDateInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(int: int) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(int: int, locale: java.util.Locale) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(int: int, int2: int) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(
        int: int, int2: int, locale: java.util.Locale
    ) -> DateFormat: ...
    @staticmethod
    def getInstance() -> DateFormat: ...
    def getNumberFormat(self) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(int: int) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(int: int, locale: java.util.Locale) -> DateFormat: ...
    def getTimeZone(self) -> java.util.TimeZone: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.util.Date: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.util.Date: ...
    @typing.overload
    def parseObject(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.Any: ...
    @typing.overload
    def parseObject(self, string: java.lang.String | str) -> typing.Any: ...
    def setCalendar(self, calendar: java.util.Calendar) -> None: ...
    def setLenient(self, boolean: bool) -> None: ...
    def setNumberFormat(self, numberFormat: NumberFormat) -> None: ...
    def setTimeZone(self, timeZone: java.util.TimeZone) -> None: ...
    class Field(Format.Field):
        ERA: typing.ClassVar[DateFormat.Field] = ...
        YEAR: typing.ClassVar[DateFormat.Field] = ...
        MONTH: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY1: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY0: typing.ClassVar[DateFormat.Field] = ...
        MINUTE: typing.ClassVar[DateFormat.Field] = ...
        SECOND: typing.ClassVar[DateFormat.Field] = ...
        MILLISECOND: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK_IN_MONTH: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        AM_PM: typing.ClassVar[DateFormat.Field] = ...
        HOUR1: typing.ClassVar[DateFormat.Field] = ...
        HOUR0: typing.ClassVar[DateFormat.Field] = ...
        TIME_ZONE: typing.ClassVar[DateFormat.Field] = ...
        def getCalendarField(self) -> int: ...
        @staticmethod
        def ofCalendarField(int: int) -> DateFormat.Field: ...

class ListFormat(Format):
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(
        self, list: java.util.List[java.lang.String | str]
    ) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getInstance() -> ListFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> ListFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(
        locale: java.util.Locale, type: ListFormat.Type, style: ListFormat.Style
    ) -> ListFormat: ...
    def getLocale(self) -> java.util.Locale: ...
    def getPatterns(self) -> typing.MutableSequence[java.lang.String]: ...
    def hashCode(self) -> int: ...
    def parse(
        self, string: java.lang.String | str
    ) -> java.util.List[java.lang.String]: ...
    @typing.overload
    def parseObject(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def parseObject(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.Any: ...
    def toString(self) -> java.lang.String: ...
    class Style(java.lang.Enum["ListFormat.Style"]):
        FULL: typing.ClassVar[ListFormat.Style] = ...
        SHORT: typing.ClassVar[ListFormat.Style] = ...
        NARROW: typing.ClassVar[ListFormat.Style] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> ListFormat.Style: ...
        @staticmethod
        def values() -> typing.MutableSequence[ListFormat.Style]: ...

    class Type(java.lang.Enum["ListFormat.Type"]):
        STANDARD: typing.ClassVar[ListFormat.Type] = ...
        OR: typing.ClassVar[ListFormat.Type] = ...
        UNIT: typing.ClassVar[ListFormat.Type] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> ListFormat.Type: ...
        @staticmethod
        def values() -> typing.MutableSequence[ListFormat.Type]: ...

class MessageFormat(Format):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, locale: java.util.Locale): ...
    def applyPattern(self, string: java.lang.String | str) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        objectArray: list[typing.Any] | jpype.JArray,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    @staticmethod
    def format(
        string: java.lang.String | str, *object: typing.Any
    ) -> java.lang.String: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    def getFormats(self) -> typing.MutableSequence[Format]: ...
    def getFormatsByArgumentIndex(self) -> typing.MutableSequence[Format]: ...
    def getLocale(self) -> java.util.Locale: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[typing.Any]: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.MutableSequence[typing.Any]: ...
    @typing.overload
    def parseObject(self, string: java.lang.String | str) -> typing.Any: ...
    @typing.overload
    def parseObject(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.Any: ...
    def setFormat(self, int: int, format: Format) -> None: ...
    def setFormatByArgumentIndex(self, int: int, format: Format) -> None: ...
    def setFormats(self, formatArray: list[Format] | jpype.JArray) -> None: ...
    def setFormatsByArgumentIndex(
        self, formatArray: list[Format] | jpype.JArray
    ) -> None: ...
    def setLocale(self, locale: java.util.Locale) -> None: ...
    def toPattern(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    class Field(Format.Field):
        ARGUMENT: typing.ClassVar[MessageFormat.Field] = ...

class NumberFormat(Format):
    INTEGER_FIELD: typing.ClassVar[int] = ...
    FRACTION_FIELD: typing.ClassVar[int] = ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(
        self,
        double: float,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        long: int,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(self, double: float) -> java.lang.String: ...
    @typing.overload
    def format(self, long: int) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> typing.MutableSequence[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getCompactNumberInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getCompactNumberInstance(
        locale: java.util.Locale, style: NumberFormat.Style
    ) -> NumberFormat: ...
    def getCurrency(self) -> java.util.Currency: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance(locale: java.util.Locale) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance(locale: java.util.Locale) -> NumberFormat: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    @typing.overload
    @staticmethod
    def getNumberInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getNumberInstance(locale: java.util.Locale) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance(locale: java.util.Locale) -> NumberFormat: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def hashCode(self) -> int: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    def isStrict(self) -> bool: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.lang.Number: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.lang.Number: ...
    @typing.overload
    def parseObject(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> typing.Any: ...
    @typing.overload
    def parseObject(self, string: java.lang.String | str) -> typing.Any: ...
    def setCurrency(self, currency: java.util.Currency) -> None: ...
    def setGroupingUsed(self, boolean: bool) -> None: ...
    def setMaximumFractionDigits(self, int: int) -> None: ...
    def setMaximumIntegerDigits(self, int: int) -> None: ...
    def setMinimumFractionDigits(self, int: int) -> None: ...
    def setMinimumIntegerDigits(self, int: int) -> None: ...
    def setParseIntegerOnly(self, boolean: bool) -> None: ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode) -> None: ...
    def setStrict(self, boolean: bool) -> None: ...
    class Field(Format.Field):
        INTEGER: typing.ClassVar[NumberFormat.Field] = ...
        FRACTION: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT: typing.ClassVar[NumberFormat.Field] = ...
        DECIMAL_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        SIGN: typing.ClassVar[NumberFormat.Field] = ...
        GROUPING_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SYMBOL: typing.ClassVar[NumberFormat.Field] = ...
        PERCENT: typing.ClassVar[NumberFormat.Field] = ...
        PERMILLE: typing.ClassVar[NumberFormat.Field] = ...
        CURRENCY: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SIGN: typing.ClassVar[NumberFormat.Field] = ...
        PREFIX: typing.ClassVar[NumberFormat.Field] = ...
        SUFFIX: typing.ClassVar[NumberFormat.Field] = ...

    class Style(java.lang.Enum["NumberFormat.Style"]):
        SHORT: typing.ClassVar[NumberFormat.Style] = ...
        LONG: typing.ClassVar[NumberFormat.Style] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> NumberFormat.Style: ...
        @staticmethod
        def values() -> typing.MutableSequence[NumberFormat.Style]: ...

class ChoiceFormat(NumberFormat):
    @typing.overload
    def __init__(
        self,
        doubleArray: list[float] | jpype.JArray,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    def applyPattern(self, string: java.lang.String | str) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(self, double: float) -> java.lang.String: ...
    @typing.overload
    def format(self, long: int) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        double: float,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        long: int,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    def getFormats(self) -> typing.MutableSequence[typing.Any]: ...
    def getLimits(self) -> typing.MutableSequence[float]: ...
    def hashCode(self) -> int: ...
    def isStrict(self) -> bool: ...
    @typing.overload
    @staticmethod
    def nextDouble(double: float, boolean: bool) -> float: ...
    @typing.overload
    @staticmethod
    def nextDouble(double: float) -> float: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.lang.Number: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.lang.Number: ...
    @staticmethod
    def previousDouble(double: float) -> float: ...
    def setChoices(
        self,
        doubleArray: list[float] | jpype.JArray,
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> None: ...
    def setStrict(self, boolean: bool) -> None: ...
    def toPattern(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class CompactNumberFormat(NumberFormat):
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        decimalFormatSymbols: DecimalFormatSymbols,
        stringArray: list[java.lang.String] | jpype.JArray,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        decimalFormatSymbols: DecimalFormatSymbols,
        stringArray: list[java.lang.String] | jpype.JArray,
        string3: java.lang.String | str,
    ): ...
    def clone(self) -> CompactNumberFormat: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(self, double: float) -> java.lang.String: ...
    @typing.overload
    def format(self, long: int) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        double: float,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        long: int,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    def getGroupingSize(self) -> int: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def hashCode(self) -> int: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseBigDecimal(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    def isStrict(self) -> bool: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.lang.Number: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.lang.Number: ...
    def setGroupingSize(self, int: int) -> None: ...
    def setGroupingUsed(self, boolean: bool) -> None: ...
    def setMaximumFractionDigits(self, int: int) -> None: ...
    def setMaximumIntegerDigits(self, int: int) -> None: ...
    def setMinimumFractionDigits(self, int: int) -> None: ...
    def setMinimumIntegerDigits(self, int: int) -> None: ...
    def setParseBigDecimal(self, boolean: bool) -> None: ...
    def setParseIntegerOnly(self, boolean: bool) -> None: ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode) -> None: ...
    def setStrict(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...

class DecimalFormat(NumberFormat):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, decimalFormatSymbols: DecimalFormatSymbols
    ): ...
    def applyLocalizedPattern(self, string: java.lang.String | str) -> None: ...
    def applyPattern(self, string: java.lang.String | str) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(self, double: float) -> java.lang.String: ...
    @typing.overload
    def format(self, long: int) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        double: float,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        long: int,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    def getCurrency(self) -> java.util.Currency: ...
    def getDecimalFormatSymbols(self) -> DecimalFormatSymbols: ...
    def getGroupingSize(self) -> int: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    def getMultiplier(self) -> int: ...
    def getNegativePrefix(self) -> java.lang.String: ...
    def getNegativeSuffix(self) -> java.lang.String: ...
    def getPositivePrefix(self) -> java.lang.String: ...
    def getPositiveSuffix(self) -> java.lang.String: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def hashCode(self) -> int: ...
    def isDecimalSeparatorAlwaysShown(self) -> bool: ...
    def isParseBigDecimal(self) -> bool: ...
    def isStrict(self) -> bool: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.lang.Number: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.lang.Number: ...
    def setCurrency(self, currency: java.util.Currency) -> None: ...
    def setDecimalFormatSymbols(
        self, decimalFormatSymbols: DecimalFormatSymbols
    ) -> None: ...
    def setDecimalSeparatorAlwaysShown(self, boolean: bool) -> None: ...
    def setGroupingSize(self, int: int) -> None: ...
    def setGroupingUsed(self, boolean: bool) -> None: ...
    def setMaximumFractionDigits(self, int: int) -> None: ...
    def setMaximumIntegerDigits(self, int: int) -> None: ...
    def setMinimumFractionDigits(self, int: int) -> None: ...
    def setMinimumIntegerDigits(self, int: int) -> None: ...
    def setMultiplier(self, int: int) -> None: ...
    def setNegativePrefix(self, string: java.lang.String | str) -> None: ...
    def setNegativeSuffix(self, string: java.lang.String | str) -> None: ...
    def setParseBigDecimal(self, boolean: bool) -> None: ...
    def setPositivePrefix(self, string: java.lang.String | str) -> None: ...
    def setPositiveSuffix(self, string: java.lang.String | str) -> None: ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode) -> None: ...
    def setStrict(self, boolean: bool) -> None: ...
    def toLocalizedPattern(self) -> java.lang.String: ...
    def toPattern(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class SimpleDateFormat(DateFormat):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, dateFormatSymbols: DateFormatSymbols
    ): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, locale: java.util.Locale): ...
    def applyLocalizedPattern(self, string: java.lang.String | str) -> None: ...
    def applyPattern(self, string: java.lang.String | str) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def format(self, date: java.util.Date) -> java.lang.String: ...
    @typing.overload
    def format(self, object: typing.Any) -> java.lang.String: ...
    @typing.overload
    def format(
        self,
        object: typing.Any,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(
        self,
        date: java.util.Date,
        stringBuffer: java.lang.StringBuffer,
        fieldPosition: FieldPosition,
    ) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(
        self, object: typing.Any
    ) -> AttributedCharacterIterator: ...
    def get2DigitYearStart(self) -> java.util.Date: ...
    def getDateFormatSymbols(self) -> DateFormatSymbols: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def parse(self, string: java.lang.String | str) -> java.util.Date: ...
    @typing.overload
    def parse(
        self, string: java.lang.String | str, parsePosition: ParsePosition
    ) -> java.util.Date: ...
    def set2DigitYearStart(self, date: java.util.Date) -> None: ...
    def setDateFormatSymbols(self, dateFormatSymbols: DateFormatSymbols) -> None: ...
    def toLocalizedPattern(self) -> java.lang.String: ...
    def toPattern(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.text")``.

    Annotation: type[Annotation]
    AttributedCharacterIterator: type[AttributedCharacterIterator]
    AttributedString: type[AttributedString]
    Bidi: type[Bidi]
    BreakIterator: type[BreakIterator]
    CharacterIterator: type[CharacterIterator]
    ChoiceFormat: type[ChoiceFormat]
    CollationElementIterator: type[CollationElementIterator]
    CollationKey: type[CollationKey]
    Collator: type[Collator]
    CompactNumberFormat: type[CompactNumberFormat]
    DateFormat: type[DateFormat]
    DateFormatSymbols: type[DateFormatSymbols]
    DecimalFormat: type[DecimalFormat]
    DecimalFormatSymbols: type[DecimalFormatSymbols]
    FieldPosition: type[FieldPosition]
    Format: type[Format]
    ListFormat: type[ListFormat]
    MessageFormat: type[MessageFormat]
    Normalizer: type[Normalizer]
    NumberFormat: type[NumberFormat]
    ParseException: type[ParseException]
    ParsePosition: type[ParsePosition]
    RuleBasedCollator: type[RuleBasedCollator]
    SimpleDateFormat: type[SimpleDateFormat]
    StringCharacterIterator: type[StringCharacterIterator]
    spi: java.text.spi.__module_protocol__
