import typing
from typing import Protocol

import java.applet
import java.awt
import java.beans.beancontext
import java.io
import java.lang
import java.lang.annotation
import java.lang.reflect
import java.util
import jpype
import org.xml.sax
import org.xml.sax.helpers

class AppletInitializer:
    def activate(self, applet: java.applet.Applet) -> None: ...
    def initialize(
        self,
        applet: java.applet.Applet,
        beanContext: java.beans.beancontext.BeanContext,
    ) -> None: ...

class BeanInfo:
    ICON_COLOR_16x16: typing.ClassVar[int] = ...
    ICON_COLOR_32x32: typing.ClassVar[int] = ...
    ICON_MONO_16x16: typing.ClassVar[int] = ...
    ICON_MONO_32x32: typing.ClassVar[int] = ...
    def getAdditionalBeanInfo(self) -> typing.MutableSequence[BeanInfo]: ...
    def getBeanDescriptor(self) -> BeanDescriptor: ...
    def getDefaultEventIndex(self) -> int: ...
    def getDefaultPropertyIndex(self) -> int: ...
    def getEventSetDescriptors(self) -> typing.MutableSequence[EventSetDescriptor]: ...
    def getIcon(self, int: int) -> java.awt.Image: ...
    def getMethodDescriptors(self) -> typing.MutableSequence[MethodDescriptor]: ...
    def getPropertyDescriptors(self) -> typing.MutableSequence[PropertyDescriptor]: ...

class BeanProperty(java.lang.annotation.Annotation):
    def bound(self) -> bool: ...
    def description(self) -> java.lang.String: ...
    def enumerationValues(self) -> typing.MutableSequence[java.lang.String]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def expert(self) -> bool: ...
    def hashCode(self) -> int: ...
    def hidden(self) -> bool: ...
    def preferred(self) -> bool: ...
    def required(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    def visualUpdate(self) -> bool: ...

class Beans:
    def __init__(self): ...
    @staticmethod
    def getInstanceOf(object: typing.Any, class_: type[typing.Any]) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def instantiate(
        classLoader: java.lang.ClassLoader, string: java.lang.String | str
    ) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def instantiate(
        classLoader: java.lang.ClassLoader,
        string: java.lang.String | str,
        beanContext: java.beans.beancontext.BeanContext,
    ) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def instantiate(
        classLoader: java.lang.ClassLoader,
        string: java.lang.String | str,
        beanContext: java.beans.beancontext.BeanContext,
        appletInitializer: AppletInitializer,
    ) -> typing.Any: ...
    @staticmethod
    def isDesignTime() -> bool: ...
    @staticmethod
    def isGuiAvailable() -> bool: ...
    @staticmethod
    def isInstanceOf(object: typing.Any, class_: type[typing.Any]) -> bool: ...
    @staticmethod
    def setDesignTime(boolean: bool) -> None: ...
    @staticmethod
    def setGuiAvailable(boolean: bool) -> None: ...

class ConstructorProperties(java.lang.annotation.Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> typing.MutableSequence[java.lang.String]: ...

class Customizer:
    def addPropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def removePropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def setObject(self, object: typing.Any) -> None: ...

class DesignMode:
    PROPERTYNAME: typing.ClassVar[java.lang.String] = ...
    def isDesignTime(self) -> bool: ...
    def setDesignTime(self, boolean: bool) -> None: ...

class Encoder:
    def __init__(self): ...
    def get(self, object: typing.Any) -> typing.Any: ...
    def getExceptionListener(self) -> ExceptionListener: ...
    def getPersistenceDelegate(
        self, class_: type[typing.Any]
    ) -> PersistenceDelegate: ...
    def remove(self, object: typing.Any) -> typing.Any: ...
    def setExceptionListener(
        self, exceptionListener: ExceptionListener | typing.Callable
    ) -> None: ...
    def setPersistenceDelegate(
        self, class_: type[typing.Any], persistenceDelegate: PersistenceDelegate
    ) -> None: ...
    def writeExpression(self, expression: Expression) -> None: ...
    def writeStatement(self, statement: Statement) -> None: ...

class EventHandler(java.lang.reflect.InvocationHandler):
    def __init__(
        self,
        object: typing.Any,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ): ...
    _create_0__T = typing.TypeVar("_create_0__T")  # <T>
    _create_1__T = typing.TypeVar("_create_1__T")  # <T>
    _create_2__T = typing.TypeVar("_create_2__T")  # <T>
    @typing.overload
    @staticmethod
    def create(
        class_: type[_create_0__T], object: typing.Any, string: java.lang.String | str
    ) -> _create_0__T: ...
    @typing.overload
    @staticmethod
    def create(
        class_: type[_create_1__T],
        object: typing.Any,
        string: java.lang.String | str,
        string2: java.lang.String | str,
    ) -> _create_1__T: ...
    @typing.overload
    @staticmethod
    def create(
        class_: type[_create_2__T],
        object: typing.Any,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ) -> _create_2__T: ...
    def getAction(self) -> java.lang.String: ...
    def getEventPropertyName(self) -> java.lang.String: ...
    def getListenerMethodName(self) -> java.lang.String: ...
    def getTarget(self) -> typing.Any: ...
    def invoke(
        self,
        object: typing.Any,
        method: java.lang.reflect.Method,
        objectArray: list[typing.Any] | jpype.JArray,
    ) -> typing.Any: ...

class ExceptionListener:
    def exceptionThrown(self, exception: java.lang.Exception) -> None: ...

class FeatureDescriptor:
    def __init__(self): ...
    def attributeNames(self) -> java.util.Enumeration[java.lang.String]: ...
    def getDisplayName(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getShortDescription(self) -> java.lang.String: ...
    def getValue(self, string: java.lang.String | str) -> typing.Any: ...
    def isExpert(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def isPreferred(self) -> bool: ...
    def setDisplayName(self, string: java.lang.String | str) -> None: ...
    def setExpert(self, boolean: bool) -> None: ...
    def setHidden(self, boolean: bool) -> None: ...
    def setName(self, string: java.lang.String | str) -> None: ...
    def setPreferred(self, boolean: bool) -> None: ...
    def setShortDescription(self, string: java.lang.String | str) -> None: ...
    def setValue(self, string: java.lang.String | str, object: typing.Any) -> None: ...
    def toString(self) -> java.lang.String: ...

class IntrospectionException(java.lang.Exception):
    def __init__(self, string: java.lang.String | str): ...

class Introspector:
    USE_ALL_BEANINFO: typing.ClassVar[int] = ...
    IGNORE_IMMEDIATE_BEANINFO: typing.ClassVar[int] = ...
    IGNORE_ALL_BEANINFO: typing.ClassVar[int] = ...
    @staticmethod
    def decapitalize(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def flushCaches() -> None: ...
    @staticmethod
    def flushFromCaches(class_: type[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def getBeanInfo(class_: type[typing.Any]) -> BeanInfo: ...
    @typing.overload
    @staticmethod
    def getBeanInfo(class_: type[typing.Any], int: int) -> BeanInfo: ...
    @typing.overload
    @staticmethod
    def getBeanInfo(class_: type[typing.Any], class2: type[typing.Any]) -> BeanInfo: ...
    @typing.overload
    @staticmethod
    def getBeanInfo(
        class_: type[typing.Any], class2: type[typing.Any], int: int
    ) -> BeanInfo: ...
    @staticmethod
    def getBeanInfoSearchPath() -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def setBeanInfoSearchPath(
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> None: ...

class JavaBean(java.lang.annotation.Annotation):
    def defaultEventSet(self) -> java.lang.String: ...
    def defaultProperty(self) -> java.lang.String: ...
    def description(self) -> java.lang.String: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class PersistenceDelegate:
    def writeObject(self, object: typing.Any, encoder: Encoder) -> None: ...

class PropertyChangeEvent(java.util.EventObject):
    def __init__(
        self,
        object: typing.Any,
        string: java.lang.String | str,
        object2: typing.Any,
        object3: typing.Any,
    ): ...
    def getNewValue(self) -> typing.Any: ...
    def getOldValue(self) -> typing.Any: ...
    def getPropagationId(self) -> typing.Any: ...
    def getPropertyName(self) -> java.lang.String: ...
    def setPropagationId(self, object: typing.Any) -> None: ...
    def toString(self) -> java.lang.String: ...

class PropertyChangeListener(java.util.EventListener):
    def propertyChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...

class PropertyChangeSupport(java.io.Serializable):
    def __init__(self, object: typing.Any): ...
    @typing.overload
    def addPropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    @typing.overload
    def addPropertyChangeListener(
        self,
        string: java.lang.String | str,
        propertyChangeListener: PropertyChangeListener | typing.Callable,
    ) -> None: ...
    @typing.overload
    def fireIndexedPropertyChange(
        self, string: java.lang.String | str, int: int, boolean: bool, boolean2: bool
    ) -> None: ...
    @typing.overload
    def fireIndexedPropertyChange(
        self, string: java.lang.String | str, int: int, int2: int, int3: int
    ) -> None: ...
    @typing.overload
    def fireIndexedPropertyChange(
        self,
        string: java.lang.String | str,
        int: int,
        object: typing.Any,
        object2: typing.Any,
    ) -> None: ...
    @typing.overload
    def firePropertyChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...
    @typing.overload
    def firePropertyChange(
        self, string: java.lang.String | str, boolean: bool, boolean2: bool
    ) -> None: ...
    @typing.overload
    def firePropertyChange(
        self, string: java.lang.String | str, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def firePropertyChange(
        self, string: java.lang.String | str, object: typing.Any, object2: typing.Any
    ) -> None: ...
    @typing.overload
    def getPropertyChangeListeners(
        self,
    ) -> typing.MutableSequence[PropertyChangeListener]: ...
    @typing.overload
    def getPropertyChangeListeners(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[PropertyChangeListener]: ...
    def hasListeners(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def removePropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    @typing.overload
    def removePropertyChangeListener(
        self,
        string: java.lang.String | str,
        propertyChangeListener: PropertyChangeListener | typing.Callable,
    ) -> None: ...

class PropertyEditor:
    def addPropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def getAsText(self) -> java.lang.String: ...
    def getCustomEditor(self) -> java.awt.Component: ...
    def getJavaInitializationString(self) -> java.lang.String: ...
    def getTags(self) -> typing.MutableSequence[java.lang.String]: ...
    def getValue(self) -> typing.Any: ...
    def isPaintable(self) -> bool: ...
    def paintValue(
        self, graphics: java.awt.Graphics, rectangle: java.awt.Rectangle
    ) -> None: ...
    def removePropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def setAsText(self, string: java.lang.String | str) -> None: ...
    def setValue(self, object: typing.Any) -> None: ...
    def supportsCustomEditor(self) -> bool: ...

class PropertyEditorManager:
    def __init__(self): ...
    @staticmethod
    def findEditor(class_: type[typing.Any]) -> PropertyEditor: ...
    @staticmethod
    def getEditorSearchPath() -> typing.MutableSequence[java.lang.String]: ...
    @staticmethod
    def registerEditor(class_: type[typing.Any], class2: type[typing.Any]) -> None: ...
    @staticmethod
    def setEditorSearchPath(
        stringArray: list[java.lang.String] | jpype.JArray,
    ) -> None: ...

class PropertyVetoException(java.lang.Exception):
    def __init__(
        self, string: java.lang.String | str, propertyChangeEvent: PropertyChangeEvent
    ): ...
    def getPropertyChangeEvent(self) -> PropertyChangeEvent: ...

class Statement:
    def __init__(
        self,
        object: typing.Any,
        string: java.lang.String | str,
        objectArray: list[typing.Any] | jpype.JArray,
    ): ...
    def execute(self) -> None: ...
    def getArguments(self) -> typing.MutableSequence[typing.Any]: ...
    def getMethodName(self) -> java.lang.String: ...
    def getTarget(self) -> typing.Any: ...
    def toString(self) -> java.lang.String: ...

class Transient(java.lang.annotation.Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> bool: ...

class VetoableChangeListener(java.util.EventListener):
    def vetoableChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...

class VetoableChangeSupport(java.io.Serializable):
    def __init__(self, object: typing.Any): ...
    @typing.overload
    def addVetoableChangeListener(
        self, vetoableChangeListener: VetoableChangeListener | typing.Callable
    ) -> None: ...
    @typing.overload
    def addVetoableChangeListener(
        self,
        string: java.lang.String | str,
        vetoableChangeListener: VetoableChangeListener | typing.Callable,
    ) -> None: ...
    @typing.overload
    def fireVetoableChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...
    @typing.overload
    def fireVetoableChange(
        self, string: java.lang.String | str, boolean: bool, boolean2: bool
    ) -> None: ...
    @typing.overload
    def fireVetoableChange(
        self, string: java.lang.String | str, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def fireVetoableChange(
        self, string: java.lang.String | str, object: typing.Any, object2: typing.Any
    ) -> None: ...
    @typing.overload
    def getVetoableChangeListeners(
        self,
    ) -> typing.MutableSequence[VetoableChangeListener]: ...
    @typing.overload
    def getVetoableChangeListeners(
        self, string: java.lang.String | str
    ) -> typing.MutableSequence[VetoableChangeListener]: ...
    def hasListeners(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def removeVetoableChangeListener(
        self, vetoableChangeListener: VetoableChangeListener | typing.Callable
    ) -> None: ...
    @typing.overload
    def removeVetoableChangeListener(
        self,
        string: java.lang.String | str,
        vetoableChangeListener: VetoableChangeListener | typing.Callable,
    ) -> None: ...

class Visibility:
    def avoidingGui(self) -> bool: ...
    def dontUseGui(self) -> None: ...
    def needsGui(self) -> bool: ...
    def okToUseGui(self) -> None: ...

class XMLDecoder(java.lang.AutoCloseable):
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, object: typing.Any): ...
    @typing.overload
    def __init__(
        self,
        inputStream: java.io.InputStream,
        object: typing.Any,
        exceptionListener: ExceptionListener | typing.Callable,
    ): ...
    @typing.overload
    def __init__(
        self,
        inputStream: java.io.InputStream,
        object: typing.Any,
        exceptionListener: ExceptionListener | typing.Callable,
        classLoader: java.lang.ClassLoader,
    ): ...
    @typing.overload
    def __init__(self, inputSource: org.xml.sax.InputSource): ...
    def close(self) -> None: ...
    @staticmethod
    def createHandler(
        object: typing.Any,
        exceptionListener: ExceptionListener | typing.Callable,
        classLoader: java.lang.ClassLoader,
    ) -> org.xml.sax.helpers.DefaultHandler: ...
    def getExceptionListener(self) -> ExceptionListener: ...
    def getOwner(self) -> typing.Any: ...
    def readObject(self) -> typing.Any: ...
    def setExceptionListener(
        self, exceptionListener: ExceptionListener | typing.Callable
    ) -> None: ...
    def setOwner(self, object: typing.Any) -> None: ...

class BeanDescriptor(FeatureDescriptor):
    @typing.overload
    def __init__(self, class_: type[typing.Any]): ...
    @typing.overload
    def __init__(self, class_: type[typing.Any], class2: type[typing.Any]): ...
    def getBeanClass(self) -> type[typing.Any]: ...
    def getCustomizerClass(self) -> type[typing.Any]: ...

class DefaultPersistenceDelegate(PersistenceDelegate):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, stringArray: list[java.lang.String] | jpype.JArray): ...

class EventSetDescriptor(FeatureDescriptor):
    @typing.overload
    def __init__(
        self,
        class_: type[typing.Any],
        string: java.lang.String | str,
        class2: type[typing.Any],
        string2: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        class_: type[typing.Any],
        string: java.lang.String | str,
        class2: type[typing.Any],
        stringArray: list[java.lang.String] | jpype.JArray,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        class_: type[typing.Any],
        string: java.lang.String | str,
        class2: type[typing.Any],
        stringArray: list[java.lang.String] | jpype.JArray,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        string5: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[typing.Any],
        methodDescriptorArray: list[MethodDescriptor] | jpype.JArray,
        method2: java.lang.reflect.Method,
        method3: java.lang.reflect.Method,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[typing.Any],
        methodArray: list[java.lang.reflect.Method] | jpype.JArray,
        method2: java.lang.reflect.Method,
        method3: java.lang.reflect.Method,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[typing.Any],
        methodArray: list[java.lang.reflect.Method] | jpype.JArray,
        method2: java.lang.reflect.Method,
        method3: java.lang.reflect.Method,
        method4: java.lang.reflect.Method,
    ): ...
    def getAddListenerMethod(self) -> java.lang.reflect.Method: ...
    def getGetListenerMethod(self) -> java.lang.reflect.Method: ...
    def getListenerMethodDescriptors(
        self,
    ) -> typing.MutableSequence[MethodDescriptor]: ...
    def getListenerMethods(
        self,
    ) -> typing.MutableSequence[java.lang.reflect.Method]: ...
    def getListenerType(self) -> type[typing.Any]: ...
    def getRemoveListenerMethod(self) -> java.lang.reflect.Method: ...
    def isInDefaultEventSet(self) -> bool: ...
    def isUnicast(self) -> bool: ...
    def setInDefaultEventSet(self, boolean: bool) -> None: ...
    def setUnicast(self, boolean: bool) -> None: ...

class Expression(Statement):
    @typing.overload
    def __init__(
        self,
        object: typing.Any,
        object2: typing.Any,
        string: java.lang.String | str,
        objectArray: list[typing.Any] | jpype.JArray,
    ): ...
    @typing.overload
    def __init__(
        self,
        object: typing.Any,
        string: java.lang.String | str,
        objectArray: list[typing.Any] | jpype.JArray,
    ): ...
    def execute(self) -> None: ...
    def getValue(self) -> typing.Any: ...
    def setValue(self, object: typing.Any) -> None: ...
    def toString(self) -> java.lang.String: ...

class IndexedPropertyChangeEvent(PropertyChangeEvent):
    def __init__(
        self,
        object: typing.Any,
        string: java.lang.String | str,
        object2: typing.Any,
        object3: typing.Any,
        int: int,
    ): ...
    def getIndex(self) -> int: ...

class MethodDescriptor(FeatureDescriptor):
    @typing.overload
    def __init__(self, method: java.lang.reflect.Method): ...
    @typing.overload
    def __init__(
        self,
        method: java.lang.reflect.Method,
        parameterDescriptorArray: list[ParameterDescriptor] | jpype.JArray,
    ): ...
    def getMethod(self) -> java.lang.reflect.Method: ...
    def getParameterDescriptors(
        self,
    ) -> typing.MutableSequence[ParameterDescriptor]: ...

class ParameterDescriptor(FeatureDescriptor):
    def __init__(self): ...

class PropertyChangeListenerProxy(
    java.util.EventListenerProxy[PropertyChangeListener], PropertyChangeListener
):
    def __init__(
        self,
        string: java.lang.String | str,
        propertyChangeListener: PropertyChangeListener | typing.Callable,
    ): ...
    def getPropertyName(self) -> java.lang.String: ...
    def propertyChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...

class PropertyDescriptor(FeatureDescriptor):
    @typing.overload
    def __init__(self, string: java.lang.String | str, class_: type[typing.Any]): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[typing.Any],
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        method: java.lang.reflect.Method,
        method2: java.lang.reflect.Method,
    ): ...
    def createPropertyEditor(self, object: typing.Any) -> PropertyEditor: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getPropertyEditorClass(self) -> type[typing.Any]: ...
    def getPropertyType(self) -> type[typing.Any]: ...
    def getReadMethod(self) -> java.lang.reflect.Method: ...
    def getWriteMethod(self) -> java.lang.reflect.Method: ...
    def hashCode(self) -> int: ...
    def isBound(self) -> bool: ...
    def isConstrained(self) -> bool: ...
    def setBound(self, boolean: bool) -> None: ...
    def setConstrained(self, boolean: bool) -> None: ...
    def setPropertyEditorClass(self, class_: type[typing.Any]) -> None: ...
    def setReadMethod(self, method: java.lang.reflect.Method) -> None: ...
    def setWriteMethod(self, method: java.lang.reflect.Method) -> None: ...

class PropertyEditorSupport(PropertyEditor):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, object: typing.Any): ...
    def addPropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def firePropertyChange(self) -> None: ...
    def getAsText(self) -> java.lang.String: ...
    def getCustomEditor(self) -> java.awt.Component: ...
    def getJavaInitializationString(self) -> java.lang.String: ...
    def getSource(self) -> typing.Any: ...
    def getTags(self) -> typing.MutableSequence[java.lang.String]: ...
    def getValue(self) -> typing.Any: ...
    def isPaintable(self) -> bool: ...
    def paintValue(
        self, graphics: java.awt.Graphics, rectangle: java.awt.Rectangle
    ) -> None: ...
    def removePropertyChangeListener(
        self, propertyChangeListener: PropertyChangeListener | typing.Callable
    ) -> None: ...
    def setAsText(self, string: java.lang.String | str) -> None: ...
    def setSource(self, object: typing.Any) -> None: ...
    def setValue(self, object: typing.Any) -> None: ...
    def supportsCustomEditor(self) -> bool: ...

class SimpleBeanInfo(BeanInfo):
    def __init__(self): ...
    def getAdditionalBeanInfo(self) -> typing.MutableSequence[BeanInfo]: ...
    def getBeanDescriptor(self) -> BeanDescriptor: ...
    def getDefaultEventIndex(self) -> int: ...
    def getDefaultPropertyIndex(self) -> int: ...
    def getEventSetDescriptors(self) -> typing.MutableSequence[EventSetDescriptor]: ...
    def getIcon(self, int: int) -> java.awt.Image: ...
    def getMethodDescriptors(self) -> typing.MutableSequence[MethodDescriptor]: ...
    def getPropertyDescriptors(self) -> typing.MutableSequence[PropertyDescriptor]: ...
    def loadImage(self, string: java.lang.String | str) -> java.awt.Image: ...

class VetoableChangeListenerProxy(
    java.util.EventListenerProxy[VetoableChangeListener], VetoableChangeListener
):
    def __init__(
        self,
        string: java.lang.String | str,
        vetoableChangeListener: VetoableChangeListener | typing.Callable,
    ): ...
    def getPropertyName(self) -> java.lang.String: ...
    def vetoableChange(self, propertyChangeEvent: PropertyChangeEvent) -> None: ...

class XMLEncoder(Encoder, java.lang.AutoCloseable):
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @typing.overload
    def __init__(
        self,
        outputStream: java.io.OutputStream,
        string: java.lang.String | str,
        boolean: bool,
        int: int,
    ): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def getOwner(self) -> typing.Any: ...
    def setOwner(self, object: typing.Any) -> None: ...
    def writeExpression(self, expression: Expression) -> None: ...
    def writeObject(self, object: typing.Any) -> None: ...
    def writeStatement(self, statement: Statement) -> None: ...

class IndexedPropertyDescriptor(PropertyDescriptor):
    @typing.overload
    def __init__(self, string: java.lang.String | str, class_: type[typing.Any]): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        class_: type[typing.Any],
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        string5: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        method: java.lang.reflect.Method,
        method2: java.lang.reflect.Method,
        method3: java.lang.reflect.Method,
        method4: java.lang.reflect.Method,
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getIndexedPropertyType(self) -> type[typing.Any]: ...
    def getIndexedReadMethod(self) -> java.lang.reflect.Method: ...
    def getIndexedWriteMethod(self) -> java.lang.reflect.Method: ...
    def hashCode(self) -> int: ...
    def setIndexedReadMethod(self, method: java.lang.reflect.Method) -> None: ...
    def setIndexedWriteMethod(self, method: java.lang.reflect.Method) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.beans")``.

    AppletInitializer: type[AppletInitializer]
    BeanDescriptor: type[BeanDescriptor]
    BeanInfo: type[BeanInfo]
    BeanProperty: type[BeanProperty]
    Beans: type[Beans]
    ConstructorProperties: type[ConstructorProperties]
    Customizer: type[Customizer]
    DefaultPersistenceDelegate: type[DefaultPersistenceDelegate]
    DesignMode: type[DesignMode]
    Encoder: type[Encoder]
    EventHandler: type[EventHandler]
    EventSetDescriptor: type[EventSetDescriptor]
    ExceptionListener: type[ExceptionListener]
    Expression: type[Expression]
    FeatureDescriptor: type[FeatureDescriptor]
    IndexedPropertyChangeEvent: type[IndexedPropertyChangeEvent]
    IndexedPropertyDescriptor: type[IndexedPropertyDescriptor]
    IntrospectionException: type[IntrospectionException]
    Introspector: type[Introspector]
    JavaBean: type[JavaBean]
    MethodDescriptor: type[MethodDescriptor]
    ParameterDescriptor: type[ParameterDescriptor]
    PersistenceDelegate: type[PersistenceDelegate]
    PropertyChangeEvent: type[PropertyChangeEvent]
    PropertyChangeListener: type[PropertyChangeListener]
    PropertyChangeListenerProxy: type[PropertyChangeListenerProxy]
    PropertyChangeSupport: type[PropertyChangeSupport]
    PropertyDescriptor: type[PropertyDescriptor]
    PropertyEditor: type[PropertyEditor]
    PropertyEditorManager: type[PropertyEditorManager]
    PropertyEditorSupport: type[PropertyEditorSupport]
    PropertyVetoException: type[PropertyVetoException]
    SimpleBeanInfo: type[SimpleBeanInfo]
    Statement: type[Statement]
    Transient: type[Transient]
    VetoableChangeListener: type[VetoableChangeListener]
    VetoableChangeListenerProxy: type[VetoableChangeListenerProxy]
    VetoableChangeSupport: type[VetoableChangeSupport]
    Visibility: type[Visibility]
    XMLDecoder: type[XMLDecoder]
    XMLEncoder: type[XMLEncoder]
    beancontext: java.beans.beancontext.__module_protocol__
