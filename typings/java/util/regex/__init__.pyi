import typing
from typing import Protocol

import java.io
import java.lang
import java.util
import java.util.function
import java.util.stream

class MatchResult:
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, int: int) -> int: ...
    @typing.overload
    def end(self, string: java.lang.String | str) -> int: ...
    @typing.overload
    def group(self) -> java.lang.String: ...
    @typing.overload
    def group(self, int: int) -> java.lang.String: ...
    @typing.overload
    def group(self, string: java.lang.String | str) -> java.lang.String: ...
    def groupCount(self) -> int: ...
    def hasMatch(self) -> bool: ...
    def namedGroups(self) -> java.util.Map[java.lang.String, int]: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, int: int) -> int: ...
    @typing.overload
    def start(self, string: java.lang.String | str) -> int: ...

class Pattern(java.io.Serializable):
    UNIX_LINES: typing.ClassVar[int] = ...
    CASE_INSENSITIVE: typing.ClassVar[int] = ...
    COMMENTS: typing.ClassVar[int] = ...
    MULTILINE: typing.ClassVar[int] = ...
    LITERAL: typing.ClassVar[int] = ...
    DOTALL: typing.ClassVar[int] = ...
    UNICODE_CASE: typing.ClassVar[int] = ...
    CANON_EQ: typing.ClassVar[int] = ...
    UNICODE_CHARACTER_CLASS: typing.ClassVar[int] = ...
    def asMatchPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    def asPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def compile(string: java.lang.String | str) -> Pattern: ...
    @typing.overload
    @staticmethod
    def compile(string: java.lang.String | str, int: int) -> Pattern: ...
    def flags(self) -> int: ...
    def matcher(self, charSequence: java.lang.CharSequence | str) -> Matcher: ...
    @staticmethod
    def matches(
        string: java.lang.String | str, charSequence: java.lang.CharSequence | str
    ) -> bool: ...
    def namedGroups(self) -> java.util.Map[java.lang.String, int]: ...
    def pattern(self) -> java.lang.String: ...
    @staticmethod
    def quote(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    def split(
        self, charSequence: java.lang.CharSequence | str
    ) -> typing.MutableSequence[java.lang.String]: ...
    @typing.overload
    def split(
        self, charSequence: java.lang.CharSequence | str, int: int
    ) -> typing.MutableSequence[java.lang.String]: ...
    def splitAsStream(
        self, charSequence: java.lang.CharSequence | str
    ) -> java.util.stream.Stream[java.lang.String]: ...
    def splitWithDelimiters(
        self, charSequence: java.lang.CharSequence | str, int: int
    ) -> typing.MutableSequence[java.lang.String]: ...
    def toString(self) -> java.lang.String: ...

class PatternSyntaxException(java.lang.IllegalArgumentException):
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str, int: int
    ): ...
    def getDescription(self) -> java.lang.String: ...
    def getIndex(self) -> int: ...
    def getMessage(self) -> java.lang.String: ...
    def getPattern(self) -> java.lang.String: ...

class Matcher(MatchResult):
    @typing.overload
    def appendReplacement(
        self, stringBuffer: java.lang.StringBuffer, string2: java.lang.String | str
    ) -> Matcher: ...
    @typing.overload
    def appendReplacement(
        self, stringBuilder: java.lang.StringBuilder, string2: java.lang.String | str
    ) -> Matcher: ...
    @typing.overload
    def appendTail(
        self, stringBuffer: java.lang.StringBuffer
    ) -> java.lang.StringBuffer: ...
    @typing.overload
    def appendTail(
        self, stringBuilder: java.lang.StringBuilder
    ) -> java.lang.StringBuilder: ...
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, int: int) -> int: ...
    @typing.overload
    def end(self, string: java.lang.String | str) -> int: ...
    @typing.overload
    def find(self) -> bool: ...
    @typing.overload
    def find(self, int: int) -> bool: ...
    @typing.overload
    def group(self) -> java.lang.String: ...
    @typing.overload
    def group(self, int: int) -> java.lang.String: ...
    @typing.overload
    def group(self, string: java.lang.String | str) -> java.lang.String: ...
    def groupCount(self) -> int: ...
    def hasAnchoringBounds(self) -> bool: ...
    def hasMatch(self) -> bool: ...
    def hasTransparentBounds(self) -> bool: ...
    def hitEnd(self) -> bool: ...
    def lookingAt(self) -> bool: ...
    def matches(self) -> bool: ...
    def namedGroups(self) -> java.util.Map[java.lang.String, int]: ...
    def pattern(self) -> Pattern: ...
    @staticmethod
    def quoteReplacement(string: java.lang.String | str) -> java.lang.String: ...
    def region(self, int: int, int2: int) -> Matcher: ...
    def regionEnd(self) -> int: ...
    def regionStart(self) -> int: ...
    @typing.overload
    def replaceAll(self, string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    def replaceAll(
        self,
        function: java.util.function.Function[MatchResult, java.lang.String | str]
        | typing.Callable[[MatchResult], java.lang.String | str],
    ) -> java.lang.String: ...
    @typing.overload
    def replaceFirst(self, string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    def replaceFirst(
        self,
        function: java.util.function.Function[MatchResult, java.lang.String | str]
        | typing.Callable[[MatchResult], java.lang.String | str],
    ) -> java.lang.String: ...
    def requireEnd(self) -> bool: ...
    @typing.overload
    def reset(self) -> Matcher: ...
    @typing.overload
    def reset(self, charSequence: java.lang.CharSequence | str) -> Matcher: ...
    def results(self) -> java.util.stream.Stream[MatchResult]: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, int: int) -> int: ...
    @typing.overload
    def start(self, string: java.lang.String | str) -> int: ...
    def toMatchResult(self) -> MatchResult: ...
    def toString(self) -> java.lang.String: ...
    def useAnchoringBounds(self, boolean: bool) -> Matcher: ...
    def usePattern(self, pattern: Pattern) -> Matcher: ...
    def useTransparentBounds(self, boolean: bool) -> Matcher: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.util.regex")``.

    MatchResult: type[MatchResult]
    Matcher: type[Matcher]
    Pattern: type[Pattern]
    PatternSyntaxException: type[PatternSyntaxException]
