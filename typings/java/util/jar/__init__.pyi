import typing
from typing import Protocol

import java.io
import java.lang
import java.security
import java.security.cert
import java.util
import java.util.stream
import java.util.zip
import jpype
import jpype.protocol

class Attributes(java.util.Map[typing.Any, typing.Any], java.lang.Cloneable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, attributes: Attributes): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(
        self,
    ) -> java.util.Set[java.util.Map.Entry[typing.Any, typing.Any]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> typing.Any: ...
    @typing.overload
    def getValue(self, string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    def getValue(self, name: Attributes.Name) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[typing.Any]: ...
    def put(self, object: typing.Any, object2: typing.Any) -> typing.Any: ...
    def putAll(
        self,
        map: java.util.Map[typing.Any, typing.Any]
        | typing.Mapping[typing.Any, typing.Any],
    ) -> None: ...
    def putValue(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> typing.Any: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[typing.Any]: ...
    class Name:
        MANIFEST_VERSION: typing.ClassVar[Attributes.Name] = ...
        SIGNATURE_VERSION: typing.ClassVar[Attributes.Name] = ...
        CONTENT_TYPE: typing.ClassVar[Attributes.Name] = ...
        CLASS_PATH: typing.ClassVar[Attributes.Name] = ...
        MAIN_CLASS: typing.ClassVar[Attributes.Name] = ...
        SEALED: typing.ClassVar[Attributes.Name] = ...
        EXTENSION_LIST: typing.ClassVar[Attributes.Name] = ...
        EXTENSION_NAME: typing.ClassVar[Attributes.Name] = ...
        EXTENSION_INSTALLATION: typing.ClassVar[Attributes.Name] = ...
        IMPLEMENTATION_TITLE: typing.ClassVar[Attributes.Name] = ...
        IMPLEMENTATION_VERSION: typing.ClassVar[Attributes.Name] = ...
        IMPLEMENTATION_VENDOR: typing.ClassVar[Attributes.Name] = ...
        IMPLEMENTATION_VENDOR_ID: typing.ClassVar[Attributes.Name] = ...
        IMPLEMENTATION_URL: typing.ClassVar[Attributes.Name] = ...
        SPECIFICATION_TITLE: typing.ClassVar[Attributes.Name] = ...
        SPECIFICATION_VERSION: typing.ClassVar[Attributes.Name] = ...
        SPECIFICATION_VENDOR: typing.ClassVar[Attributes.Name] = ...
        MULTI_RELEASE: typing.ClassVar[Attributes.Name] = ...
        def __init__(self, string: java.lang.String | str): ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...

class JarEntry(java.util.zip.ZipEntry):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, jarEntry: JarEntry): ...
    @typing.overload
    def __init__(self, zipEntry: java.util.zip.ZipEntry): ...
    def getAttributes(self) -> Attributes: ...
    def getCertificates(
        self,
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def getCodeSigners(self) -> typing.MutableSequence[java.security.CodeSigner]: ...
    def getRealName(self) -> java.lang.String: ...

class JarException(java.util.zip.ZipException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class JarFile(java.util.zip.ZipFile):
    MANIFEST_NAME: typing.ClassVar[java.lang.String] = ...
    @typing.overload
    def __init__(self, file: java.io.File | jpype.protocol.SupportsPath): ...
    @typing.overload
    def __init__(
        self, file: java.io.File | jpype.protocol.SupportsPath, boolean: bool
    ): ...
    @typing.overload
    def __init__(
        self, file: java.io.File | jpype.protocol.SupportsPath, boolean: bool, int: int
    ): ...
    @typing.overload
    def __init__(
        self,
        file: java.io.File | jpype.protocol.SupportsPath,
        boolean: bool,
        int: int,
        version: java.lang.Runtime.Version,
    ): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, boolean: bool): ...
    @staticmethod
    def baseVersion() -> java.lang.Runtime.Version: ...
    def entries(self) -> java.util.Enumeration[JarEntry]: ...
    def getEntry(self, string: java.lang.String | str) -> java.util.zip.ZipEntry: ...
    def getInputStream(
        self, zipEntry: java.util.zip.ZipEntry
    ) -> java.io.InputStream: ...
    def getJarEntry(self, string: java.lang.String | str) -> JarEntry: ...
    def getManifest(self) -> Manifest: ...
    def getVersion(self) -> java.lang.Runtime.Version: ...
    def isMultiRelease(self) -> bool: ...
    @staticmethod
    def runtimeVersion() -> java.lang.Runtime.Version: ...
    def stream(self) -> java.util.stream.Stream[JarEntry]: ...
    def versionedStream(self) -> java.util.stream.Stream[JarEntry]: ...

class JarInputStream(java.util.zip.ZipInputStream):
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, boolean: bool): ...
    def getManifest(self) -> Manifest: ...
    def getNextEntry(self) -> java.util.zip.ZipEntry: ...
    def getNextJarEntry(self) -> JarEntry: ...
    @typing.overload
    def read(self, byteArray: list[int] | jpype.JArray | bytes) -> int: ...
    @typing.overload
    def read(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> int: ...
    @typing.overload
    def read(self) -> int: ...

class JarOutputStream(java.util.zip.ZipOutputStream):
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, manifest: Manifest): ...
    def putNextEntry(self, zipEntry: java.util.zip.ZipEntry) -> None: ...

class Manifest(java.lang.Cloneable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, manifest: Manifest): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAttributes(self, string: java.lang.String | str) -> Attributes: ...
    def getEntries(self) -> java.util.Map[java.lang.String, Attributes]: ...
    def getMainAttributes(self) -> Attributes: ...
    def hashCode(self) -> int: ...
    def read(self, inputStream: java.io.InputStream) -> None: ...
    def write(self, outputStream: java.io.OutputStream) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.util.jar")``.

    Attributes: type[Attributes]
    JarEntry: type[JarEntry]
    JarException: type[JarException]
    JarFile: type[JarFile]
    JarInputStream: type[JarInputStream]
    JarOutputStream: type[JarOutputStream]
    Manifest: type[Manifest]
