import typing
from typing import Protocol

import java.io
import java.lang
import java.lang.reflect
import java.net
import java.nio
import java.nio.file
import java.util
import java.util.function
import java.util.stream
import jpype.protocol

class Configuration:
    @staticmethod
    def empty() -> Configuration: ...
    def findModule(
        self, string: java.lang.String | str
    ) -> java.util.Optional[ResolvedModule]: ...
    def modules(self) -> java.util.Set[ResolvedModule]: ...
    def parents(self) -> java.util.List[Configuration]: ...
    @typing.overload
    def resolve(
        self,
        moduleFinder: ModuleFinder,
        moduleFinder2: ModuleFinder,
        collection: java.util.Collection[java.lang.String | str]
        | typing.Sequence[java.lang.String | str]
        | set[java.lang.String | str],
    ) -> Configuration: ...
    @typing.overload
    @staticmethod
    def resolve(
        moduleFinder: ModuleFinder,
        list: java.util.List[Configuration],
        moduleFinder2: ModuleFinder,
        collection: java.util.Collection[java.lang.String | str]
        | typing.Sequence[java.lang.String | str]
        | set[java.lang.String | str],
    ) -> Configuration: ...
    @typing.overload
    def resolveAndBind(
        self,
        moduleFinder: ModuleFinder,
        moduleFinder2: ModuleFinder,
        collection: java.util.Collection[java.lang.String | str]
        | typing.Sequence[java.lang.String | str]
        | set[java.lang.String | str],
    ) -> Configuration: ...
    @typing.overload
    @staticmethod
    def resolveAndBind(
        moduleFinder: ModuleFinder,
        list: java.util.List[Configuration],
        moduleFinder2: ModuleFinder,
        collection: java.util.Collection[java.lang.String | str]
        | typing.Sequence[java.lang.String | str]
        | set[java.lang.String | str],
    ) -> Configuration: ...
    def toString(self) -> java.lang.String: ...

class FindException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class InvalidModuleDescriptorException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class ModuleDescriptor(java.lang.Comparable["ModuleDescriptor"]):
    def accessFlags(self) -> java.util.Set[java.lang.reflect.AccessFlag]: ...
    def compareTo(self, moduleDescriptor: ModuleDescriptor) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def exports(self) -> java.util.Set[ModuleDescriptor.Exports]: ...
    def hashCode(self) -> int: ...
    def isAutomatic(self) -> bool: ...
    def isOpen(self) -> bool: ...
    def mainClass(self) -> java.util.Optional[java.lang.String]: ...
    def modifiers(self) -> java.util.Set[ModuleDescriptor.Modifier]: ...
    def name(self) -> java.lang.String: ...
    @staticmethod
    def newAutomaticModule(
        string: java.lang.String | str,
    ) -> ModuleDescriptor.Builder: ...
    @typing.overload
    @staticmethod
    def newModule(string: java.lang.String | str) -> ModuleDescriptor.Builder: ...
    @typing.overload
    @staticmethod
    def newModule(
        string: java.lang.String | str, set: java.util.Set[ModuleDescriptor.Modifier]
    ) -> ModuleDescriptor.Builder: ...
    @staticmethod
    def newOpenModule(string: java.lang.String | str) -> ModuleDescriptor.Builder: ...
    def opens(self) -> java.util.Set[ModuleDescriptor.Opens]: ...
    def packages(self) -> java.util.Set[java.lang.String]: ...
    def provides(self) -> java.util.Set[ModuleDescriptor.Provides]: ...
    def rawVersion(self) -> java.util.Optional[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def read(inputStream: java.io.InputStream) -> ModuleDescriptor: ...
    @typing.overload
    @staticmethod
    def read(
        inputStream: java.io.InputStream,
        supplier: java.util.function.Supplier[java.util.Set[java.lang.String | str]]
        | typing.Callable[[], java.util.Set[java.lang.String | str]],
    ) -> ModuleDescriptor: ...
    @typing.overload
    @staticmethod
    def read(byteBuffer: java.nio.ByteBuffer) -> ModuleDescriptor: ...
    @typing.overload
    @staticmethod
    def read(
        byteBuffer: java.nio.ByteBuffer,
        supplier: java.util.function.Supplier[java.util.Set[java.lang.String | str]]
        | typing.Callable[[], java.util.Set[java.lang.String | str]],
    ) -> ModuleDescriptor: ...
    def requires(self) -> java.util.Set[ModuleDescriptor.Requires]: ...
    def toNameAndVersion(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def uses(self) -> java.util.Set[java.lang.String]: ...
    def version(self) -> java.util.Optional[ModuleDescriptor.Version]: ...
    class Builder:
        def build(self) -> ModuleDescriptor: ...
        @typing.overload
        def exports(
            self, string: java.lang.String | str
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def exports(
            self,
            string: java.lang.String | str,
            set: java.util.Set[java.lang.String | str],
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def exports(
            self, exports: ModuleDescriptor.Exports
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def exports(
            self,
            set: java.util.Set[ModuleDescriptor.Exports.Modifier],
            string: java.lang.String | str,
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def exports(
            self,
            set: java.util.Set[ModuleDescriptor.Exports.Modifier],
            string: java.lang.String | str,
            set2: java.util.Set[java.lang.String | str],
        ) -> ModuleDescriptor.Builder: ...
        def mainClass(
            self, string: java.lang.String | str
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def opens(self, string: java.lang.String | str) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def opens(
            self,
            string: java.lang.String | str,
            set: java.util.Set[java.lang.String | str],
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def opens(self, opens: ModuleDescriptor.Opens) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def opens(
            self,
            set: java.util.Set[ModuleDescriptor.Opens.Modifier],
            string: java.lang.String | str,
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def opens(
            self,
            set: java.util.Set[ModuleDescriptor.Opens.Modifier],
            string: java.lang.String | str,
            set2: java.util.Set[java.lang.String | str],
        ) -> ModuleDescriptor.Builder: ...
        def packages(
            self, set: java.util.Set[java.lang.String | str]
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def provides(
            self,
            string: java.lang.String | str,
            list: java.util.List[java.lang.String | str],
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def provides(
            self, provides: ModuleDescriptor.Provides
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def requires(
            self, string: java.lang.String | str
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def requires(
            self, requires: ModuleDescriptor.Requires
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def requires(
            self,
            set: java.util.Set[ModuleDescriptor.Requires.Modifier],
            string: java.lang.String | str,
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def requires(
            self,
            set: java.util.Set[ModuleDescriptor.Requires.Modifier],
            string: java.lang.String | str,
            version: ModuleDescriptor.Version,
        ) -> ModuleDescriptor.Builder: ...
        def uses(self, string: java.lang.String | str) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def version(
            self, string: java.lang.String | str
        ) -> ModuleDescriptor.Builder: ...
        @typing.overload
        def version(
            self, version: ModuleDescriptor.Version
        ) -> ModuleDescriptor.Builder: ...

    class Exports(java.lang.Comparable["ModuleDescriptor.Exports"]):
        def accessFlags(self) -> java.util.Set[java.lang.reflect.AccessFlag]: ...
        def compareTo(self, exports: ModuleDescriptor.Exports) -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isQualified(self) -> bool: ...
        def modifiers(self) -> java.util.Set[ModuleDescriptor.Exports.Modifier]: ...
        def source(self) -> java.lang.String: ...
        def targets(self) -> java.util.Set[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum["ModuleDescriptor.Exports.Modifier"]):
            SYNTHETIC: typing.ClassVar[ModuleDescriptor.Exports.Modifier] = ...
            MANDATED: typing.ClassVar[ModuleDescriptor.Exports.Modifier] = ...
            _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(
                class_: type[_valueOf_0__T], string: java.lang.String | str
            ) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(
                string: java.lang.String | str,
            ) -> ModuleDescriptor.Exports.Modifier: ...
            @staticmethod
            def values() -> typing.MutableSequence[
                ModuleDescriptor.Exports.Modifier
            ]: ...

    class Modifier(java.lang.Enum["ModuleDescriptor.Modifier"]):
        OPEN: typing.ClassVar[ModuleDescriptor.Modifier] = ...
        AUTOMATIC: typing.ClassVar[ModuleDescriptor.Modifier] = ...
        SYNTHETIC: typing.ClassVar[ModuleDescriptor.Modifier] = ...
        MANDATED: typing.ClassVar[ModuleDescriptor.Modifier] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> ModuleDescriptor.Modifier: ...
        @staticmethod
        def values() -> typing.MutableSequence[ModuleDescriptor.Modifier]: ...

    class Opens(java.lang.Comparable["ModuleDescriptor.Opens"]):
        def accessFlags(self) -> java.util.Set[java.lang.reflect.AccessFlag]: ...
        def compareTo(self, opens: ModuleDescriptor.Opens) -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isQualified(self) -> bool: ...
        def modifiers(self) -> java.util.Set[ModuleDescriptor.Opens.Modifier]: ...
        def source(self) -> java.lang.String: ...
        def targets(self) -> java.util.Set[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum["ModuleDescriptor.Opens.Modifier"]):
            SYNTHETIC: typing.ClassVar[ModuleDescriptor.Opens.Modifier] = ...
            MANDATED: typing.ClassVar[ModuleDescriptor.Opens.Modifier] = ...
            _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(
                class_: type[_valueOf_0__T], string: java.lang.String | str
            ) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(
                string: java.lang.String | str,
            ) -> ModuleDescriptor.Opens.Modifier: ...
            @staticmethod
            def values() -> typing.MutableSequence[ModuleDescriptor.Opens.Modifier]: ...

    class Provides(java.lang.Comparable["ModuleDescriptor.Provides"]):
        def compareTo(self, provides: ModuleDescriptor.Provides) -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def providers(self) -> java.util.List[java.lang.String]: ...
        def service(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...

    class Requires(java.lang.Comparable["ModuleDescriptor.Requires"]):
        def accessFlags(self) -> java.util.Set[java.lang.reflect.AccessFlag]: ...
        def compareTo(self, requires: ModuleDescriptor.Requires) -> int: ...
        def compiledVersion(self) -> java.util.Optional[ModuleDescriptor.Version]: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def modifiers(self) -> java.util.Set[ModuleDescriptor.Requires.Modifier]: ...
        def name(self) -> java.lang.String: ...
        def rawCompiledVersion(self) -> java.util.Optional[java.lang.String]: ...
        def toString(self) -> java.lang.String: ...
        class Modifier(java.lang.Enum["ModuleDescriptor.Requires.Modifier"]):
            TRANSITIVE: typing.ClassVar[ModuleDescriptor.Requires.Modifier] = ...
            STATIC: typing.ClassVar[ModuleDescriptor.Requires.Modifier] = ...
            SYNTHETIC: typing.ClassVar[ModuleDescriptor.Requires.Modifier] = ...
            MANDATED: typing.ClassVar[ModuleDescriptor.Requires.Modifier] = ...
            _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(
                class_: type[_valueOf_0__T], string: java.lang.String | str
            ) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(
                string: java.lang.String | str,
            ) -> ModuleDescriptor.Requires.Modifier: ...
            @staticmethod
            def values() -> typing.MutableSequence[
                ModuleDescriptor.Requires.Modifier
            ]: ...

    class Version(java.lang.Comparable["ModuleDescriptor.Version"]):
        def compareTo(self, version: ModuleDescriptor.Version) -> int: ...
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        @staticmethod
        def parse(string: java.lang.String | str) -> ModuleDescriptor.Version: ...
        def toString(self) -> java.lang.String: ...

class ModuleFinder:
    @staticmethod
    def compose(*moduleFinder: ModuleFinder) -> ModuleFinder: ...
    def find(
        self, string: java.lang.String | str
    ) -> java.util.Optional[ModuleReference]: ...
    def findAll(self) -> java.util.Set[ModuleReference]: ...
    @staticmethod
    def of(*path: java.nio.file.Path | jpype.protocol.SupportsPath) -> ModuleFinder: ...
    @staticmethod
    def ofSystem() -> ModuleFinder: ...

class ModuleReader(java.io.Closeable):
    def close(self) -> None: ...
    def find(
        self, string: java.lang.String | str
    ) -> java.util.Optional[java.net.URI]: ...
    def list(self) -> java.util.stream.Stream[java.lang.String]: ...
    def open(
        self, string: java.lang.String | str
    ) -> java.util.Optional[java.io.InputStream]: ...
    def read(
        self, string: java.lang.String | str
    ) -> java.util.Optional[java.nio.ByteBuffer]: ...
    def release(self, byteBuffer: java.nio.ByteBuffer) -> None: ...

class ModuleReference:
    def descriptor(self) -> ModuleDescriptor: ...
    def location(self) -> java.util.Optional[java.net.URI]: ...
    def open(self) -> ModuleReader: ...

class ResolutionException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class ResolvedModule:
    def configuration(self) -> Configuration: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def name(self) -> java.lang.String: ...
    def reads(self) -> java.util.Set[ResolvedModule]: ...
    def reference(self) -> ModuleReference: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.lang.module")``.

    Configuration: type[Configuration]
    FindException: type[FindException]
    InvalidModuleDescriptorException: type[InvalidModuleDescriptorException]
    ModuleDescriptor: type[ModuleDescriptor]
    ModuleFinder: type[ModuleFinder]
    ModuleReader: type[ModuleReader]
    ModuleReference: type[ModuleReference]
    ResolutionException: type[ResolutionException]
    ResolvedModule: type[ResolvedModule]
