import typing
from typing import Protocol

import java
import java.lang
import java.lang.invoke
import java.nio
import java.nio.charset
import java.nio.file
import java.util
import java.util.function
import java.util.stream
import jpype
import jpype.protocol

class FunctionDescriptor:
    def appendArgumentLayouts(
        self, *memoryLayout: MemoryLayout
    ) -> FunctionDescriptor: ...
    def argumentLayouts(self) -> java.util.List[MemoryLayout]: ...
    def changeReturnLayout(self, memoryLayout: MemoryLayout) -> FunctionDescriptor: ...
    def dropReturnLayout(self) -> FunctionDescriptor: ...
    def insertArgumentLayouts(
        self, int: int, *memoryLayout: MemoryLayout
    ) -> FunctionDescriptor: ...
    @staticmethod
    def of(
        memoryLayout: MemoryLayout, *memoryLayout2: MemoryLayout
    ) -> FunctionDescriptor: ...
    @staticmethod
    def ofVoid(*memoryLayout: MemoryLayout) -> FunctionDescriptor: ...
    def returnLayout(self) -> java.util.Optional[MemoryLayout]: ...
    def toMethodType(self) -> java.lang.invoke.MethodType: ...

class Linker:
    def canonicalLayouts(self) -> java.util.Map[java.lang.String, MemoryLayout]: ...
    def defaultLookup(self) -> SymbolLookup: ...
    @typing.overload
    def downcallHandle(
        self, functionDescriptor: FunctionDescriptor, *option: Linker.Option
    ) -> java.lang.invoke.MethodHandle: ...
    @typing.overload
    def downcallHandle(
        self,
        memorySegment: MemorySegment,
        functionDescriptor: FunctionDescriptor,
        *option: Linker.Option,
    ) -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def nativeLinker() -> Linker: ...
    def upcallStub(
        self,
        methodHandle: java.lang.invoke.MethodHandle,
        functionDescriptor: FunctionDescriptor,
        arena: Arena,
        *option: Linker.Option,
    ) -> MemorySegment: ...
    class Option:
        @staticmethod
        def captureCallState(*string: java.lang.String | str) -> Linker.Option: ...
        @staticmethod
        def captureStateLayout() -> StructLayout: ...
        @staticmethod
        def critical(boolean: bool) -> Linker.Option: ...
        @staticmethod
        def firstVariadicArg(int: int) -> Linker.Option: ...

class MemoryLayout:
    def arrayElementVarHandle(
        self, *pathElement: MemoryLayout.PathElement
    ) -> java.lang.invoke.VarHandle: ...
    def byteAlignment(self) -> int: ...
    def byteOffset(self, *pathElement: MemoryLayout.PathElement) -> int: ...
    def byteOffsetHandle(
        self, *pathElement: MemoryLayout.PathElement
    ) -> java.lang.invoke.MethodHandle: ...
    def byteSize(self) -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def name(self) -> java.util.Optional[java.lang.String]: ...
    @staticmethod
    def paddingLayout(long: int) -> PaddingLayout: ...
    def scale(self, long: int, long2: int) -> int: ...
    def scaleHandle(self) -> java.lang.invoke.MethodHandle: ...
    def select(self, *pathElement: MemoryLayout.PathElement) -> MemoryLayout: ...
    @staticmethod
    def sequenceLayout(long: int, memoryLayout: MemoryLayout) -> SequenceLayout: ...
    def sliceHandle(
        self, *pathElement: MemoryLayout.PathElement
    ) -> java.lang.invoke.MethodHandle: ...
    @staticmethod
    def structLayout(*memoryLayout: MemoryLayout) -> StructLayout: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def unionLayout(*memoryLayout: MemoryLayout) -> UnionLayout: ...
    def varHandle(
        self, *pathElement: MemoryLayout.PathElement
    ) -> java.lang.invoke.VarHandle: ...
    def withByteAlignment(self, long: int) -> MemoryLayout: ...
    def withName(self, string: java.lang.String | str) -> MemoryLayout: ...
    def withoutName(self) -> MemoryLayout: ...
    class PathElement:
        @staticmethod
        def dereferenceElement() -> MemoryLayout.PathElement: ...
        @typing.overload
        @staticmethod
        def groupElement(
            string: java.lang.String | str,
        ) -> MemoryLayout.PathElement: ...
        @typing.overload
        @staticmethod
        def groupElement(long: int) -> MemoryLayout.PathElement: ...
        @typing.overload
        @staticmethod
        def sequenceElement() -> MemoryLayout.PathElement: ...
        @typing.overload
        @staticmethod
        def sequenceElement(long: int) -> MemoryLayout.PathElement: ...
        @typing.overload
        @staticmethod
        def sequenceElement(long: int, long2: int) -> MemoryLayout.PathElement: ...

class MemorySegment:
    NULL: typing.ClassVar[MemorySegment] = ...
    def address(self) -> int: ...
    def asByteBuffer(self) -> java.nio.ByteBuffer: ...
    def asOverlappingSlice(
        self, memorySegment: MemorySegment
    ) -> java.util.Optional[MemorySegment]: ...
    def asReadOnly(self) -> MemorySegment: ...
    @typing.overload
    def asSlice(self, long: int) -> MemorySegment: ...
    @typing.overload
    def asSlice(self, long: int, memoryLayout: MemoryLayout) -> MemorySegment: ...
    @typing.overload
    def asSlice(self, long: int, long2: int) -> MemorySegment: ...
    @typing.overload
    def asSlice(self, long: int, long2: int, long3: int) -> MemorySegment: ...
    def byteSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def copy(
        object: typing.Any,
        int: int,
        memorySegment: MemorySegment,
        valueLayout: ValueLayout,
        long: int,
        int2: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def copy(
        memorySegment: MemorySegment,
        valueLayout: ValueLayout,
        long: int,
        object: typing.Any,
        int: int,
        int2: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def copy(
        memorySegment: MemorySegment,
        valueLayout: ValueLayout,
        long: int,
        memorySegment2: MemorySegment,
        valueLayout2: ValueLayout,
        long2: int,
        long3: int,
    ) -> None: ...
    @typing.overload
    @staticmethod
    def copy(
        memorySegment: MemorySegment,
        long: int,
        memorySegment2: MemorySegment,
        long2: int,
        long3: int,
    ) -> None: ...
    def copyFrom(self, memorySegment: MemorySegment) -> MemorySegment: ...
    def elements(
        self, memoryLayout: MemoryLayout
    ) -> java.util.stream.Stream[MemorySegment]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def fill(self, byte: int) -> MemorySegment: ...
    def force(self) -> None: ...
    @typing.overload
    def get(self, ofBoolean: ValueLayout.OfBoolean, long: int) -> bool: ...
    @typing.overload
    def get(self, ofByte: ValueLayout.OfByte, long: int) -> int: ...
    @typing.overload
    def get(self, ofChar: ValueLayout.OfChar, long: int) -> str: ...
    @typing.overload
    def get(self, ofDouble: ValueLayout.OfDouble, long: int) -> float: ...
    @typing.overload
    def get(self, ofFloat: ValueLayout.OfFloat, long: int) -> float: ...
    @typing.overload
    def get(self, ofInt: ValueLayout.OfInt, long: int) -> int: ...
    @typing.overload
    def get(self, addressLayout: AddressLayout, long: int) -> MemorySegment: ...
    @typing.overload
    def get(self, ofLong: ValueLayout.OfLong, long: int) -> int: ...
    @typing.overload
    def get(self, ofShort: ValueLayout.OfShort, long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofBoolean: ValueLayout.OfBoolean, long: int) -> bool: ...
    @typing.overload
    def getAtIndex(self, ofByte: ValueLayout.OfByte, long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofChar: ValueLayout.OfChar, long: int) -> str: ...
    @typing.overload
    def getAtIndex(self, ofDouble: ValueLayout.OfDouble, long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofFloat: ValueLayout.OfFloat, long: int) -> float: ...
    @typing.overload
    def getAtIndex(self, ofInt: ValueLayout.OfInt, long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, addressLayout: AddressLayout, long: int) -> MemorySegment: ...
    @typing.overload
    def getAtIndex(self, ofLong: ValueLayout.OfLong, long: int) -> int: ...
    @typing.overload
    def getAtIndex(self, ofShort: ValueLayout.OfShort, long: int) -> int: ...
    @typing.overload
    def getString(self, long: int) -> java.lang.String: ...
    @typing.overload
    def getString(
        self, long: int, charset: java.nio.charset.Charset
    ) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def heapBase(self) -> java.util.Optional[typing.Any]: ...
    def isAccessibleBy(self, thread: java.lang.Thread) -> bool: ...
    def isLoaded(self) -> bool: ...
    def isMapped(self) -> bool: ...
    def isNative(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def load(self) -> None: ...
    def maxByteAlignment(self) -> int: ...
    @typing.overload
    def mismatch(self, memorySegment: MemorySegment) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(
        memorySegment: MemorySegment,
        long: int,
        long2: int,
        memorySegment2: MemorySegment,
        long3: int,
        long4: int,
    ) -> int: ...
    @staticmethod
    def ofAddress(long: int) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(byteArray: list[int] | jpype.JArray | bytes) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(charArray: list[str] | jpype.JArray) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(doubleArray: list[float] | jpype.JArray) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(floatArray: list[float] | jpype.JArray) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(intArray: list[int] | jpype.JArray) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(longArray: list[int] | jpype.JArray) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def ofArray(shortArray: list[int] | jpype.JArray) -> MemorySegment: ...
    @staticmethod
    def ofBuffer(buffer: java.nio.Buffer) -> MemorySegment: ...
    @typing.overload
    def reinterpret(
        self,
        arena: Arena,
        consumer: java.util.function.Consumer[MemorySegment]
        | typing.Callable[[MemorySegment], None],
    ) -> MemorySegment: ...
    @typing.overload
    def reinterpret(self, long: int) -> MemorySegment: ...
    @typing.overload
    def reinterpret(
        self,
        long: int,
        arena: Arena,
        consumer: java.util.function.Consumer[MemorySegment]
        | typing.Callable[[MemorySegment], None],
    ) -> MemorySegment: ...
    def scope(self) -> MemorySegment.Scope: ...
    @typing.overload
    def set(
        self, addressLayout: AddressLayout, long: int, memorySegment: MemorySegment
    ) -> None: ...
    @typing.overload
    def set(
        self, ofBoolean: ValueLayout.OfBoolean, long: int, boolean: bool
    ) -> None: ...
    @typing.overload
    def set(self, ofByte: ValueLayout.OfByte, long: int, byte: int) -> None: ...
    @typing.overload
    def set(self, ofChar: ValueLayout.OfChar, long: int, char: str) -> None: ...
    @typing.overload
    def set(self, ofDouble: ValueLayout.OfDouble, long: int, double: float) -> None: ...
    @typing.overload
    def set(self, ofFloat: ValueLayout.OfFloat, long: int, float: float) -> None: ...
    @typing.overload
    def set(self, ofInt: ValueLayout.OfInt, long: int, int: int) -> None: ...
    @typing.overload
    def set(self, ofLong: ValueLayout.OfLong, long: int, long2: int) -> None: ...
    @typing.overload
    def set(self, ofShort: ValueLayout.OfShort, long: int, short: int) -> None: ...
    @typing.overload
    def setAtIndex(
        self, addressLayout: AddressLayout, long: int, memorySegment: MemorySegment
    ) -> None: ...
    @typing.overload
    def setAtIndex(
        self, ofBoolean: ValueLayout.OfBoolean, long: int, boolean: bool
    ) -> None: ...
    @typing.overload
    def setAtIndex(self, ofByte: ValueLayout.OfByte, long: int, byte: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofChar: ValueLayout.OfChar, long: int, char: str) -> None: ...
    @typing.overload
    def setAtIndex(
        self, ofDouble: ValueLayout.OfDouble, long: int, double: float
    ) -> None: ...
    @typing.overload
    def setAtIndex(
        self, ofFloat: ValueLayout.OfFloat, long: int, float: float
    ) -> None: ...
    @typing.overload
    def setAtIndex(self, ofInt: ValueLayout.OfInt, long: int, int: int) -> None: ...
    @typing.overload
    def setAtIndex(self, ofLong: ValueLayout.OfLong, long: int, long2: int) -> None: ...
    @typing.overload
    def setAtIndex(
        self, ofShort: ValueLayout.OfShort, long: int, short: int
    ) -> None: ...
    @typing.overload
    def setString(self, long: int, string: java.lang.String | str) -> None: ...
    @typing.overload
    def setString(
        self,
        long: int,
        string: java.lang.String | str,
        charset: java.nio.charset.Charset,
    ) -> None: ...
    def spliterator(
        self, memoryLayout: MemoryLayout
    ) -> java.util.Spliterator[MemorySegment]: ...
    @typing.overload
    def toArray(self, ofByte: ValueLayout.OfByte) -> typing.MutableSequence[int]: ...
    @typing.overload
    def toArray(self, ofChar: ValueLayout.OfChar) -> typing.MutableSequence[str]: ...
    @typing.overload
    def toArray(
        self, ofDouble: ValueLayout.OfDouble
    ) -> typing.MutableSequence[float]: ...
    @typing.overload
    def toArray(
        self, ofFloat: ValueLayout.OfFloat
    ) -> typing.MutableSequence[float]: ...
    @typing.overload
    def toArray(self, ofInt: ValueLayout.OfInt) -> typing.MutableSequence[int]: ...
    @typing.overload
    def toArray(self, ofLong: ValueLayout.OfLong) -> typing.MutableSequence[int]: ...
    @typing.overload
    def toArray(self, ofShort: ValueLayout.OfShort) -> typing.MutableSequence[int]: ...
    def unload(self) -> None: ...
    class Scope:
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def isAlive(self) -> bool: ...

class SegmentAllocator:
    @typing.overload
    def allocate(self, long: int, long2: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout) -> MemorySegment: ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout, long: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, long: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, string: java.lang.String | str) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, string: java.lang.String | str, charset: java.nio.charset.Charset
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, addressLayout: AddressLayout, memorySegment: MemorySegment
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofByte: ValueLayout.OfByte, byte: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofByte: ValueLayout.OfByte, *byte: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofChar: ValueLayout.OfChar, char: str) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofChar: ValueLayout.OfChar, *char: str) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofDouble: ValueLayout.OfDouble, double: float
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofDouble: ValueLayout.OfDouble, *double: float
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofFloat: ValueLayout.OfFloat, float: float
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofFloat: ValueLayout.OfFloat, *float: float
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofInt: ValueLayout.OfInt, int: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofInt: ValueLayout.OfInt, *int: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofLong: ValueLayout.OfLong, long: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(self, ofLong: ValueLayout.OfLong, *long: int) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofShort: ValueLayout.OfShort, short: int
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self, ofShort: ValueLayout.OfShort, *short: int
    ) -> MemorySegment: ...
    @typing.overload
    def allocateFrom(
        self,
        valueLayout: ValueLayout,
        memorySegment: MemorySegment,
        valueLayout2: ValueLayout,
        long: int,
        long2: int,
    ) -> MemorySegment: ...
    @staticmethod
    def prefixAllocator(memorySegment: MemorySegment) -> SegmentAllocator: ...
    @staticmethod
    def slicingAllocator(memorySegment: MemorySegment) -> SegmentAllocator: ...

class SymbolLookup:
    def find(
        self, string: java.lang.String | str
    ) -> java.util.Optional[MemorySegment]: ...
    def findOrThrow(self, string: java.lang.String | str) -> MemorySegment: ...
    @typing.overload
    @staticmethod
    def libraryLookup(string: java.lang.String | str, arena: Arena) -> SymbolLookup: ...
    @typing.overload
    @staticmethod
    def libraryLookup(
        path: java.nio.file.Path | jpype.protocol.SupportsPath, arena: Arena
    ) -> SymbolLookup: ...
    @staticmethod
    def loaderLookup() -> SymbolLookup: ...
    def or_(self, symbolLookup: SymbolLookup | typing.Callable) -> SymbolLookup: ...

class Arena(SegmentAllocator, java.lang.AutoCloseable):
    @typing.overload
    def allocate(self, long: int, long2: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout) -> MemorySegment: ...
    @typing.overload
    def allocate(self, memoryLayout: MemoryLayout, long: int) -> MemorySegment: ...
    @typing.overload
    def allocate(self, long: int) -> MemorySegment: ...
    def close(self) -> None: ...
    @staticmethod
    def global_() -> Arena: ...
    @staticmethod
    def ofAuto() -> Arena: ...
    @staticmethod
    def ofConfined() -> Arena: ...
    @staticmethod
    def ofShared() -> Arena: ...
    def scope(self) -> MemorySegment.Scope: ...

class GroupLayout(MemoryLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def memberLayouts(self) -> java.util.List[MemoryLayout]: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> GroupLayout: ...
    def withName(self, string: java.lang.String | str) -> GroupLayout: ...
    def withoutName(self) -> GroupLayout: ...

class PaddingLayout(MemoryLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> PaddingLayout: ...
    def withName(self, string: java.lang.String | str) -> PaddingLayout: ...
    def withoutName(self) -> PaddingLayout: ...

class SequenceLayout(MemoryLayout):
    def elementCount(self) -> int: ...
    def elementLayout(self) -> MemoryLayout: ...
    def equals(self, object: typing.Any) -> bool: ...
    def flatten(self) -> SequenceLayout: ...
    def hashCode(self) -> int: ...
    def reshape(self, *long: int) -> SequenceLayout: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> SequenceLayout: ...
    def withElementCount(self, long: int) -> SequenceLayout: ...
    def withName(self, string: java.lang.String | str) -> SequenceLayout: ...
    def withoutName(self) -> MemoryLayout: ...

class StructLayout(GroupLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> StructLayout: ...
    def withName(self, string: java.lang.String | str) -> StructLayout: ...
    def withoutName(self) -> StructLayout: ...

class UnionLayout(GroupLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> UnionLayout: ...
    def withName(self, string: java.lang.String | str) -> UnionLayout: ...
    def withoutName(self) -> UnionLayout: ...

class AddressLayout(java.lang.foreign.ValueLayout):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def targetLayout(self) -> java.util.Optional[MemoryLayout]: ...
    def toString(self) -> java.lang.String: ...
    def withByteAlignment(self, long: int) -> AddressLayout: ...
    def withName(self, string: java.lang.String | str) -> AddressLayout: ...
    def withOrder(self, byteOrder: java.nio.ByteOrder) -> AddressLayout: ...
    def withTargetLayout(self, memoryLayout: MemoryLayout) -> AddressLayout: ...
    def withoutName(self) -> AddressLayout: ...
    def withoutTargetLayout(self) -> AddressLayout: ...

class ValueLayout(MemoryLayout):
    ADDRESS: typing.ClassVar[AddressLayout] = ...
    JAVA_BYTE: typing.ClassVar[ValueLayout.OfByte] = ...
    JAVA_BOOLEAN: typing.ClassVar[ValueLayout.OfBoolean] = ...
    JAVA_CHAR: typing.ClassVar[ValueLayout.OfChar] = ...
    JAVA_SHORT: typing.ClassVar[ValueLayout.OfShort] = ...
    JAVA_INT: typing.ClassVar[ValueLayout.OfInt] = ...
    JAVA_LONG: typing.ClassVar[ValueLayout.OfLong] = ...
    JAVA_FLOAT: typing.ClassVar[ValueLayout.OfFloat] = ...
    JAVA_DOUBLE: typing.ClassVar[ValueLayout.OfDouble] = ...
    ADDRESS_UNALIGNED: typing.ClassVar[AddressLayout] = ...
    JAVA_CHAR_UNALIGNED: typing.ClassVar[ValueLayout.OfChar] = ...
    JAVA_SHORT_UNALIGNED: typing.ClassVar[ValueLayout.OfShort] = ...
    JAVA_INT_UNALIGNED: typing.ClassVar[ValueLayout.OfInt] = ...
    JAVA_LONG_UNALIGNED: typing.ClassVar[ValueLayout.OfLong] = ...
    JAVA_FLOAT_UNALIGNED: typing.ClassVar[ValueLayout.OfFloat] = ...
    JAVA_DOUBLE_UNALIGNED: typing.ClassVar[ValueLayout.OfDouble] = ...
    def carrier(self) -> type[typing.Any]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def order(self) -> java.nio.ByteOrder: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def varHandle(
        self, *pathElement: MemoryLayout.PathElement
    ) -> java.lang.invoke.VarHandle: ...
    @typing.overload
    def varHandle(self) -> java.lang.invoke.VarHandle: ...
    def withByteAlignment(self, long: int) -> ValueLayout: ...
    def withName(self, string: java.lang.String | str) -> ValueLayout: ...
    def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout: ...
    def withoutName(self) -> ValueLayout: ...
    class OfBoolean(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfBoolean: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfBoolean: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfBoolean: ...
        def withoutName(self) -> ValueLayout.OfBoolean: ...

    class OfByte(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfByte: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfByte: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfByte: ...
        def withoutName(self) -> ValueLayout.OfByte: ...

    class OfChar(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfChar: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfChar: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfChar: ...
        def withoutName(self) -> ValueLayout.OfChar: ...

    class OfDouble(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfDouble: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfDouble: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfDouble: ...
        def withoutName(self) -> ValueLayout.OfDouble: ...

    class OfFloat(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfFloat: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfFloat: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfFloat: ...
        def withoutName(self) -> ValueLayout.OfFloat: ...

    class OfInt(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfInt: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfInt: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfInt: ...
        def withoutName(self) -> ValueLayout.OfInt: ...

    class OfLong(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfLong: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfLong: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfLong: ...
        def withoutName(self) -> ValueLayout.OfLong: ...

    class OfShort(java.lang.foreign.ValueLayout):
        def equals(self, object: typing.Any) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> java.lang.String: ...
        def withByteAlignment(self, long: int) -> ValueLayout.OfShort: ...
        def withName(self, string: java.lang.String | str) -> ValueLayout.OfShort: ...
        def withOrder(self, byteOrder: java.nio.ByteOrder) -> ValueLayout.OfShort: ...
        def withoutName(self) -> ValueLayout.OfShort: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.lang.foreign")``.

    AddressLayout: type[AddressLayout]
    Arena: type[Arena]
    FunctionDescriptor: type[FunctionDescriptor]
    GroupLayout: type[GroupLayout]
    Linker: type[Linker]
    MemoryLayout: type[MemoryLayout]
    MemorySegment: type[MemorySegment]
    PaddingLayout: type[PaddingLayout]
    SegmentAllocator: type[SegmentAllocator]
    SequenceLayout: type[SequenceLayout]
    StructLayout: type[StructLayout]
    SymbolLookup: type[SymbolLookup]
    UnionLayout: type[UnionLayout]
    ValueLayout: type[ValueLayout]
