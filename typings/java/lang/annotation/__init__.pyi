import typing
from typing import Protocol

import java.lang
import java.lang.reflect

class Annotation:
    def annotationType(self) -> type[Annotation]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class AnnotationFormatError(java.lang.Error):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class AnnotationTypeMismatchException(java.lang.RuntimeException):
    def __init__(
        self, method: java.lang.reflect.Method, string: java.lang.String | str
    ): ...
    def element(self) -> java.lang.reflect.Method: ...
    def foundType(self) -> java.lang.String: ...

class ElementType(java.lang.Enum["ElementType"]):
    TYPE: typing.ClassVar[ElementType] = ...
    FIELD: typing.ClassVar[ElementType] = ...
    METHOD: typing.ClassVar[ElementType] = ...
    PARAMETER: typing.ClassVar[ElementType] = ...
    CONSTRUCTOR: typing.ClassVar[ElementType] = ...
    LOCAL_VARIABLE: typing.ClassVar[ElementType] = ...
    ANNOTATION_TYPE: typing.ClassVar[ElementType] = ...
    PACKAGE: typing.ClassVar[ElementType] = ...
    TYPE_PARAMETER: typing.ClassVar[ElementType] = ...
    TYPE_USE: typing.ClassVar[ElementType] = ...
    MODULE: typing.ClassVar[ElementType] = ...
    RECORD_COMPONENT: typing.ClassVar[ElementType] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: type[_valueOf_0__T], string: java.lang.String | str
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: java.lang.String | str) -> ElementType: ...
    @staticmethod
    def values() -> typing.MutableSequence[ElementType]: ...

class IncompleteAnnotationException(java.lang.RuntimeException):
    def __init__(self, class_: type[Annotation], string: java.lang.String | str): ...
    def annotationType(self) -> type[Annotation]: ...
    def elementName(self) -> java.lang.String: ...

class RetentionPolicy(java.lang.Enum["RetentionPolicy"]):
    SOURCE: typing.ClassVar[RetentionPolicy] = ...
    CLASS: typing.ClassVar[RetentionPolicy] = ...
    RUNTIME: typing.ClassVar[RetentionPolicy] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: type[_valueOf_0__T], string: java.lang.String | str
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: java.lang.String | str) -> RetentionPolicy: ...
    @staticmethod
    def values() -> typing.MutableSequence[RetentionPolicy]: ...

class Documented(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class Inherited(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class Native(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class Repeatable(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> type[Annotation]: ...

class Retention(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> RetentionPolicy: ...

class Target(Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def value(self) -> typing.MutableSequence[ElementType]: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.lang.annotation")``.

    Annotation: type[Annotation]
    AnnotationFormatError: type[AnnotationFormatError]
    AnnotationTypeMismatchException: type[AnnotationTypeMismatchException]
    Documented: type[Documented]
    ElementType: type[ElementType]
    IncompleteAnnotationException: type[IncompleteAnnotationException]
    Inherited: type[Inherited]
    Native: type[Native]
    Repeatable: type[Repeatable]
    Retention: type[Retention]
    RetentionPolicy: type[RetentionPolicy]
    Target: type[Target]
