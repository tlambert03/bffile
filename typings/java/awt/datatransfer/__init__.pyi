import typing
from typing import Protocol

import java.io
import java.lang
import java.util
import jpype

class Clipboard:
    def __init__(self, string: java.lang.String | str): ...
    def addFlavorListener(
        self, flavorListener: FlavorListener | typing.Callable
    ) -> None: ...
    def getAvailableDataFlavors(self) -> typing.MutableSequence[DataFlavor]: ...
    def getContents(self, object: typing.Any) -> Transferable: ...
    def getData(self, dataFlavor: DataFlavor) -> typing.Any: ...
    def getFlavorListeners(self) -> typing.MutableSequence[FlavorListener]: ...
    def getName(self) -> java.lang.String: ...
    def isDataFlavorAvailable(self, dataFlavor: DataFlavor) -> bool: ...
    def removeFlavorListener(
        self, flavorListener: FlavorListener | typing.Callable
    ) -> None: ...
    def setContents(
        self,
        transferable: Transferable,
        clipboardOwner: ClipboardOwner | typing.Callable,
    ) -> None: ...

class ClipboardOwner:
    def lostOwnership(
        self, clipboard: Clipboard, transferable: Transferable
    ) -> None: ...

class DataFlavor(java.io.Externalizable, java.lang.Cloneable):
    stringFlavor: typing.ClassVar[DataFlavor] = ...
    imageFlavor: typing.ClassVar[DataFlavor] = ...
    plainTextFlavor: typing.ClassVar[DataFlavor] = ...
    javaSerializedObjectMimeType: typing.ClassVar[java.lang.String] = ...
    javaFileListFlavor: typing.ClassVar[DataFlavor] = ...
    javaJVMLocalObjectMimeType: typing.ClassVar[java.lang.String] = ...
    javaRemoteObjectMimeType: typing.ClassVar[java.lang.String] = ...
    selectionHtmlFlavor: typing.ClassVar[DataFlavor] = ...
    fragmentHtmlFlavor: typing.ClassVar[DataFlavor] = ...
    allHtmlFlavor: typing.ClassVar[DataFlavor] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, class_: type[typing.Any], string: java.lang.String | str): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        classLoader: java.lang.ClassLoader,
    ): ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    def equals(self, dataFlavor: DataFlavor) -> bool: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, string: java.lang.String | str) -> bool: ...
    def getDefaultRepresentationClass(self) -> type[typing.Any]: ...
    def getDefaultRepresentationClassAsString(self) -> java.lang.String: ...
    def getHumanPresentableName(self) -> java.lang.String: ...
    def getMimeType(self) -> java.lang.String: ...
    def getParameter(self, string: java.lang.String | str) -> java.lang.String: ...
    def getPrimaryType(self) -> java.lang.String: ...
    def getReaderForText(self, transferable: Transferable) -> java.io.Reader: ...
    def getRepresentationClass(self) -> type[typing.Any]: ...
    def getSubType(self) -> java.lang.String: ...
    @staticmethod
    def getTextPlainUnicodeFlavor() -> DataFlavor: ...
    def hashCode(self) -> int: ...
    def isFlavorJavaFileListType(self) -> bool: ...
    def isFlavorRemoteObjectType(self) -> bool: ...
    def isFlavorSerializedObjectType(self) -> bool: ...
    def isFlavorTextType(self) -> bool: ...
    @typing.overload
    def isMimeTypeEqual(self, string: java.lang.String | str) -> bool: ...
    @typing.overload
    def isMimeTypeEqual(self, dataFlavor: DataFlavor) -> bool: ...
    def isMimeTypeSerializedObject(self) -> bool: ...
    def isRepresentationClassByteBuffer(self) -> bool: ...
    def isRepresentationClassCharBuffer(self) -> bool: ...
    def isRepresentationClassInputStream(self) -> bool: ...
    def isRepresentationClassReader(self) -> bool: ...
    def isRepresentationClassRemote(self) -> bool: ...
    def isRepresentationClassSerializable(self) -> bool: ...
    def match(self, dataFlavor: DataFlavor) -> bool: ...
    def readExternal(self, objectInput: java.io.ObjectInput) -> None: ...
    @staticmethod
    def selectBestTextFlavor(
        dataFlavorArray: list[DataFlavor] | jpype.JArray,
    ) -> DataFlavor: ...
    def setHumanPresentableName(self, string: java.lang.String | str) -> None: ...
    def toString(self) -> java.lang.String: ...
    def writeExternal(self, objectOutput: java.io.ObjectOutput) -> None: ...

class FlavorEvent(java.util.EventObject):
    def __init__(self, clipboard: Clipboard): ...

class FlavorListener(java.util.EventListener):
    def flavorsChanged(self, flavorEvent: FlavorEvent) -> None: ...

class FlavorMap:
    def getFlavorsForNatives(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> java.util.Map[java.lang.String, DataFlavor]: ...
    def getNativesForFlavors(
        self, dataFlavorArray: list[DataFlavor] | jpype.JArray
    ) -> java.util.Map[DataFlavor, java.lang.String]: ...

class MimeTypeParseException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class Transferable:
    def getTransferData(self, dataFlavor: DataFlavor) -> typing.Any: ...
    def getTransferDataFlavors(self) -> typing.MutableSequence[DataFlavor]: ...
    def isDataFlavorSupported(self, dataFlavor: DataFlavor) -> bool: ...

class UnsupportedFlavorException(java.lang.Exception):
    def __init__(self, dataFlavor: DataFlavor): ...

class FlavorTable(FlavorMap):
    def getFlavorsForNative(
        self, string: java.lang.String | str
    ) -> java.util.List[DataFlavor]: ...
    def getNativesForFlavor(
        self, dataFlavor: DataFlavor
    ) -> java.util.List[java.lang.String]: ...

class StringSelection(Transferable, ClipboardOwner):
    def __init__(self, string: java.lang.String | str): ...
    def getTransferData(self, dataFlavor: DataFlavor) -> typing.Any: ...
    def getTransferDataFlavors(self) -> typing.MutableSequence[DataFlavor]: ...
    def isDataFlavorSupported(self, dataFlavor: DataFlavor) -> bool: ...
    def lostOwnership(
        self, clipboard: Clipboard, transferable: Transferable
    ) -> None: ...

class SystemFlavorMap(FlavorMap, FlavorTable):
    def addFlavorForUnencodedNative(
        self, string: java.lang.String | str, dataFlavor: DataFlavor
    ) -> None: ...
    def addUnencodedNativeForFlavor(
        self, dataFlavor: DataFlavor, string: java.lang.String | str
    ) -> None: ...
    @staticmethod
    def decodeDataFlavor(string: java.lang.String | str) -> DataFlavor: ...
    @staticmethod
    def decodeJavaMIMEType(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def encodeDataFlavor(dataFlavor: DataFlavor) -> java.lang.String: ...
    @staticmethod
    def encodeJavaMIMEType(string: java.lang.String | str) -> java.lang.String: ...
    @staticmethod
    def getDefaultFlavorMap() -> FlavorMap: ...
    def getFlavorsForNative(
        self, string: java.lang.String | str
    ) -> java.util.List[DataFlavor]: ...
    def getFlavorsForNatives(
        self, stringArray: list[java.lang.String] | jpype.JArray
    ) -> java.util.Map[java.lang.String, DataFlavor]: ...
    def getNativesForFlavor(
        self, dataFlavor: DataFlavor
    ) -> java.util.List[java.lang.String]: ...
    def getNativesForFlavors(
        self, dataFlavorArray: list[DataFlavor] | jpype.JArray
    ) -> java.util.Map[DataFlavor, java.lang.String]: ...
    @staticmethod
    def isJavaMIMEType(string: java.lang.String | str) -> bool: ...
    def setFlavorsForNative(
        self,
        string: java.lang.String | str,
        dataFlavorArray: list[DataFlavor] | jpype.JArray,
    ) -> None: ...
    def setNativesForFlavor(
        self, dataFlavor: DataFlavor, stringArray: list[java.lang.String] | jpype.JArray
    ) -> None: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.awt.datatransfer")``.

    Clipboard: type[Clipboard]
    ClipboardOwner: type[ClipboardOwner]
    DataFlavor: type[DataFlavor]
    FlavorEvent: type[FlavorEvent]
    FlavorListener: type[FlavorListener]
    FlavorMap: type[FlavorMap]
    FlavorTable: type[FlavorTable]
    MimeTypeParseException: type[MimeTypeParseException]
    StringSelection: type[StringSelection]
    SystemFlavorMap: type[SystemFlavorMap]
    Transferable: type[Transferable]
    UnsupportedFlavorException: type[UnsupportedFlavorException]
