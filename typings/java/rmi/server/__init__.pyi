import typing
from typing import Protocol

import java.io
import java.lang
import java.lang.reflect
import java.net
import java.rmi
import jpype

class ExportException(java.rmi.RemoteException):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, exception: java.lang.Exception
    ): ...

class LoaderHandler:
    packagePrefix: typing.ClassVar[java.lang.String] = ...
    def getSecurityContext(self, classLoader: java.lang.ClassLoader) -> typing.Any: ...
    @typing.overload
    def loadClass(self, string: java.lang.String | str) -> type[typing.Any]: ...
    @typing.overload
    def loadClass(
        self, uRL: java.net.URL, string: java.lang.String | str
    ) -> type[typing.Any]: ...

class LogStream(java.io.PrintStream):
    SILENT: typing.ClassVar[int] = ...
    BRIEF: typing.ClassVar[int] = ...
    VERBOSE: typing.ClassVar[int] = ...
    @staticmethod
    def getDefaultStream() -> java.io.PrintStream: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    @staticmethod
    def log(string: java.lang.String | str) -> LogStream: ...
    @staticmethod
    def parseLevel(string: java.lang.String | str) -> int: ...
    @staticmethod
    def setDefaultStream(printStream: java.io.PrintStream) -> None: ...
    def setOutputStream(self, outputStream: java.io.OutputStream) -> None: ...
    def toString(self) -> java.lang.String: ...
    @typing.overload
    def write(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def write(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    @typing.overload
    def write(self, int: int) -> None: ...

class ObjID(java.io.Serializable):
    REGISTRY_ID: typing.ClassVar[int] = ...
    ACTIVATOR_ID: typing.ClassVar[int] = ...
    DGC_ID: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def read(objectInput: java.io.ObjectInput) -> ObjID: ...
    def toString(self) -> java.lang.String: ...
    def write(self, objectOutput: java.io.ObjectOutput) -> None: ...

class Operation:
    def __init__(self, string: java.lang.String | str): ...
    def getOperation(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class RMIClassLoader:
    @staticmethod
    def getClassAnnotation(class_: type[typing.Any]) -> java.lang.String: ...
    @staticmethod
    def getClassLoader(string: java.lang.String | str) -> java.lang.ClassLoader: ...
    @staticmethod
    def getDefaultProviderInstance() -> RMIClassLoaderSpi: ...
    @staticmethod
    def getSecurityContext(classLoader: java.lang.ClassLoader) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def loadClass(string: java.lang.String | str) -> type[typing.Any]: ...
    @typing.overload
    @staticmethod
    def loadClass(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> type[typing.Any]: ...
    @typing.overload
    @staticmethod
    def loadClass(
        string: java.lang.String | str,
        string2: java.lang.String | str,
        classLoader: java.lang.ClassLoader,
    ) -> type[typing.Any]: ...
    @typing.overload
    @staticmethod
    def loadClass(
        uRL: java.net.URL, string: java.lang.String | str
    ) -> type[typing.Any]: ...
    @staticmethod
    def loadProxyClass(
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        classLoader: java.lang.ClassLoader,
    ) -> type[typing.Any]: ...

class RMIClassLoaderSpi:
    def __init__(self): ...
    def getClassAnnotation(self, class_: type[typing.Any]) -> java.lang.String: ...
    def getClassLoader(
        self, string: java.lang.String | str
    ) -> java.lang.ClassLoader: ...
    def loadClass(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        classLoader: java.lang.ClassLoader,
    ) -> type[typing.Any]: ...
    def loadProxyClass(
        self,
        string: java.lang.String | str,
        stringArray: list[java.lang.String] | jpype.JArray,
        classLoader: java.lang.ClassLoader,
    ) -> type[typing.Any]: ...

class RMIClientSocketFactory:
    def createSocket(
        self, string: java.lang.String | str, int: int
    ) -> java.net.Socket: ...

class RMIFailureHandler:
    def failure(self, exception: java.lang.Exception) -> bool: ...

class RMIServerSocketFactory:
    def createServerSocket(self, int: int) -> java.net.ServerSocket: ...

class RemoteCall:
    def done(self) -> None: ...
    def executeCall(self) -> None: ...
    def getInputStream(self) -> java.io.ObjectInput: ...
    def getOutputStream(self) -> java.io.ObjectOutput: ...
    def getResultStream(self, boolean: bool) -> java.io.ObjectOutput: ...
    def releaseInputStream(self) -> None: ...
    def releaseOutputStream(self) -> None: ...

class RemoteObject(java.rmi.Remote, java.io.Serializable):
    def equals(self, object: typing.Any) -> bool: ...
    def getRef(self) -> RemoteRef: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def toStub(remote: java.rmi.Remote) -> java.rmi.Remote: ...

class RemoteRef(java.io.Externalizable):
    serialVersionUID: typing.ClassVar[int] = ...
    packagePrefix: typing.ClassVar[java.lang.String] = ...
    def done(self, remoteCall: RemoteCall) -> None: ...
    def getRefClass(self, objectOutput: java.io.ObjectOutput) -> java.lang.String: ...
    @typing.overload
    def invoke(
        self,
        remote: java.rmi.Remote,
        method: java.lang.reflect.Method,
        objectArray: list[typing.Any] | jpype.JArray,
        long: int,
    ) -> typing.Any: ...
    @typing.overload
    def invoke(self, remoteCall: RemoteCall) -> None: ...
    def newCall(
        self,
        remoteObject: RemoteObject,
        operationArray: list[Operation] | jpype.JArray,
        int: int,
        long: int,
    ) -> RemoteCall: ...
    def remoteEquals(self, remoteRef: RemoteRef) -> bool: ...
    def remoteHashCode(self) -> int: ...
    def remoteToString(self) -> java.lang.String: ...

class ServerCloneException(java.lang.CloneNotSupportedException):
    detail: java.lang.Exception = ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, exception: java.lang.Exception
    ): ...
    def getCause(self) -> java.lang.Throwable: ...
    def getMessage(self) -> java.lang.String: ...

class ServerNotActiveException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class Skeleton:
    def dispatch(
        self, remote: java.rmi.Remote, remoteCall: RemoteCall, int: int, long: int
    ) -> None: ...
    def getOperations(self) -> typing.MutableSequence[Operation]: ...

class SkeletonMismatchException(java.rmi.RemoteException):
    def __init__(self, string: java.lang.String | str): ...

class SkeletonNotFoundException(java.rmi.RemoteException):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, exception: java.lang.Exception
    ): ...

class UID(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, short: int): ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def read(dataInput: java.io.DataInput) -> UID: ...
    def toString(self) -> java.lang.String: ...
    def write(self, dataOutput: java.io.DataOutput) -> None: ...

class Unreferenced:
    def unreferenced(self) -> None: ...

class RMISocketFactory(RMIClientSocketFactory, RMIServerSocketFactory):
    def __init__(self): ...
    def createServerSocket(self, int: int) -> java.net.ServerSocket: ...
    def createSocket(
        self, string: java.lang.String | str, int: int
    ) -> java.net.Socket: ...
    @staticmethod
    def getDefaultSocketFactory() -> RMISocketFactory: ...
    @staticmethod
    def getFailureHandler() -> RMIFailureHandler: ...
    @staticmethod
    def getSocketFactory() -> RMISocketFactory: ...
    @staticmethod
    def setFailureHandler(
        rMIFailureHandler: RMIFailureHandler | typing.Callable,
    ) -> None: ...
    @staticmethod
    def setSocketFactory(rMISocketFactory: RMISocketFactory) -> None: ...

class RemoteObjectInvocationHandler(RemoteObject, java.lang.reflect.InvocationHandler):
    def __init__(self, remoteRef: RemoteRef): ...
    def invoke(
        self,
        object: typing.Any,
        method: java.lang.reflect.Method,
        objectArray: list[typing.Any] | jpype.JArray,
    ) -> typing.Any: ...

class RemoteServer(RemoteObject):
    @staticmethod
    def getClientHost() -> java.lang.String: ...
    @staticmethod
    def getLog() -> java.io.PrintStream: ...
    @staticmethod
    def setLog(outputStream: java.io.OutputStream) -> None: ...

class RemoteStub(RemoteObject): ...

class ServerRef(RemoteRef):
    serialVersionUID: typing.ClassVar[int] = ...
    def exportObject(
        self, remote: java.rmi.Remote, object: typing.Any
    ) -> RemoteStub: ...
    def getClientHost(self) -> java.lang.String: ...

class SocketSecurityException(ExportException):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, exception: java.lang.Exception
    ): ...

class UnicastRemoteObject(RemoteServer):
    def clone(self) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def exportObject(remote: java.rmi.Remote, int: int) -> java.rmi.Remote: ...
    @typing.overload
    @staticmethod
    def exportObject(
        remote: java.rmi.Remote,
        int: int,
        objectInputFilter: java.io.ObjectInputFilter | typing.Callable,
    ) -> java.rmi.Remote: ...
    @typing.overload
    @staticmethod
    def exportObject(
        remote: java.rmi.Remote,
        int: int,
        rMIClientSocketFactory: RMIClientSocketFactory | typing.Callable,
        rMIServerSocketFactory: RMIServerSocketFactory | typing.Callable,
    ) -> java.rmi.Remote: ...
    @typing.overload
    @staticmethod
    def exportObject(
        remote: java.rmi.Remote,
        int: int,
        rMIClientSocketFactory: RMIClientSocketFactory | typing.Callable,
        rMIServerSocketFactory: RMIServerSocketFactory | typing.Callable,
        objectInputFilter: java.io.ObjectInputFilter | typing.Callable,
    ) -> java.rmi.Remote: ...
    @typing.overload
    @staticmethod
    def exportObject(remote: java.rmi.Remote) -> RemoteStub: ...
    @staticmethod
    def unexportObject(remote: java.rmi.Remote, boolean: bool) -> bool: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.rmi.server")``.

    ExportException: type[ExportException]
    LoaderHandler: type[LoaderHandler]
    LogStream: type[LogStream]
    ObjID: type[ObjID]
    Operation: type[Operation]
    RMIClassLoader: type[RMIClassLoader]
    RMIClassLoaderSpi: type[RMIClassLoaderSpi]
    RMIClientSocketFactory: type[RMIClientSocketFactory]
    RMIFailureHandler: type[RMIFailureHandler]
    RMIServerSocketFactory: type[RMIServerSocketFactory]
    RMISocketFactory: type[RMISocketFactory]
    RemoteCall: type[RemoteCall]
    RemoteObject: type[RemoteObject]
    RemoteObjectInvocationHandler: type[RemoteObjectInvocationHandler]
    RemoteRef: type[RemoteRef]
    RemoteServer: type[RemoteServer]
    RemoteStub: type[RemoteStub]
    ServerCloneException: type[ServerCloneException]
    ServerNotActiveException: type[ServerNotActiveException]
    ServerRef: type[ServerRef]
    Skeleton: type[Skeleton]
    SkeletonMismatchException: type[SkeletonMismatchException]
    SkeletonNotFoundException: type[SkeletonNotFoundException]
    SocketSecurityException: type[SocketSecurityException]
    UID: type[UID]
    UnicastRemoteObject: type[UnicastRemoteObject]
    Unreferenced: type[Unreferenced]
