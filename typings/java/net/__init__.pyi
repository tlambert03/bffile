import builtins
import typing
from typing import Protocol

import java.io
import java.lang
import java.net.http
import java.net.spi
import java.nio.channels
import java.nio.charset
import java.nio.file
import java.security
import java.security.cert
import java.util
import java.util.jar
import java.util.stream
import javax.net.ssl
import jpype
import jpype.protocol

class Authenticator:
    def __init__(self): ...
    @staticmethod
    def getDefault() -> Authenticator: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(
        string: java.lang.String | str,
        inetAddress: InetAddress,
        int: int,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
    ) -> PasswordAuthentication: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(
        string: java.lang.String | str,
        inetAddress: InetAddress,
        int: int,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        uRL: URL,
        requestorType: Authenticator.RequestorType,
    ) -> PasswordAuthentication: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(
        authenticator: Authenticator,
        string: java.lang.String | str,
        inetAddress: InetAddress,
        int: int,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        uRL: URL,
        requestorType: Authenticator.RequestorType,
    ) -> PasswordAuthentication: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(
        inetAddress: InetAddress,
        int: int,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ) -> PasswordAuthentication: ...
    def requestPasswordAuthenticationInstance(
        self,
        string: java.lang.String | str,
        inetAddress: InetAddress,
        int: int,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        uRL: URL,
        requestorType: Authenticator.RequestorType,
    ) -> PasswordAuthentication: ...
    @staticmethod
    def setDefault(authenticator: Authenticator) -> None: ...
    class RequestorType(java.lang.Enum["Authenticator.RequestorType"]):
        PROXY: typing.ClassVar[Authenticator.RequestorType] = ...
        SERVER: typing.ClassVar[Authenticator.RequestorType] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> Authenticator.RequestorType: ...
        @staticmethod
        def values() -> typing.MutableSequence[Authenticator.RequestorType]: ...

class CacheRequest:
    def __init__(self): ...
    def abort(self) -> None: ...
    def getBody(self) -> java.io.OutputStream: ...

class CacheResponse:
    def __init__(self): ...
    def getBody(self) -> java.io.InputStream: ...
    def getHeaders(
        self,
    ) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...

class ContentHandler:
    def __init__(self): ...
    @typing.overload
    def getContent(self, uRLConnection: URLConnection) -> typing.Any: ...
    @typing.overload
    def getContent(
        self, uRLConnection: URLConnection, classArray: list[type] | jpype.JArray
    ) -> typing.Any: ...

class ContentHandlerFactory:
    def createContentHandler(
        self, string: java.lang.String | str
    ) -> ContentHandler: ...

class CookieHandler:
    def __init__(self): ...
    def get(
        self,
        uRI: URI,
        map: java.util.Map[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ]
        | typing.Mapping[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ],
    ) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    @staticmethod
    def getDefault() -> CookieHandler: ...
    def put(
        self,
        uRI: URI,
        map: java.util.Map[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ]
        | typing.Mapping[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ],
    ) -> None: ...
    @staticmethod
    def setDefault(cookieHandler: CookieHandler) -> None: ...

class CookiePolicy:
    ACCEPT_ALL: typing.ClassVar[CookiePolicy] = ...
    ACCEPT_NONE: typing.ClassVar[CookiePolicy] = ...
    ACCEPT_ORIGINAL_SERVER: typing.ClassVar[CookiePolicy] = ...
    def shouldAccept(self, uRI: URI, httpCookie: HttpCookie) -> bool: ...

class CookieStore:
    def add(self, uRI: URI, httpCookie: HttpCookie) -> None: ...
    def get(self, uRI: URI) -> java.util.List[HttpCookie]: ...
    def getCookies(self) -> java.util.List[HttpCookie]: ...
    def getURIs(self) -> java.util.List[URI]: ...
    def remove(self, uRI: URI, httpCookie: HttpCookie) -> bool: ...
    def removeAll(self) -> bool: ...

class DatagramPacket:
    @typing.overload
    def __init__(self, byteArray: list[int] | jpype.JArray | bytes, int: int): ...
    @typing.overload
    def __init__(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ): ...
    @typing.overload
    def __init__(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        inetAddress: InetAddress,
        int3: int,
    ): ...
    @typing.overload
    def __init__(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        int2: int,
        socketAddress: SocketAddress,
    ): ...
    @typing.overload
    def __init__(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        inetAddress: InetAddress,
        int2: int,
    ): ...
    @typing.overload
    def __init__(
        self,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
        socketAddress: SocketAddress,
    ): ...
    def getAddress(self) -> InetAddress: ...
    def getData(self) -> typing.MutableSequence[int]: ...
    def getLength(self) -> int: ...
    def getOffset(self) -> int: ...
    def getPort(self) -> int: ...
    def getSocketAddress(self) -> SocketAddress: ...
    def setAddress(self, inetAddress: InetAddress) -> None: ...
    @typing.overload
    def setData(self, byteArray: list[int] | jpype.JArray | bytes) -> None: ...
    @typing.overload
    def setData(
        self, byteArray: list[int] | jpype.JArray | bytes, int: int, int2: int
    ) -> None: ...
    def setLength(self, int: int) -> None: ...
    def setPort(self, int: int) -> None: ...
    def setSocketAddress(self, socketAddress: SocketAddress) -> None: ...

class DatagramSocket(java.io.Closeable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, inetAddress: InetAddress): ...
    @typing.overload
    def __init__(self, socketAddress: SocketAddress): ...
    def bind(self, socketAddress: SocketAddress) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, inetAddress: InetAddress, int: int) -> None: ...
    @typing.overload
    def connect(self, socketAddress: SocketAddress) -> None: ...
    def disconnect(self) -> None: ...
    def getBroadcast(self) -> bool: ...
    def getChannel(self) -> java.nio.channels.DatagramChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getLocalAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    _getOption__T = typing.TypeVar("_getOption__T")  # <T>
    def getOption(self, socketOption: SocketOption[_getOption__T]) -> _getOption__T: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> SocketAddress: ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def joinGroup(
        self, socketAddress: SocketAddress, networkInterface: NetworkInterface
    ) -> None: ...
    def leaveGroup(
        self, socketAddress: SocketAddress, networkInterface: NetworkInterface
    ) -> None: ...
    def receive(self, datagramPacket: DatagramPacket) -> None: ...
    def send(self, datagramPacket: DatagramPacket) -> None: ...
    def setBroadcast(self, boolean: bool) -> None: ...
    @staticmethod
    def setDatagramSocketImplFactory(
        datagramSocketImplFactory: DatagramSocketImplFactory | typing.Callable,
    ) -> None: ...
    _setOption__T = typing.TypeVar("_setOption__T")  # <T>
    def setOption(
        self, socketOption: SocketOption[_setOption__T], t: _setOption__T
    ) -> DatagramSocket: ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSendBufferSize(self, int: int) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    def setTrafficClass(self, int: int) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[typing.Any]]: ...

class DatagramSocketImplFactory:
    def createDatagramSocketImpl(self) -> DatagramSocketImpl: ...

class FileNameMap:
    def getContentTypeFor(self, string: java.lang.String | str) -> java.lang.String: ...

class HttpCookie(java.lang.Cloneable):
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def clone(self) -> typing.Any: ...
    @staticmethod
    def domainMatches(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getComment(self) -> java.lang.String: ...
    def getCommentURL(self) -> java.lang.String: ...
    def getDiscard(self) -> bool: ...
    def getDomain(self) -> java.lang.String: ...
    def getMaxAge(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPortlist(self) -> java.lang.String: ...
    def getSecure(self) -> bool: ...
    def getValue(self) -> java.lang.String: ...
    def getVersion(self) -> int: ...
    def hasExpired(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isHttpOnly(self) -> bool: ...
    @staticmethod
    def parse(string: java.lang.String | str) -> java.util.List[HttpCookie]: ...
    def setComment(self, string: java.lang.String | str) -> None: ...
    def setCommentURL(self, string: java.lang.String | str) -> None: ...
    def setDiscard(self, boolean: bool) -> None: ...
    def setDomain(self, string: java.lang.String | str) -> None: ...
    def setHttpOnly(self, boolean: bool) -> None: ...
    def setMaxAge(self, long: int) -> None: ...
    def setPath(self, string: java.lang.String | str) -> None: ...
    def setPortlist(self, string: java.lang.String | str) -> None: ...
    def setSecure(self, boolean: bool) -> None: ...
    def setValue(self, string: java.lang.String | str) -> None: ...
    def setVersion(self, int: int) -> None: ...
    def toString(self) -> java.lang.String: ...

class HttpRetryException(java.io.IOException):
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, int: int, string2: java.lang.String | str
    ): ...
    def getLocation(self) -> java.lang.String: ...
    def getReason(self) -> java.lang.String: ...
    def responseCode(self) -> int: ...

class IDN:
    ALLOW_UNASSIGNED: typing.ClassVar[int] = ...
    USE_STD3_ASCII_RULES: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def toASCII(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def toASCII(string: java.lang.String | str, int: int) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def toUnicode(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def toUnicode(string: java.lang.String | str, int: int) -> java.lang.String: ...

class InetAddress(java.io.Serializable):
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.MutableSequence[int]: ...
    @staticmethod
    def getAllByName(
        string: java.lang.String | str,
    ) -> typing.MutableSequence[InetAddress]: ...
    @typing.overload
    @staticmethod
    def getByAddress(byteArray: list[int] | jpype.JArray | bytes) -> InetAddress: ...
    @typing.overload
    @staticmethod
    def getByAddress(
        string: java.lang.String | str, byteArray: list[int] | jpype.JArray | bytes
    ) -> InetAddress: ...
    @staticmethod
    def getByName(string: java.lang.String | str) -> InetAddress: ...
    def getCanonicalHostName(self) -> java.lang.String: ...
    def getHostAddress(self) -> java.lang.String: ...
    def getHostName(self) -> java.lang.String: ...
    @staticmethod
    def getLocalHost() -> InetAddress: ...
    @staticmethod
    def getLoopbackAddress() -> InetAddress: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    @typing.overload
    def isReachable(self, int: int) -> bool: ...
    @typing.overload
    def isReachable(
        self, networkInterface: NetworkInterface, int: int, int2: int
    ) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...
    @staticmethod
    def ofLiteral(string: java.lang.String | str) -> InetAddress: ...
    def toString(self) -> java.lang.String: ...

class InterfaceAddress:
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getBroadcast(self) -> InetAddress: ...
    def getNetworkPrefixLength(self) -> int: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...

class MalformedURLException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class NetPermission(java.security.BasicPermission):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...

class NetworkInterface:
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def getByIndex(int: int) -> NetworkInterface: ...
    @staticmethod
    def getByInetAddress(inetAddress: InetAddress) -> NetworkInterface: ...
    @staticmethod
    def getByName(string: java.lang.String | str) -> NetworkInterface: ...
    def getDisplayName(self) -> java.lang.String: ...
    def getHardwareAddress(self) -> typing.MutableSequence[int]: ...
    def getIndex(self) -> int: ...
    def getInetAddresses(self) -> java.util.Enumeration[InetAddress]: ...
    def getInterfaceAddresses(self) -> java.util.List[InterfaceAddress]: ...
    def getMTU(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    @staticmethod
    def getNetworkInterfaces() -> java.util.Enumeration[NetworkInterface]: ...
    def getParent(self) -> NetworkInterface: ...
    def getSubInterfaces(self) -> java.util.Enumeration[NetworkInterface]: ...
    def hashCode(self) -> int: ...
    def inetAddresses(self) -> java.util.stream.Stream[InetAddress]: ...
    def isLoopback(self) -> bool: ...
    def isPointToPoint(self) -> bool: ...
    def isUp(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    @staticmethod
    def networkInterfaces() -> java.util.stream.Stream[NetworkInterface]: ...
    def subInterfaces(self) -> java.util.stream.Stream[NetworkInterface]: ...
    def supportsMulticast(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class PasswordAuthentication:
    def __init__(
        self, string: java.lang.String | str, charArray: list[str] | jpype.JArray
    ): ...
    def getPassword(self) -> typing.MutableSequence[str]: ...
    def getUserName(self) -> java.lang.String: ...

class ProtocolException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class ProtocolFamily:
    def name(self) -> java.lang.String: ...

class Proxy:
    NO_PROXY: typing.ClassVar[Proxy] = ...
    def __init__(self, type: Proxy.Type, socketAddress: SocketAddress): ...
    def address(self) -> SocketAddress: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> java.lang.String: ...
    def type(self) -> Proxy.Type: ...
    class Type(java.lang.Enum["Proxy.Type"]):
        DIRECT: typing.ClassVar[Proxy.Type] = ...
        HTTP: typing.ClassVar[Proxy.Type] = ...
        SOCKS: typing.ClassVar[Proxy.Type] = ...
        _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(
            class_: type[_valueOf_0__T], string: java.lang.String | str
        ) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: java.lang.String | str) -> Proxy.Type: ...
        @staticmethod
        def values() -> typing.MutableSequence[Proxy.Type]: ...

class ProxySelector:
    def __init__(self): ...
    def connectFailed(
        self, uRI: URI, socketAddress: SocketAddress, iOException: java.io.IOException
    ) -> None: ...
    @staticmethod
    def getDefault() -> ProxySelector: ...
    @staticmethod
    def of(inetSocketAddress: InetSocketAddress) -> ProxySelector: ...
    def select(self, uRI: URI) -> java.util.List[Proxy]: ...
    @staticmethod
    def setDefault(proxySelector: ProxySelector) -> None: ...

class ResponseCache:
    def __init__(self): ...
    def get(
        self,
        uRI: URI,
        string: java.lang.String | str,
        map: java.util.Map[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ]
        | typing.Mapping[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ],
    ) -> CacheResponse: ...
    @staticmethod
    def getDefault() -> ResponseCache: ...
    def put(self, uRI: URI, uRLConnection: URLConnection) -> CacheRequest: ...
    @staticmethod
    def setDefault(responseCache: ResponseCache) -> None: ...

class ServerSocket(java.io.Closeable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, inetAddress: InetAddress): ...
    def accept(self) -> Socket: ...
    @typing.overload
    def bind(self, socketAddress: SocketAddress) -> None: ...
    @typing.overload
    def bind(self, socketAddress: SocketAddress, int: int) -> None: ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.ServerSocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    _getOption__T = typing.TypeVar("_getOption__T")  # <T>
    def getOption(self, socketOption: SocketOption[_getOption__T]) -> _getOption__T: ...
    def getReceiveBufferSize(self) -> int: ...
    def getReuseAddress(self) -> bool: ...
    def getSoTimeout(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    _setOption__T = typing.TypeVar("_setOption__T")  # <T>
    def setOption(
        self, socketOption: SocketOption[_setOption__T], t: _setOption__T
    ) -> ServerSocket: ...
    def setPerformancePreferences(self, int: int, int2: int, int3: int) -> None: ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    @staticmethod
    def setSocketFactory(
        socketImplFactory: SocketImplFactory | typing.Callable,
    ) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[typing.Any]]: ...
    def toString(self) -> java.lang.String: ...

class Socket(java.io.Closeable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int, boolean: bool): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        int: int,
        inetAddress: InetAddress,
        int2: int,
    ): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int, boolean: bool): ...
    @typing.overload
    def __init__(
        self, inetAddress: InetAddress, int: int, inetAddress2: InetAddress, int2: int
    ): ...
    @typing.overload
    def __init__(self, proxy: Proxy): ...
    def bind(self, socketAddress: SocketAddress) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, socketAddress: SocketAddress) -> None: ...
    @typing.overload
    def connect(self, socketAddress: SocketAddress, int: int) -> None: ...
    def getChannel(self) -> java.nio.channels.SocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getKeepAlive(self) -> bool: ...
    def getLocalAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    def getOOBInline(self) -> bool: ...
    _getOption__T = typing.TypeVar("_getOption__T")  # <T>
    def getOption(self, socketOption: SocketOption[_getOption__T]) -> _getOption__T: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> SocketAddress: ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoLinger(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTcpNoDelay(self) -> bool: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def isInputShutdown(self) -> bool: ...
    def isOutputShutdown(self) -> bool: ...
    def sendUrgentData(self, int: int) -> None: ...
    def setKeepAlive(self, boolean: bool) -> None: ...
    def setOOBInline(self, boolean: bool) -> None: ...
    _setOption__T = typing.TypeVar("_setOption__T")  # <T>
    def setOption(
        self, socketOption: SocketOption[_setOption__T], t: _setOption__T
    ) -> Socket: ...
    def setPerformancePreferences(self, int: int, int2: int, int3: int) -> None: ...
    def setReceiveBufferSize(self, int: int) -> None: ...
    def setReuseAddress(self, boolean: bool) -> None: ...
    def setSendBufferSize(self, int: int) -> None: ...
    def setSoLinger(self, boolean: bool, int: int) -> None: ...
    def setSoTimeout(self, int: int) -> None: ...
    @staticmethod
    def setSocketImplFactory(
        socketImplFactory: SocketImplFactory | typing.Callable,
    ) -> None: ...
    def setTcpNoDelay(self, boolean: bool) -> None: ...
    def setTrafficClass(self, int: int) -> None: ...
    def shutdownInput(self) -> None: ...
    def shutdownOutput(self) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[typing.Any]]: ...
    def toString(self) -> java.lang.String: ...

class SocketAddress(java.io.Serializable):
    def __init__(self): ...

class SocketException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, throwable: java.lang.Throwable
    ): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class SocketImplFactory:
    def createSocketImpl(self) -> SocketImpl: ...

_SocketOption__T = typing.TypeVar("_SocketOption__T")  # <T>

class SocketOption(typing.Generic[_SocketOption__T]):
    def name(self) -> java.lang.String: ...
    def type(self) -> builtins.type[_SocketOption__T]: ...

class SocketOptions:
    TCP_NODELAY: typing.ClassVar[int] = ...
    SO_BINDADDR: typing.ClassVar[int] = ...
    SO_REUSEADDR: typing.ClassVar[int] = ...
    SO_REUSEPORT: typing.ClassVar[int] = ...
    SO_BROADCAST: typing.ClassVar[int] = ...
    IP_MULTICAST_IF: typing.ClassVar[int] = ...
    IP_MULTICAST_IF2: typing.ClassVar[int] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[int] = ...
    IP_TOS: typing.ClassVar[int] = ...
    SO_LINGER: typing.ClassVar[int] = ...
    SO_TIMEOUT: typing.ClassVar[int] = ...
    SO_SNDBUF: typing.ClassVar[int] = ...
    SO_RCVBUF: typing.ClassVar[int] = ...
    SO_KEEPALIVE: typing.ClassVar[int] = ...
    SO_OOBINLINE: typing.ClassVar[int] = ...
    def getOption(self, int: int) -> typing.Any: ...
    def setOption(self, int: int, object: typing.Any) -> None: ...

class SocketPermission(java.security.Permission, java.io.Serializable):
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class SocketTimeoutException(java.io.InterruptedIOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class StandardSocketOptions:
    SO_BROADCAST: typing.ClassVar[SocketOption] = ...
    SO_KEEPALIVE: typing.ClassVar[SocketOption] = ...
    SO_SNDBUF: typing.ClassVar[SocketOption] = ...
    SO_RCVBUF: typing.ClassVar[SocketOption] = ...
    SO_REUSEADDR: typing.ClassVar[SocketOption] = ...
    SO_REUSEPORT: typing.ClassVar[SocketOption] = ...
    SO_LINGER: typing.ClassVar[SocketOption] = ...
    IP_TOS: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_IF: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_TTL: typing.ClassVar[SocketOption] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[SocketOption] = ...
    TCP_NODELAY: typing.ClassVar[SocketOption] = ...

class URI(java.lang.Comparable["URI"], java.io.Serializable):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        int: int,
        string4: java.lang.String | str,
        string5: java.lang.String | str,
        string6: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
        string4: java.lang.String | str,
        string5: java.lang.String | str,
    ): ...
    def compareTo(self, uRI: URI) -> int: ...
    @staticmethod
    def create(string: java.lang.String | str) -> URI: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAuthority(self) -> java.lang.String: ...
    def getFragment(self) -> java.lang.String: ...
    def getHost(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getQuery(self) -> java.lang.String: ...
    def getRawAuthority(self) -> java.lang.String: ...
    def getRawFragment(self) -> java.lang.String: ...
    def getRawPath(self) -> java.lang.String: ...
    def getRawQuery(self) -> java.lang.String: ...
    def getRawSchemeSpecificPart(self) -> java.lang.String: ...
    def getRawUserInfo(self) -> java.lang.String: ...
    def getScheme(self) -> java.lang.String: ...
    def getSchemeSpecificPart(self) -> java.lang.String: ...
    def getUserInfo(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def normalize(self) -> URI: ...
    def parseServerAuthority(self) -> URI: ...
    def relativize(self, uRI: URI) -> URI: ...
    @typing.overload
    def resolve(self, string: java.lang.String | str) -> URI: ...
    @typing.overload
    def resolve(self, uRI: URI) -> URI: ...
    def toASCIIString(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def toURL(self) -> URL: ...

class URISyntaxException(java.lang.Exception):
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str, int: int
    ): ...
    def getIndex(self) -> int: ...
    def getInput(self) -> java.lang.String: ...
    def getMessage(self) -> java.lang.String: ...
    def getReason(self) -> java.lang.String: ...

class URL(java.io.Serializable):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        int: int,
        string3: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        int: int,
        string3: java.lang.String | str,
        uRLStreamHandler: URLStreamHandler,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        string2: java.lang.String | str,
        string3: java.lang.String | str,
    ): ...
    @typing.overload
    def __init__(self, uRL: URL, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self,
        uRL: URL,
        string: java.lang.String | str,
        uRLStreamHandler: URLStreamHandler,
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAuthority(self) -> java.lang.String: ...
    @typing.overload
    def getContent(self) -> typing.Any: ...
    @typing.overload
    def getContent(
        self, classArray: list[type[typing.Any]] | jpype.JArray
    ) -> typing.Any: ...
    def getDefaultPort(self) -> int: ...
    def getFile(self) -> java.lang.String: ...
    def getHost(self) -> java.lang.String: ...
    def getPath(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def getProtocol(self) -> java.lang.String: ...
    def getQuery(self) -> java.lang.String: ...
    def getRef(self) -> java.lang.String: ...
    def getUserInfo(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def of(uRI: URI, uRLStreamHandler: URLStreamHandler) -> URL: ...
    @typing.overload
    def openConnection(self) -> URLConnection: ...
    @typing.overload
    def openConnection(self, proxy: Proxy) -> URLConnection: ...
    def openStream(self) -> java.io.InputStream: ...
    def sameFile(self, uRL: URL) -> bool: ...
    @staticmethod
    def setURLStreamHandlerFactory(
        uRLStreamHandlerFactory: URLStreamHandlerFactory | typing.Callable,
    ) -> None: ...
    def toExternalForm(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...
    def toURI(self) -> URI: ...

class URLClassLoader(java.security.SecureClassLoader, java.io.Closeable):
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        uRLArray: list[URL] | jpype.JArray,
        classLoader: java.lang.ClassLoader,
    ): ...
    @typing.overload
    def __init__(
        self,
        string: java.lang.String | str,
        uRLArray: list[URL] | jpype.JArray,
        classLoader: java.lang.ClassLoader,
        uRLStreamHandlerFactory: URLStreamHandlerFactory | typing.Callable,
    ): ...
    @typing.overload
    def __init__(self, uRLArray: list[URL] | jpype.JArray): ...
    @typing.overload
    def __init__(
        self, uRLArray: list[URL] | jpype.JArray, classLoader: java.lang.ClassLoader
    ): ...
    @typing.overload
    def __init__(
        self,
        uRLArray: list[URL] | jpype.JArray,
        classLoader: java.lang.ClassLoader,
        uRLStreamHandlerFactory: URLStreamHandlerFactory | typing.Callable,
    ): ...
    def close(self) -> None: ...
    def findResource(self, string: java.lang.String | str) -> URL: ...
    def findResources(
        self, string: java.lang.String | str
    ) -> java.util.Enumeration[URL]: ...
    def getResourceAsStream(
        self, string: java.lang.String | str
    ) -> java.io.InputStream: ...
    def getURLs(self) -> typing.MutableSequence[URL]: ...
    @typing.overload
    @staticmethod
    def newInstance(uRLArray: list[URL] | jpype.JArray) -> URLClassLoader: ...
    @typing.overload
    @staticmethod
    def newInstance(
        uRLArray: list[URL] | jpype.JArray, classLoader: java.lang.ClassLoader
    ) -> URLClassLoader: ...

class URLConnection:
    def addRequestProperty(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    def connect(self) -> None: ...
    def getAllowUserInteraction(self) -> bool: ...
    def getConnectTimeout(self) -> int: ...
    @typing.overload
    def getContent(self) -> typing.Any: ...
    @typing.overload
    def getContent(
        self, classArray: list[type[typing.Any]] | jpype.JArray
    ) -> typing.Any: ...
    def getContentEncoding(self) -> java.lang.String: ...
    def getContentLength(self) -> int: ...
    def getContentLengthLong(self) -> int: ...
    def getContentType(self) -> java.lang.String: ...
    def getDate(self) -> int: ...
    @staticmethod
    def getDefaultAllowUserInteraction() -> bool: ...
    @staticmethod
    def getDefaultRequestProperty(
        string: java.lang.String | str,
    ) -> java.lang.String: ...
    @typing.overload
    def getDefaultUseCaches(self) -> bool: ...
    @typing.overload
    @staticmethod
    def getDefaultUseCaches(string: java.lang.String | str) -> bool: ...
    def getDoInput(self) -> bool: ...
    def getDoOutput(self) -> bool: ...
    def getExpiration(self) -> int: ...
    @staticmethod
    def getFileNameMap() -> FileNameMap: ...
    @typing.overload
    def getHeaderField(self, int: int) -> java.lang.String: ...
    @typing.overload
    def getHeaderField(self, string: java.lang.String | str) -> java.lang.String: ...
    def getHeaderFieldDate(self, string: java.lang.String | str, long: int) -> int: ...
    def getHeaderFieldInt(self, string: java.lang.String | str, int: int) -> int: ...
    def getHeaderFieldKey(self, int: int) -> java.lang.String: ...
    def getHeaderFieldLong(self, string: java.lang.String | str, long: int) -> int: ...
    def getHeaderFields(
        self,
    ) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getIfModifiedSince(self) -> int: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getLastModified(self) -> int: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPermission(self) -> java.security.Permission: ...
    def getReadTimeout(self) -> int: ...
    def getRequestProperties(
        self,
    ) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getRequestProperty(
        self, string: java.lang.String | str
    ) -> java.lang.String: ...
    def getURL(self) -> URL: ...
    def getUseCaches(self) -> bool: ...
    @staticmethod
    def guessContentTypeFromName(
        string: java.lang.String | str,
    ) -> java.lang.String: ...
    @staticmethod
    def guessContentTypeFromStream(
        inputStream: java.io.InputStream,
    ) -> java.lang.String: ...
    def setAllowUserInteraction(self, boolean: bool) -> None: ...
    def setConnectTimeout(self, int: int) -> None: ...
    @staticmethod
    def setContentHandlerFactory(
        contentHandlerFactory: ContentHandlerFactory | typing.Callable,
    ) -> None: ...
    @staticmethod
    def setDefaultAllowUserInteraction(boolean: bool) -> None: ...
    @staticmethod
    def setDefaultRequestProperty(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    @typing.overload
    @staticmethod
    def setDefaultUseCaches(string: java.lang.String | str, boolean: bool) -> None: ...
    @typing.overload
    def setDefaultUseCaches(self, boolean: bool) -> None: ...
    def setDoInput(self, boolean: bool) -> None: ...
    def setDoOutput(self, boolean: bool) -> None: ...
    @staticmethod
    def setFileNameMap(fileNameMap: FileNameMap | typing.Callable) -> None: ...
    def setIfModifiedSince(self, long: int) -> None: ...
    def setReadTimeout(self, int: int) -> None: ...
    def setRequestProperty(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ) -> None: ...
    def setUseCaches(self, boolean: bool) -> None: ...
    def toString(self) -> java.lang.String: ...

class URLDecoder:
    @typing.overload
    @staticmethod
    def decode(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def decode(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def decode(
        string: java.lang.String | str, charset: java.nio.charset.Charset
    ) -> java.lang.String: ...

class URLEncoder:
    @typing.overload
    @staticmethod
    def encode(string: java.lang.String | str) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def encode(
        string: java.lang.String | str, string2: java.lang.String | str
    ) -> java.lang.String: ...
    @typing.overload
    @staticmethod
    def encode(
        string: java.lang.String | str, charset: java.nio.charset.Charset
    ) -> java.lang.String: ...

class URLPermission(java.security.Permission):
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...
    @typing.overload
    def __init__(
        self, string: java.lang.String | str, string2: java.lang.String | str
    ): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...

class URLStreamHandler:
    def __init__(self): ...

class URLStreamHandlerFactory:
    def createURLStreamHandler(
        self, string: java.lang.String | str
    ) -> URLStreamHandler: ...

class UnknownHostException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class UnknownServiceException(java.io.IOException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class BindException(SocketException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class ConnectException(SocketException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class CookieManager(CookieHandler):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(
        self, cookieStore: CookieStore, cookiePolicy: CookiePolicy | typing.Callable
    ): ...
    def get(
        self,
        uRI: URI,
        map: java.util.Map[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ]
        | typing.Mapping[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ],
    ) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getCookieStore(self) -> CookieStore: ...
    def put(
        self,
        uRI: URI,
        map: java.util.Map[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ]
        | typing.Mapping[
            java.lang.String | str, java.util.List[java.lang.String | str]
        ],
    ) -> None: ...
    def setCookiePolicy(self, cookiePolicy: CookiePolicy | typing.Callable) -> None: ...

class DatagramSocketImpl(SocketOptions):
    def __init__(self): ...

class HttpURLConnection(URLConnection):
    HTTP_OK: typing.ClassVar[int] = ...
    HTTP_CREATED: typing.ClassVar[int] = ...
    HTTP_ACCEPTED: typing.ClassVar[int] = ...
    HTTP_NOT_AUTHORITATIVE: typing.ClassVar[int] = ...
    HTTP_NO_CONTENT: typing.ClassVar[int] = ...
    HTTP_RESET: typing.ClassVar[int] = ...
    HTTP_PARTIAL: typing.ClassVar[int] = ...
    HTTP_MULT_CHOICE: typing.ClassVar[int] = ...
    HTTP_MOVED_PERM: typing.ClassVar[int] = ...
    HTTP_MOVED_TEMP: typing.ClassVar[int] = ...
    HTTP_SEE_OTHER: typing.ClassVar[int] = ...
    HTTP_NOT_MODIFIED: typing.ClassVar[int] = ...
    HTTP_USE_PROXY: typing.ClassVar[int] = ...
    HTTP_BAD_REQUEST: typing.ClassVar[int] = ...
    HTTP_UNAUTHORIZED: typing.ClassVar[int] = ...
    HTTP_PAYMENT_REQUIRED: typing.ClassVar[int] = ...
    HTTP_FORBIDDEN: typing.ClassVar[int] = ...
    HTTP_NOT_FOUND: typing.ClassVar[int] = ...
    HTTP_BAD_METHOD: typing.ClassVar[int] = ...
    HTTP_NOT_ACCEPTABLE: typing.ClassVar[int] = ...
    HTTP_PROXY_AUTH: typing.ClassVar[int] = ...
    HTTP_CLIENT_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_CONFLICT: typing.ClassVar[int] = ...
    HTTP_GONE: typing.ClassVar[int] = ...
    HTTP_LENGTH_REQUIRED: typing.ClassVar[int] = ...
    HTTP_PRECON_FAILED: typing.ClassVar[int] = ...
    HTTP_ENTITY_TOO_LARGE: typing.ClassVar[int] = ...
    HTTP_REQ_TOO_LONG: typing.ClassVar[int] = ...
    HTTP_UNSUPPORTED_TYPE: typing.ClassVar[int] = ...
    HTTP_SERVER_ERROR: typing.ClassVar[int] = ...
    HTTP_INTERNAL_ERROR: typing.ClassVar[int] = ...
    HTTP_NOT_IMPLEMENTED: typing.ClassVar[int] = ...
    HTTP_BAD_GATEWAY: typing.ClassVar[int] = ...
    HTTP_UNAVAILABLE: typing.ClassVar[int] = ...
    HTTP_GATEWAY_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_VERSION: typing.ClassVar[int] = ...
    def disconnect(self) -> None: ...
    def getErrorStream(self) -> java.io.InputStream: ...
    @staticmethod
    def getFollowRedirects() -> bool: ...
    @typing.overload
    def getHeaderField(self, int: int) -> java.lang.String: ...
    @typing.overload
    def getHeaderField(self, string: java.lang.String | str) -> java.lang.String: ...
    def getHeaderFieldDate(self, string: java.lang.String | str, long: int) -> int: ...
    def getHeaderFieldKey(self, int: int) -> java.lang.String: ...
    def getInstanceFollowRedirects(self) -> bool: ...
    def getPermission(self) -> java.security.Permission: ...
    def getRequestMethod(self) -> java.lang.String: ...
    def getResponseCode(self) -> int: ...
    def getResponseMessage(self) -> java.lang.String: ...
    def setAuthenticator(self, authenticator: Authenticator) -> None: ...
    def setChunkedStreamingMode(self, int: int) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, int: int) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, long: int) -> None: ...
    @staticmethod
    def setFollowRedirects(boolean: bool) -> None: ...
    def setInstanceFollowRedirects(self, boolean: bool) -> None: ...
    def setRequestMethod(self, string: java.lang.String | str) -> None: ...
    def usingProxy(self) -> bool: ...

class Inet4Address(InetAddress):
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.MutableSequence[int]: ...
    def getHostAddress(self) -> java.lang.String: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...
    @typing.overload
    @staticmethod
    def ofLiteral(string: java.lang.String | str) -> Inet4Address: ...
    @typing.overload
    @staticmethod
    def ofLiteral(string: java.lang.String | str) -> InetAddress: ...
    @staticmethod
    def ofPosixLiteral(string: java.lang.String | str) -> Inet4Address: ...

class Inet6Address(InetAddress):
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def getByAddress(
        string: java.lang.String | str,
        byteArray: list[int] | jpype.JArray | bytes,
        int: int,
    ) -> Inet6Address: ...
    @typing.overload
    @staticmethod
    def getByAddress(
        string: java.lang.String | str,
        byteArray: list[int] | jpype.JArray | bytes,
        networkInterface: NetworkInterface,
    ) -> Inet6Address: ...
    @typing.overload
    @staticmethod
    def getByAddress(byteArray: list[int] | jpype.JArray | bytes) -> InetAddress: ...
    @typing.overload
    @staticmethod
    def getByAddress(
        string: java.lang.String | str, byteArray: list[int] | jpype.JArray | bytes
    ) -> InetAddress: ...
    def getHostAddress(self) -> java.lang.String: ...
    def getScopeId(self) -> int: ...
    def getScopedInterface(self) -> NetworkInterface: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isIPv4CompatibleAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...
    @staticmethod
    def ofLiteral(string: java.lang.String | str) -> InetAddress: ...

class InetSocketAddress(SocketAddress):
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str, int: int): ...
    @typing.overload
    def __init__(self, inetAddress: InetAddress, int: int): ...
    @staticmethod
    def createUnresolved(
        string: java.lang.String | str, int: int
    ) -> InetSocketAddress: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getHostName(self) -> java.lang.String: ...
    def getHostString(self) -> java.lang.String: ...
    def getPort(self) -> int: ...
    def hashCode(self) -> int: ...
    def isUnresolved(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class JarURLConnection(URLConnection):
    def getAttributes(self) -> java.util.jar.Attributes: ...
    def getCertificates(
        self,
    ) -> typing.MutableSequence[java.security.cert.Certificate]: ...
    def getEntryName(self) -> java.lang.String: ...
    def getJarEntry(self) -> java.util.jar.JarEntry: ...
    def getJarFile(self) -> java.util.jar.JarFile: ...
    def getJarFileURL(self) -> URL: ...
    def getMainAttributes(self) -> java.util.jar.Attributes: ...
    def getManifest(self) -> java.util.jar.Manifest: ...

class MulticastSocket(DatagramSocket):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, socketAddress: SocketAddress): ...
    def getInterface(self) -> InetAddress: ...
    def getLoopbackMode(self) -> bool: ...
    def getNetworkInterface(self) -> NetworkInterface: ...
    def getTTL(self) -> int: ...
    def getTimeToLive(self) -> int: ...
    @typing.overload
    def joinGroup(self, inetAddress: InetAddress) -> None: ...
    @typing.overload
    def joinGroup(
        self, socketAddress: SocketAddress, networkInterface: NetworkInterface
    ) -> None: ...
    @typing.overload
    def leaveGroup(self, inetAddress: InetAddress) -> None: ...
    @typing.overload
    def leaveGroup(
        self, socketAddress: SocketAddress, networkInterface: NetworkInterface
    ) -> None: ...
    @typing.overload
    def send(self, datagramPacket: DatagramPacket) -> None: ...
    @typing.overload
    def send(self, datagramPacket: DatagramPacket, byte: int) -> None: ...
    def setInterface(self, inetAddress: InetAddress) -> None: ...
    def setLoopbackMode(self, boolean: bool) -> None: ...
    def setNetworkInterface(self, networkInterface: NetworkInterface) -> None: ...
    def setTTL(self, byte: int) -> None: ...
    def setTimeToLive(self, int: int) -> None: ...

class NoRouteToHostException(SocketException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class PortUnreachableException(SocketException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: java.lang.String | str): ...

class SecureCacheResponse(CacheResponse):
    def __init__(self): ...
    def getCipherSuite(self) -> java.lang.String: ...
    def getLocalCertificateChain(
        self,
    ) -> java.util.List[java.security.cert.Certificate]: ...
    def getLocalPrincipal(self) -> java.security.Principal: ...
    def getPeerPrincipal(self) -> java.security.Principal: ...
    def getSSLSession(self) -> java.util.Optional[javax.net.ssl.SSLSession]: ...
    def getServerCertificateChain(
        self,
    ) -> java.util.List[java.security.cert.Certificate]: ...

class SocketImpl(SocketOptions):
    def __init__(self): ...
    def toString(self) -> java.lang.String: ...

class StandardProtocolFamily(java.lang.Enum["StandardProtocolFamily"], ProtocolFamily):
    INET: typing.ClassVar[StandardProtocolFamily] = ...
    INET6: typing.ClassVar[StandardProtocolFamily] = ...
    UNIX: typing.ClassVar[StandardProtocolFamily] = ...
    _valueOf_0__T = typing.TypeVar("_valueOf_0__T", bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(
        class_: type[_valueOf_0__T], string: java.lang.String | str
    ) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: java.lang.String | str) -> StandardProtocolFamily: ...
    @staticmethod
    def values() -> typing.MutableSequence[StandardProtocolFamily]: ...

class UnixDomainSocketAddress(SocketAddress):
    def equals(self, object: typing.Any) -> bool: ...
    def getPath(self) -> java.nio.file.Path: ...
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def of(string: java.lang.String | str) -> UnixDomainSocketAddress: ...
    @typing.overload
    @staticmethod
    def of(
        path: java.nio.file.Path | jpype.protocol.SupportsPath,
    ) -> UnixDomainSocketAddress: ...
    def toString(self) -> java.lang.String: ...

class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.net")``.

    Authenticator: type[Authenticator]
    BindException: type[BindException]
    CacheRequest: type[CacheRequest]
    CacheResponse: type[CacheResponse]
    ConnectException: type[ConnectException]
    ContentHandler: type[ContentHandler]
    ContentHandlerFactory: type[ContentHandlerFactory]
    CookieHandler: type[CookieHandler]
    CookieManager: type[CookieManager]
    CookiePolicy: type[CookiePolicy]
    CookieStore: type[CookieStore]
    DatagramPacket: type[DatagramPacket]
    DatagramSocket: type[DatagramSocket]
    DatagramSocketImpl: type[DatagramSocketImpl]
    DatagramSocketImplFactory: type[DatagramSocketImplFactory]
    FileNameMap: type[FileNameMap]
    HttpCookie: type[HttpCookie]
    HttpRetryException: type[HttpRetryException]
    HttpURLConnection: type[HttpURLConnection]
    IDN: type[IDN]
    Inet4Address: type[Inet4Address]
    Inet6Address: type[Inet6Address]
    InetAddress: type[InetAddress]
    InetSocketAddress: type[InetSocketAddress]
    InterfaceAddress: type[InterfaceAddress]
    JarURLConnection: type[JarURLConnection]
    MalformedURLException: type[MalformedURLException]
    MulticastSocket: type[MulticastSocket]
    NetPermission: type[NetPermission]
    NetworkInterface: type[NetworkInterface]
    NoRouteToHostException: type[NoRouteToHostException]
    PasswordAuthentication: type[PasswordAuthentication]
    PortUnreachableException: type[PortUnreachableException]
    ProtocolException: type[ProtocolException]
    ProtocolFamily: type[ProtocolFamily]
    Proxy: type[Proxy]
    ProxySelector: type[ProxySelector]
    ResponseCache: type[ResponseCache]
    SecureCacheResponse: type[SecureCacheResponse]
    ServerSocket: type[ServerSocket]
    Socket: type[Socket]
    SocketAddress: type[SocketAddress]
    SocketException: type[SocketException]
    SocketImpl: type[SocketImpl]
    SocketImplFactory: type[SocketImplFactory]
    SocketOption: type[SocketOption]
    SocketOptions: type[SocketOptions]
    SocketPermission: type[SocketPermission]
    SocketTimeoutException: type[SocketTimeoutException]
    StandardProtocolFamily: type[StandardProtocolFamily]
    StandardSocketOptions: type[StandardSocketOptions]
    URI: type[URI]
    URISyntaxException: type[URISyntaxException]
    URL: type[URL]
    URLClassLoader: type[URLClassLoader]
    URLConnection: type[URLConnection]
    URLDecoder: type[URLDecoder]
    URLEncoder: type[URLEncoder]
    URLPermission: type[URLPermission]
    URLStreamHandler: type[URLStreamHandler]
    URLStreamHandlerFactory: type[URLStreamHandlerFactory]
    UnixDomainSocketAddress: type[UnixDomainSocketAddress]
    UnknownHostException: type[UnknownHostException]
    UnknownServiceException: type[UnknownServiceException]
    http: java.net.http.__module_protocol__
    spi: java.net.spi.__module_protocol__
